<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL存储过程和调度</title>
    <url>/2015/08/13/MySQL-Procedure/</url>
    <content><![CDATA[<h2 id="MySQL存储过程和调度简单示例"><a href="#MySQL存储过程和调度简单示例" class="headerlink" title="MySQL存储过程和调度简单示例"></a>MySQL存储过程和调度简单示例</h2><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><blockquote>
<p>一个简单的存储过程示例        </p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE test;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> IF <span class="keyword">EXISTS</span> sp_switch_group_trade;</span><br><span class="line"><span class="comment">-- 声明结束标记，防止遇到;就结束</span></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> sp_switch_group_trade () </span><br><span class="line"><span class="comment">-- 作者：杨龙</span></span><br><span class="line"><span class="comment">-- 功能：将blog分表中的行业转换到主表中</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="comment">-- 变量申明</span></span><br><span class="line">  <span class="keyword">DECLARE</span> v_trade <span class="type">VARCHAR</span> (<span class="number">20</span>) ;</span><br><span class="line">  <span class="keyword">DECLARE</span> v_id <span class="type">BIGINT</span> ;</span><br><span class="line">  <span class="keyword">DECLARE</span> end_flag <span class="type">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="literal">FALSE</span> ;</span><br><span class="line">  <span class="comment">-- 游标查询转换分表中的行业</span></span><br><span class="line">  <span class="keyword">DECLARE</span> cur <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> </span><br><span class="line">  <span class="keyword">SELECT</span> </span><br><span class="line">    <span class="keyword">CASE</span></span><br><span class="line">      t.trade_id </span><br><span class="line">      <span class="keyword">WHEN</span> <span class="string">&#x27;100100&#x27;</span> </span><br><span class="line">      <span class="keyword">THEN</span> <span class="string">&#x27;1&#x27;</span> </span><br><span class="line">      <span class="keyword">WHEN</span> <span class="string">&#x27;100101&#x27;</span> </span><br><span class="line">      <span class="keyword">THEN</span> <span class="string">&#x27;2&#x27;</span> </span><br><span class="line">      <span class="keyword">WHEN</span> <span class="string">&#x27;100102&#x27;</span> </span><br><span class="line">      <span class="keyword">THEN</span> <span class="string">&#x27;3&#x27;</span> </span><br><span class="line">      <span class="keyword">WHEN</span> <span class="string">&#x27;100103&#x27;</span> </span><br><span class="line">      <span class="keyword">THEN</span> <span class="string">&#x27;4&#x27;</span> </span><br><span class="line">      <span class="keyword">WHEN</span> <span class="string">&#x27;100104&#x27;</span> </span><br><span class="line">      <span class="keyword">THEN</span> <span class="string">&#x27;5&#x27;</span> </span><br><span class="line">      <span class="keyword">ELSE</span> <span class="string">&#x27;0&#x27;</span> </span><br><span class="line">    <span class="keyword">END</span> trade,</span><br><span class="line">    t.id </span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    industry t </span><br><span class="line">  <span class="keyword">WHERE</span>  </span><br><span class="line">    t.status <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> ;</span><br><span class="line">  <span class="comment">-- 游标标记</span></span><br><span class="line">  <span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> end_flag <span class="operator">=</span> <span class="literal">TRUE</span> ;</span><br><span class="line">  <span class="comment">--打开游标，开始逐行读取</span></span><br><span class="line">  <span class="keyword">OPEN</span> cur ;</span><br><span class="line">    read_loop : LOOP</span><br><span class="line">      <span class="comment">-- 获取游标数据</span></span><br><span class="line">      <span class="keyword">FETCH</span> cur <span class="keyword">INTO</span> v_trade,v_id;</span><br><span class="line">      <span class="comment">-- 循环跳出判断</span></span><br><span class="line">      IF end_flag </span><br><span class="line">        <span class="keyword">THEN</span> LEAVE read_loop;</span><br><span class="line">      <span class="keyword">END</span> IF ;</span><br><span class="line">      <span class="comment">-- 操作执行语句块</span></span><br><span class="line">      UPDATE </span><br><span class="line">        main_trade </span><br><span class="line">      <span class="keyword">SET</span></span><br><span class="line">        trade <span class="operator">=</span> v_trade </span><br><span class="line">      <span class="keyword">WHERE</span> group_id <span class="operator">=</span> v_id ;</span><br><span class="line">    <span class="keyword">END</span> LOOP ;</span><br><span class="line">  <span class="keyword">CLOSE</span> cur ;</span><br><span class="line"><span class="keyword">END</span> ;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="事件调度"><a href="#事件调度" class="headerlink" title="事件调度"></a>事件调度</h3><blockquote>
<p>事件调度示例，完成存储过程的调用，有3个无出入参数的存储过程，将每天顺序执行一次   </p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> event_scheduler <span class="operator">=</span> <span class="keyword">ON</span>;</span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="comment">-- 杨龙，定时任务，转换行业    </span></span><br><span class="line"><span class="keyword">CREATE</span> EVENT ev_trade</span><br><span class="line"><span class="keyword">ON</span> SCHEDULE</span><br><span class="line"><span class="comment">-- 设置执行间隔时间EVERY 1 DAY每天，STARTS CURRENT_TIMESTAMP + INTERVAL 30 MINUTE当前时间后的30分钟开始第一次执行</span></span><br><span class="line"><span class="keyword">EVERY</span> <span class="number">1</span> <span class="keyword">DAY</span> STARTS <span class="built_in">CURRENT_TIMESTAMP</span> <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">30</span> <span class="keyword">MINUTE</span> </span><br><span class="line">DO</span><br><span class="line">  <span class="keyword">BEGIN</span></span><br><span class="line">      <span class="keyword">CALL</span> sp_switch_trade1();</span><br><span class="line">      <span class="keyword">CALL</span> sp_switch_trade2();</span><br><span class="line">      <span class="keyword">CALL</span> sp_switch_trade3();</span><br><span class="line">  <span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<h4 id="如果SET-GLOBAL-event-scheduler-ON报错，检查MySQL配置文件是否配置了"><a href="#如果SET-GLOBAL-event-scheduler-ON报错，检查MySQL配置文件是否配置了" class="headerlink" title="如果SET GLOBAL event_scheduler = ON报错，检查MySQL配置文件是否配置了"></a>如果<strong>SET GLOBAL event_scheduler = ON</strong>报错，检查MySQL配置文件是否配置了</h4><blockquote>
<p>skip-grant-tables<br>如果配置了，将其注释掉，然后重启MySQL</p>
</blockquote>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>mysql存储过程</tag>
        <tag>mysql事件</tag>
      </tags>
  </entry>
  <entry>
    <title>去掉java项目URL地址栏后面的&quot;;JEESESSIONID=&quot;</title>
    <url>/2015/07/07/del-jeesessionid/</url>
    <content><![CDATA[<h1 id="关于JEESESSIONID"><a href="#关于JEESESSIONID" class="headerlink" title="关于JEESESSIONID"></a>关于JEESESSIONID</h1><p>一般的J2EE项目，默认会使用JEESESSIONID作为会话id的标识，在服务器端和客户端交互中带上这个标识及其值，特别是shiro默认会在url后带这个后缀</p>
<h2 id="servlet3-0以后session-id的保存方式"><a href="#servlet3-0以后session-id的保存方式" class="headerlink" title="servlet3.0以后session id的保存方式"></a>servlet3.0以后session id的保存方式</h2><ol>
<li>COOKIE 保存在客户端COOKIE中，通过请求读取cookie确认会话归属</li>
<li>URL 跟在url接连后面，默认方式，通过读取url后缀确认会话归属</li>
<li>SSL 使用SSL连接确认会话归属，这个最安全，但成本最高</li>
</ol>
<h2 id="如何去掉url后缀的”-JEESESSIONID-”"><a href="#如何去掉url后缀的”-JEESESSIONID-”" class="headerlink" title="如何去掉url后缀的”;JEESESSIONID=”"></a>如何去掉url后缀的”;JEESESSIONID=”</h2><p>从上面看出，默认使用后缀，因此，只要改变session id的保存方式即可去掉，具体使用2中方式</p>
<h3 id="设置web-xml"><a href="#设置web-xml" class="headerlink" title="设置web.xml"></a>设置web.xml</h3><p>如果使用<strong>Tomcat7</strong>及以上版本，且开发基于<strong>servlet3.0+</strong>可以通过web.xml经行配置，如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tracking-mode</span>&gt;</span>COOKIE<span class="tag">&lt;/<span class="name">tracking-mode</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="使用filter"><a href="#使用filter" class="headerlink" title="使用filter"></a>使用filter</h3><p>使用filter，去除后缀，DisableUrlSessionFilter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        Copyright  DR.YangLong</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment">        you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">        You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">        distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">        See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">        limitations under the License.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> com.yanglong.common.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponseWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 去掉浏览后缀附带的J2EE session id字符串，默认为JSESSIONID，使用初始化属性sessionFix来指定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisableUrlSessionFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SESSION_SIGN=<span class="string">&quot;JSESSIONID&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> FilterConfig filterConfig;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.filterConfig=<span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(request <span class="keyword">instanceof</span> HttpServletRequest)) &#123;</span><br><span class="line">			chain.doFilter(request, response);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		HttpServletRequest httpRequest = (HttpServletRequest) request;</span><br><span class="line">		HttpServletResponse httpResponse = (HttpServletResponse) response;</span><br><span class="line">		<span class="keyword">if</span> (httpRequest.isRequestedSessionIdFromURL()) &#123;  </span><br><span class="line">            HttpSession session = httpRequest.getSession();</span><br><span class="line">            <span class="keyword">if</span> (session != <span class="keyword">null</span>)  </span><br><span class="line">                session.invalidate();  </span><br><span class="line">        &#125; </span><br><span class="line">		String url = httpRequest.getRequestURL().toString();</span><br><span class="line">		String sessionFix=filterConfig.getInitParameter(<span class="string">&quot;sessionFix&quot;</span>);</span><br><span class="line">		sessionFix=(sessionFix==<span class="keyword">null</span>||<span class="string">&quot;&quot;</span>.equals(sessionFix))?DEFAULT_SESSION_SIGN:sessionFix;</span><br><span class="line">		sessionFix=<span class="string">&quot;;&quot;</span>+sessionFix+<span class="string">&quot;=&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> inx = url.indexOf(sessionFix);</span><br><span class="line">        <span class="keyword">if</span>(inx &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	url = url.substring(<span class="number">0</span>, inx);</span><br><span class="line">        	httpResponse.sendRedirect(url);</span><br><span class="line">        	<span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		HttpServletResponseWrapper wrappedResponse = <span class="keyword">new</span> HttpServletResponseWrapper(httpResponse) &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">encodeRedirectUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> url;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">encodeRedirectURL</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> url;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">encodeUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> url;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">encodeURL</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> url;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		chain.doFilter(request, wrappedResponse);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.filterConfig=filterConfig;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> FilterConfig <span class="title">getFilterConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> filterConfig;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFilterConfig</span><span class="params">(FilterConfig filterConfig)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.filterConfig = filterConfig;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将这个filter配置到web.xml，位置在编码filter之后，其他filter之前</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>disableUrlSessionFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.up360.core.web.DisableUrlSessionFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>sessionFix<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>JEESESSIONID<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>disableUrlSessionFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然这个性能稍微差点，但在设置</p>
<blockquote>
<p><tracking-mode>COOKIE</tracking-mode></p>
</blockquote>
<p>无效的情况下可以使用，最坏的情况2者都用。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>去掉JEESESSIONID</tag>
        <tag>shiro 去掉JEESESSIONID</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基础命令</title>
    <url>/2019/07/07/docker/</url>
    <content><![CDATA[<h2 id="Docker基础命令"><a href="#Docker基础命令" class="headerlink" title="Docker基础命令"></a>Docker基础命令</h2><h3 id="运行容器："><a href="#运行容器：" class="headerlink" title="运行容器："></a>运行容器：</h3><blockquote>
<p>docker run -i -t ubuntu /bin/bash</p>
</blockquote>
<blockquote>
<p>docker run -i -t ubuntu:12.04 /bin/bash 运行特定tag标定的容器</p>
</blockquote>
<p>-i:开启STDIN<br>-t:分配一个伪终端</p>
<blockquote>
<p>docker run –rm ….</p>
</blockquote>
<p>–rm：运行结束后删除容器并清理，等价于容器退出后执行docker rm -v</p>
<span id="more"></span>
<h3 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h3><p>运行时使用p参数指定：</p>
<blockquote>
<p>docker run -p [宿主机绑定IP:端口号]:[容器端口号] … </p>
</blockquote>
<h3 id="运行并命名容器"><a href="#运行并命名容器" class="headerlink" title="运行并命名容器"></a>运行并命名容器</h3><blockquote>
<p>docker run –name app_named -i -t ubuntu /bin/bash</p>
</blockquote>
<p>运行一个容器，并以app_named为名称。</p>
<h3 id="容器列表"><a href="#容器列表" class="headerlink" title="容器列表"></a>容器列表</h3><blockquote>
<p>docker ps  列出正在运行的容器</p>
</blockquote>
<blockquote>
<p>docker ps -a 列出所有容器</p>
</blockquote>
<blockquote>
<p>docker ps -n [x] 显示最后的x个容器</p>
</blockquote>
<blockquote>
<p>docker ps -l 查看端口映射情况</p>
</blockquote>
<blockquote>
<p>docker port [id/name] 查看容器端口映射</p>
</blockquote>
<h3 id="重新启动已经停止的容器"><a href="#重新启动已经停止的容器" class="headerlink" title="重新启动已经停止的容器"></a>重新启动已经停止的容器</h3><blockquote>
<p>docker start [id/name]</p>
</blockquote>
<blockquote>
<p>docker restart [id/name]</p>
</blockquote>
<h3 id="附着到容器上"><a href="#附着到容器上" class="headerlink" title="附着到容器上"></a>附着到容器上</h3><blockquote>
<p>docker attach [id/name]</p>
</blockquote>
<h3 id="创建守护式容器"><a href="#创建守护式容器" class="headerlink" title="创建守护式容器"></a>创建守护式容器</h3><blockquote>
<p>docker run –name deamond_named -d ubuntu /bin/sh -c “while true;do echo hello world;sleep 1;done”</p>
</blockquote>
<p>-d参数使容器在后台运行。</p>
<h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><blockquote>
<p>docker logs [id/name] 查看已输出日志</p>
</blockquote>
<blockquote>
<p>docker logs -f [id/name] 跟踪</p>
</blockquote>
<blockquote>
<p>docker logs –tail 10 [id/name] 查看最后10行</p>
</blockquote>
<blockquote>
<p>docker logs –tail 0 -f [id/name] 跟踪最新</p>
</blockquote>
<blockquote>
<p>docker logs -f -t [id/name] 跟踪带时间戳</p>
</blockquote>
<h3 id="自定义日志驱动"><a href="#自定义日志驱动" class="headerlink" title="自定义日志驱动"></a>自定义日志驱动</h3><p>运行时通过–log-driver指定。默认json-file,可选syslog，none。syslog，输出到系统日志，需要开启宿主机Syslog守护进程。none禁用日志。</p>
<blockquote>
<p>docker run –log-driver=”syslog” –name deamond_named -d ubuntu /bin/sh -c “while true;do echo hello world;sleep 1;done”</p>
</blockquote>
<h3 id="查看容器内进程"><a href="#查看容器内进程" class="headerlink" title="查看容器内进程"></a>查看容器内进程</h3><blockquote>
<p>docker top [id/name]</p>
</blockquote>
<h3 id="查看docker状态信息，可多个"><a href="#查看docker状态信息，可多个" class="headerlink" title="查看docker状态信息，可多个"></a>查看docker状态信息，可多个</h3><blockquote>
<p>docker stats [id/name]+</p>
</blockquote>
<h3 id="容器内额外启动新进程"><a href="#容器内额外启动新进程" class="headerlink" title="容器内额外启动新进程"></a>容器内额外启动新进程</h3><blockquote>
<p>docker exec -d [id/name] [指令] 使用在运行的容器执行后台指令</p>
</blockquote>
<blockquote>
<p> docker exec -ti -u root [id/name] [指令]<br>使用容器的root用户运行指令</p>
</blockquote>
<blockquote>
<p>docker exec -t -i [id/name] /bin/bash 使用在运行的容器执行交互命令</p>
</blockquote>
<h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><blockquote>
<p>docker stop [id/name]</p>
</blockquote>
<h3 id="自动重启容器"><a href="#自动重启容器" class="headerlink" title="自动重启容器"></a>自动重启容器</h3><blockquote>
<p>docker run –restart=always –name named -d ubuntu  /bin/sh -c “while true;do echo hello world;sleep 1;done”</p>
</blockquote>
<p>restart参数：</p>
<ul>
<li>always:无论退出标志是什么，总是重启。</li>
<li>on-failure:当退出标志不为0时重启，可指定重启次数：–restart=on-failure:5,表示尝试重启5次。</li>
</ul>
<h3 id="获取容器详细信息"><a href="#获取容器详细信息" class="headerlink" title="获取容器详细信息"></a>获取容器详细信息</h3><blockquote>
<p>docker inspect [id/name]+ 获取所有信息</p>
</blockquote>
<blockquote>
<p>docker inspect –format=’&amp;#123&amp;#123.State.Running&amp;#125&amp;#125’ [id/name]+ 获取模板指定信息</p>
</blockquote>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><blockquote>
<p>docker rm [id/name] 删除未运行的容器</p>
</blockquote>
<blockquote>
<p>docker rm -f [id/name] 删除运行中的容器</p>
</blockquote>
<blockquote>
<p>docker rm $(docker ps -a -q) 删除所有容器</p>
</blockquote>
<h3 id="列出本机所有可用镜像"><a href="#列出本机所有可用镜像" class="headerlink" title="列出本机所有可用镜像"></a>列出本机所有可用镜像</h3><blockquote>
<p>docker images</p>
</blockquote>
<h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><blockquote>
<p>docker pull [name]:[tag] 拉取tag标注的镜像</p>
</blockquote>
<h3 id="查看镜像信息"><a href="#查看镜像信息" class="headerlink" title="查看镜像信息"></a>查看镜像信息</h3><blockquote>
<p>docker images [镜像名]</p>
</blockquote>
<h3 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h3><blockquote>
<p>docker search [镜像名]</p>
</blockquote>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>Dockerfile模板：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">#注释 &lt;&gt;表示变量</span><br><span class="line">FROM &lt;镜像名&gt;:&lt;tag/digest&gt;</span><br><span class="line">MAINTAINER &lt;用户名&gt; &quot;&lt;邮箱&gt;&quot; 已被LABEl替代</span><br><span class="line">RUN [&quot;&lt;指令&gt;&quot;,&quot;&lt;参数1&gt;&quot;,&quot;&lt;参数2&gt;&quot;,...]构建时执行shell命令，多条用“;”分割，可指定多次</span><br><span class="line">CMD [&quot;&lt;指令&gt;&quot;,&quot;&lt;参数1&gt;&quot;,&quot;&lt;参数2&gt;&quot;,...]，运行时执行指令，只能指定一次，会被docker run 指定的指令覆盖</span><br><span class="line">ENTRYPOINT [&quot;&lt;指定默认程序&gt;&quot;,&quot;&lt;参数1&gt;&quot;,&quot;&lt;参数2&gt;&quot;,...]容器运行时默认运行此程序    </span><br><span class="line">LABEL &lt;key&gt;=&lt;value&gt;，指定元数据，key=value的形式，多个空格分开</span><br><span class="line">EXPOSE &lt;端口&gt;，指定容器运行时监听的端口，多个空格分开，要使端口可访问，需要在执行docker run时使用-p指定</span><br><span class="line">ENV &lt;key&gt;=&lt;value&gt;，设定环境变量，多个空格分开</span><br><span class="line">ADD &lt;src&gt;... &lt;dest&gt;   拷贝并解压。如果src是目录，只会拷贝目录中的文件。</span><br><span class="line">ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br><span class="line">COPY &lt;src&gt;... &lt;dest&gt; 拷贝不解压，src是目录只会拷贝文件。</span><br><span class="line">COPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br><span class="line">VOLUME &lt;container目录&gt;，挂载卷，创建一个匿名volume，目录不存在会创建。</span><br><span class="line">USER &lt;daemon&gt;，设定容器运行时的用户</span><br><span class="line">WORKDIR &lt;目录名&gt;，设置工作目录，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY等命令都会在该目录下执行。多次设置会拼接出层级目录。</span><br><span class="line">ARG &lt;name&gt;=&lt;default value&gt;，设定构建时可传递值的变量，运行build时使用--build-arg key=value传入</span><br><span class="line">ONBUILD &lt;指令&gt;，当该镜像被作为基础镜像使用时将要触发的指令</span><br><span class="line">STOPSIGNAL &lt;系统合法信号值&gt;，当容器停止运行时所要发送的系统调用信号</span><br><span class="line">SHELL [&quot;&lt;executable&gt;&quot;, &quot;&lt;parameter&gt;&quot;,&quot;&lt;parameter&gt;&quot;,...]指定要运行指令的shell程序，多个shell时使用，功能同RUN</span><br></pre></td></tr></table></figure>
<p>ADD和COPY不能指定上下文文件夹以外的目录，ADD可使用URL，copy不行，2个命令都会覆盖容器中已存在的文件。</p>
<p>VOLUME：一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">卷可以容器间共享和重用</span><br><span class="line">容器并不一定要和其它容器共享卷</span><br><span class="line">修改卷后会立即生效</span><br><span class="line">对卷的修改不会对镜像产生影响</span><br><span class="line">卷会一直存在，直到没有任何容器在使用它</span><br></pre></td></tr></table></figure>


<p>使用USER指定用户时，可以使用用户名、UID或GID，或是两者的组合。以下都是合法的指定值：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">USER user</span><br><span class="line">USER user:group</span><br><span class="line">USER uid</span><br><span class="line">USER uid:gid</span><br><span class="line">USER user:gid</span><br><span class="line">USER uid:group</span><br></pre></td></tr></table></figure>
<p>使用USER指定用户后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT都将使用该用户。镜像构建完成后，通过docker run运行容器时，可以通过-u参数来覆盖所指定的用户。</p>
<h4 id="构建命令："><a href="#构建命令：" class="headerlink" title="构建命令："></a>构建命令：</h4><blockquote>
<p>docker build -t=”仓库名/镜像名:tag” -f=”文件所在位置”  “上下文文件夹位置”</p>
</blockquote>
<h3 id="推送镜像到docker-hub"><a href="#推送镜像到docker-hub" class="headerlink" title="推送镜像到docker hub"></a>推送镜像到docker hub</h3><blockquote>
<p>docker push [namespace]/[name]:[tag]</p>
</blockquote>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><blockquote>
<p>docker rmi [id/name]+</p>
</blockquote>
<h3 id="从容器运行Registry"><a href="#从容器运行Registry" class="headerlink" title="从容器运行Registry"></a>从容器运行Registry</h3><p><a href="https://docs.docker.com/registry/deploying/">参看</a></p>
<h3 id="运行容器并挂载卷"><a href="#运行容器并挂载卷" class="headerlink" title="运行容器并挂载卷"></a>运行容器并挂载卷</h3><blockquote>
<p>docker run -d -p 80 -v $PWD/website:/var/www/html/website –name named  unbuntu nginx</p>
</blockquote>
<p>-v [本地目录]:[容器目录]:[卷对容器的权限，读写：wr，只读：ro]  将本地目录设为容器卷</p>
<h3 id="创建Docker-Networking"><a href="#创建Docker-Networking" class="headerlink" title="创建Docker Networking"></a>创建Docker Networking</h3><blockquote>
<p>docker network create [name]</p>
</blockquote>
<h3 id="查看Docker-Networking详细信息"><a href="#查看Docker-Networking详细信息" class="headerlink" title="查看Docker Networking详细信息"></a>查看Docker Networking详细信息</h3><blockquote>
<p>docker network inspect [name]</p>
</blockquote>
<h3 id="列出当前系统中所有网络"><a href="#列出当前系统中所有网络" class="headerlink" title="列出当前系统中所有网络"></a>列出当前系统中所有网络</h3><blockquote>
<p>docker network ls</p>
</blockquote>
<h3 id="删除网络"><a href="#删除网络" class="headerlink" title="删除网络"></a>删除网络</h3><blockquote>
<p>docker network rm [name]</p>
</blockquote>
<h3 id="将容器添加到网络"><a href="#将容器添加到网络" class="headerlink" title="将容器添加到网络"></a>将容器添加到网络</h3><p>运行时指定：</p>
<blockquote>
<p>docker run –net=[网络名] …</p>
</blockquote>
<p>已运行容器加入：</p>
<blockquote>
<p>docker network connect [网络名] [容器id/名称]</p>
</blockquote>
<h3 id="将容器从网络中断开"><a href="#将容器从网络中断开" class="headerlink" title="将容器从网络中断开"></a>将容器从网络中断开</h3><blockquote>
<p>docker network disconnect [网络名] [容器id/名称]</p>
</blockquote>
<h3 id="容器链接"><a href="#容器链接" class="headerlink" title="容器链接"></a>容器链接</h3><blockquote>
<p>docker run –link [目标容器名]:[本容器使用的别名] …</p>
</blockquote>
<p>容器链接以后，当前容器可以访问目标容器所有expose的端口。一个容器在run时通过多次–link标志可以链接多个容器，同时一个容器也可以供多个容器链接。</p>
<h3 id="卷"><a href="#卷" class="headerlink" title="卷"></a>卷</h3><blockquote>
<p>docker volume </p>
</blockquote>
<ul>
<li>ls 查看所有卷</li>
<li>rm [name] 删除一个卷</li>
<li>create [name] 创建一个卷</li>
<li>inspect [name] 查看卷详情</li>
<li>prune  删除所有没在使用的卷</li>
</ul>
<h1 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker compose"></a>Docker compose</h1><p>docker compose定义了一组服务，每个服务为一个容器。docker compose通过docker-compose.yml对这些服务进行编排。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Druid加密</title>
    <url>/2017/05/28/druid-encrypted/</url>
    <content><![CDATA[<h1 id="Druid数据源加密"><a href="#Druid数据源加密" class="headerlink" title="Druid数据源加密"></a>Druid数据源加密</h1><p>首先说下意见，druid数据源加密其实可有可无，只不过是多了一点破解时间，因为公钥和密文都知道，破解非常简单。不过加密下还是有些许必要的，至少逼格档次和心里安慰是有的:)。</p>
<h2 id="ConfigTools-java加密"><a href="#ConfigTools-java加密" class="headerlink" title="ConfigTools.java加密"></a>ConfigTools.java加密</h2><p>druid的加密类为ConfigTools，全路径为：</p>
<blockquote>
<p>com.alibaba.druid.filter.config.ConfigTools.java</p>
</blockquote>
<p>里面有个main方法，随机生成私钥和公钥，并加密密码生成密文。所以使用时只需要传入密码即可，运行后会输出公钥，私钥和密码密文。</p>
<blockquote>
<p>java -cp druid-1.0.26.jar com.alibaba.druid.filter.config.ConfigTools root</p>
</blockquote>
<span id="more"></span>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">privateKey:MIIBVQIBADANBgkqhkiG9w0BAQEFAASCAT8wggE7AgEAAkEAiMmH7UHifMOk7lYYfwnH4yJ7mg7BrJ6MxUlZeisp4v2mBF70byat5Rh12K4xtwTmn53KOg5CwTCG8gDHQkwq/wIDAQABAkBsSOYDC5opXJPvXVbNEsgbZgvlHHNznJwh/fwIe60QFLtZNIImtM8ar+tFK+Vg/cwpmPyaOS57M2msBA31mSX5AiEA9L53/4hkinrQca2QIAWWpHx3QPwdQsJbRBHycnPxKfsCIQCPFAQzbbz7nLIV78flw1EhSEanJewFzSJ1xquFSbgXzQIhAIvkYwq4l19gG80efAcRqq2SR0fp03/ZP/mEmKQ7CVoJAiBiSLK2DU0DXllq/kLHz0q83SRDj6Y5OffRBb8vGTvPhQIhAMmrCgtPPsMz+R076967CuD3zwa6rhmR9yXZXf4Nc4Xd</span><br><span class="line"></span><br><span class="line">publicKey:MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAIjJh+1B4nzDpO5WGH8Jx+Mie5oOwayejMVJWXorKeL9pgRe9G8mreUYddiuMbcE5p+dyjoOQsEwhvIAx0JMKv8CAwEAAQ==</span><br><span class="line"></span><br><span class="line">password:U8TkvAncYH6sYhuHbYsF2bvhk+O+hC9RLhKPo1+u/cuLW/WVxlxaJ+WUkSffL7sZ5EJAtvjNodNafM3kDnmc6Q==</span><br></pre></td></tr></table></figure>
<p>网上有很多都是老版本的，使用的都是默认私钥和公钥，不过效果没差别。<br>main方法源码：    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       String password = args[<span class="number">0</span>];</span><br><span class="line">       String[] arr = genKeyPair(<span class="number">512</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;privateKey:&quot;</span> + arr[<span class="number">0</span>]);</span><br><span class="line">       System.out.println(<span class="string">&quot;publicKey:&quot;</span> + arr[<span class="number">1</span>]);</span><br><span class="line">       System.out.println(<span class="string">&quot;password:&quot;</span> + encrypt(arr[<span class="number">0</span>], password));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#data source配置下</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">&quot;密文密码&quot;</span></span><br><span class="line"><span class="attr">connectionProperties:</span> <span class="string">&quot;config.decrypt=true;config.decrypt.key=公钥&quot;</span></span><br><span class="line"><span class="comment"># stat是状态监控，可参照官方文档配置，如果只用解密密码，只需配置config参数</span></span><br><span class="line"><span class="attr">filters:</span> <span class="string">&quot;stat,config&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实意义不是很大，因为如果别人已经拿到你的密文和公钥，那加密和解密都没有任何意义，如果是通过抓包获取，那获取的时候已经是明文了。数据库的安全还是需要依赖于操作系统的防火墙和其他设施来保障的，比如iptables这些。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>双层for循环优化</title>
    <url>/2017/05/29/for/</url>
    <content><![CDATA[<h1 id="双层循环优化"><a href="#双层循环优化" class="headerlink" title="双层循环优化"></a>双层循环优化</h1><p>底层数据存储方式：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">行优先存储：</span><br><span class="line">a[0][0],a[0][1],a[0][2]...</span><br><span class="line">列优先存储：</span><br><span class="line">a[0][0],a[1][0],a[2][0]...</span><br></pre></td></tr></table></figure>

<p>对于双层循环，行优先保证外层循环比内层循环小，对于列优先保证内层循环比外层循环小，简而言之，谁不变谁循环次数小。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Flow使用</title>
    <url>/2016/09/08/git-flow/</url>
    <content><![CDATA[<h1 id="git-flow入门"><a href="#git-flow入门" class="headerlink" title="git flow入门"></a>git flow入门</h1><p>软件在开发中的周期为：新功能定义-&gt;新功能实现-&gt;新功能测试-&gt;新功能BUG修复-&gt;新功能发布上线-&gt;紧急线上bug修复；<br>使用git的分支以及分支合并可以很好的完成各周期对应的实际操作，但是必须熟知git命令并且规范性比较差，git flow是一个基于git的工作流规范工具。<br>它集成了git的分支，tag等命令，整合为软件开发周期中的各个阶段，可以很容易就实现软件的规范化开发。<br>基本流程图（来源于博客ngulc，不再重复画了）：<br><img src="https://images2015.cnblogs.com/blog/805129/201608/805129-20160814142051093-1392948534.png" alt="FLOW"></p>
<span id="more"></span>

<h2 id="初始化git-flow"><a href="#初始化git-flow" class="headerlink" title="初始化git-flow"></a>初始化git-flow</h2><ul>
<li>在已有的git仓库执行<blockquote>
<p>git flow init</p>
</blockquote>
</li>
</ul>
<p>回复几个问题，可以全部使用默认，也可以自定义，建议默认。<br>初始化即完成。同时会生成一个<strong>本地 develop</strong>分支并切换到此分支。<br>将develop分支推送到远程仓库，作为常驻分支。</p>
<blockquote>
<p>git push -u origin develop</p>
</blockquote>
<h2 id="开始开发新模块"><a href="#开始开发新模块" class="headerlink" title="开始开发新模块"></a>开始开发新模块</h2><p>使用命令</p>
<blockquote>
<p>git flow feature start [模块名称]</p>
</blockquote>
<p>开始一个新的模块开发，此命令基于develop分创建一个名为[模块名称]的新<strong>本地分支</strong>并切换到此分支。</p>
<h2 id="协作开发新模块"><a href="#协作开发新模块" class="headerlink" title="协作开发新模块"></a>协作开发新模块</h2><p>当需要协作开发时，可以将新模块分支推送到远程仓库：</p>
<blockquote>
<p>git flow feature publish [模块名称]</p>
</blockquote>
<p>其他开发人员即可通过如下命令获取新模块：</p>
<blockquote>
<p>git flow feature pull origin [模块名称]</p>
</blockquote>
<p>也可以使用（2.0后将只能使用此命令）</p>
<blockquote>
<p>git flow feature track [模块名称]</p>
</blockquote>
<p>pull远程模块分支的变更。</p>
<h2 id="新模块开发完成"><a href="#新模块开发完成" class="headerlink" title="新模块开发完成"></a>新模块开发完成</h2><p>使用命令</p>
<blockquote>
<p>git flow feature finish [模块名称]</p>
</blockquote>
<p>完成一个新模块开发。此命令将[模块名称]分支合并到develop分支，删除[模块名称]分支并切换回develop分支。<br>需要注意的是，必须使工作空间保持干净才能够执行此命令。</p>
<h2 id="发布新模块"><a href="#发布新模块" class="headerlink" title="发布新模块"></a>发布新模块</h2><p>发布命令：</p>
<blockquote>
<p>git flow release start [RELEASE] [BASE]</p>
</blockquote>
<p>RELEASE：版本名称<br>BASE：develop分支下的commit的sha-1值。<br>命令仅基于develop分支创建本地release分支，将此分支推送到远程仓库：</p>
<blockquote>
<p>git flow release publish [RELEASE]</p>
</blockquote>
<p>使用</p>
<blockquote>
<p>git flow release track [RELEASE]</p>
</blockquote>
<p>pull远程release分支的变更。</p>
<h2 id="完成新模块"><a href="#完成新模块" class="headerlink" title="完成新模块"></a>完成新模块</h2><blockquote>
<p>git flow release finish [RELEASE]</p>
</blockquote>
<p>合并release分支到master分支，用release分支名打tag；合并release分支到develop分支；删除release分支。</p>
<h2 id="紧急修复"><a href="#紧急修复" class="headerlink" title="紧急修复"></a>紧急修复</h2><p>发现某个提交有bug，使用</p>
<blockquote>
<p>git flow hotfix start [VERSION] [BASENAME]</p>
</blockquote>
<p>VERSION：修正版本名称<br>BASENAME： release分支名<br>从master新开一个分支，分支名称为VERSION参数名。</p>
<h2 id="完成修复"><a href="#完成修复" class="headerlink" title="完成修复"></a>完成修复</h2><blockquote>
<p>git flow hotfix finish [VERSION]</p>
</blockquote>
<p>完成修复。修复分支合并到master，develop，master分支打上修正版本tag。</p>
<h2 id="完成feature或release时出现分叉"><a href="#完成feature或release时出现分叉" class="headerlink" title="完成feature或release时出现分叉"></a>完成feature或release时出现分叉</h2><p>如果提示<strong>undiverge branches</strong>，说明develop分支或master分支在你提交前已经有新的提交，需要先checkout到develop或master分支进行pull，然后rebase当前的feature分支或者release分支。然后再执行finish命令。<br>如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout develop</span><br><span class="line">git pull</span><br><span class="line">git flow feature rebase [featureTree]</span><br><span class="line">[此处可能需要处理冲突文件，处理完后运行git rebase --<span class="built_in">continue</span>]</span><br><span class="line">git flow feature finish [featureTree]</span><br><span class="line">[有可能提示featureTree有分叉，这时，由于远程和本地不一样，按git流程，先pull，然后处理冲突文件，然后commit，push，完成后再次运行finish命令]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://github.com/nvie/gitflow">https://github.com/nvie/gitflow</a></li>
<li><a href="http://jeffkreeftmeijer.com/2010/why-arent-you-using-git-flow/">http://jeffkreeftmeijer.com/2010/why-arent-you-using-git-flow/</a></li>
<li><a href="http://www.cnblogs.com/lcngu/p/5770288.html">http://www.cnblogs.com/lcngu/p/5770288.html</a></li>
<li><a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html">http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Git入门</title>
    <url>/2016/05/28/git-guide/</url>
    <content><![CDATA[<h2 id="git入门"><a href="#git入门" class="headerlink" title="git入门"></a>git入门</h2><p>git是一个免费开源的分布式版本控制系统。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://git-scm.com/downloads" title="点击下载">gitbash下载</a>,<a href="https://tortoisegit.org/download/" title="tortoisegit">图形化管理工具下载</a></p>
<h3 id="工作区与版本库，暂存区"><a href="#工作区与版本库，暂存区" class="headerlink" title="工作区与版本库，暂存区"></a>工作区与版本库，暂存区</h3><blockquote>
<p>工作区</p>
</blockquote>
<p>电脑中看到的目录，就是工作区。</p>
<blockquote>
<p>版本库</p>
</blockquote>
<p>被git管理的目录叫做版本库，此目录下任何文件都被git追踪管理，包括修改，新增，删除，每次修改git都有相应的历史记录，以便可以进行变更追踪以及恢复。</p>
<ul>
<li>本地仓库：在本机的仓库，记录本机的变更记录。</li>
<li>远程仓库：在远程主机上的仓库，记录所有相关的操作，当远程仓库和本机仓库关联起来以后，才组成一个完整git系统。在本地进行的操作一旦提交，远程仓库就会应用这些操作在远程仓库上。<span id="more"></span>
<blockquote>
<p>暂存区</p>
</blockquote>
</li>
</ul>
<p>用户将一次操作向版本库提交时，要分为2步：</p>
<ol>
<li>新增</li>
<li>提交</li>
</ol>
<p>第一步，新增时操作就储存在暂存区。此时，操作并没有真正的对原来的版本起任何作用。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>基本操作包括仓库的创建，文件管理，远程仓库关联，分支管理。</p>
<h4 id="本地操作"><a href="#本地操作" class="headerlink" title="本地操作"></a>本地操作</h4><blockquote>
<p>创建本地仓库</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir <span class="built_in">test</span></span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">test</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>使用<strong>git init</strong>创建一个本地仓库。可以在目录下发现有一个<em>.git</em>的目录。</p>
<blockquote>
<p>管理修改</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在工作区新增文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">test</span>&gt;&gt;test.md</span><br><span class="line">git status</span><br><span class="line"><span class="comment">#向本地仓库新增文件</span></span><br><span class="line">git add test.md</span><br><span class="line"><span class="comment">#查看工作区状态</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment">#修改test.md新增内容</span></span><br><span class="line">vim test.md</span><br><span class="line"><span class="comment">#提交</span></span><br><span class="line">git commit -m <span class="string">&quot;git change content&quot;</span></span><br><span class="line"><span class="comment">#查看状态，可以看到git提示文本被修改，所以上面的提交仅仅是提交了第一次的操作，原因是我们仅仅新增了第一次操作到暂存区，commit仅会将暂存区的操作提交到仓库</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment">#此时可以有2个选择，一个是撤销修改，一个是新增修改到暂存区</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>撤销修改</p>
</blockquote>
<p>当你新增一个修改到暂存区前发现原来的才是对的，你修改的是错的，没用的，这时候可以将修改撤销</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ cat test.md</span><br><span class="line"><span class="built_in">test</span> <span class="keyword">for</span> git</span><br><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ git checkout -- test.md</span><br><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ cat test.md</span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>可以看到，文件已经恢复到了第一次修改时。</p>
<blockquote>
<p>查看修改</p>
</blockquote>
<p>当你修改了一个文件，但是已经忘记修改了什么地方的时候，可以使用以下命令查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff fileName</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除文件</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ rm test.md</span><br><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">尚未暂存以备提交的变更：</span><br><span class="line">  （使用 <span class="string">&quot;git add/rm &lt;文件&gt;...&quot;</span> 更新要提交的内容）</span><br><span class="line">  （使用 <span class="string">&quot;git checkout -- &lt;文件&gt;...&quot;</span> 丢弃工作区的改动）</span><br><span class="line"></span><br><span class="line">	删除：     test.md</span><br><span class="line"></span><br><span class="line">修改尚未加入提交（使用 <span class="string">&quot;git add&quot;</span> 和/或 <span class="string">&quot;git commit -a&quot;</span>）</span><br></pre></td></tr></table></figure>
<p>如上，如果要真正的删除文件，必须在删除后新增修改，然后commit，这样文件才会从版本庫删除，如果删错了，也很简单，可以使用checkout命令找回来。</p>
<blockquote>
<p>版本回退</p>
</blockquote>
<p>如果你发现需要一个很早之前的版本怎么办，这时候就可以使用版本回退。</p>
<blockquote>
<p>查看版本记录：git log [–pretty=oneline]<br>回退版本：git reset [–hard|soft|mixed|merge|keep] &lt;commitId|HEAD&gt;</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git每次commit会自动生成commitId,git <span class="built_in">log</span>中的16进制串。git使用HEAD标示版本，HEAD表示当前版本，HEAD^表示上一个版本，HEAD^^表示上上的版本，以此类推，也可以使用HEAD～[n]表示往前第几个版本，n为自然正整数。</span><br></pre></td></tr></table></figure>
<p>常用的3种模式：</p>
<ul>
<li>hard：工作区重置到指定commitId的版本，指定commitId以后的修改全部丢弃。HEAD指到commitId。</li>
<li>soft：工作区内容不做任何改变，仅仅将HEAD<br>指到commitId，指定commitId以后的修改全部放入到暂存区，可以使用git status查看。如果此时使用commit，就会将commitId之后的所有更改都提交。</li>
<li>mixed：默认模式，HEAD指向commitId，工作区的修改都会被保留，但commitId之后的修改不会放入暂存区，需要使用add手动去添加修改。</li>
</ul>
<p>5种模式的区别详见   <a href="http://blog.csdn.net/hudashi/article/details/7664464" title="前往">模式区别</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ cat test.md</span><br><span class="line"><span class="built_in">test</span> <span class="keyword">for</span> reset</span><br><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">13850ac7f584717576f3090e7a722ce0937e9f16 reset</span><br><span class="line">7175b5992fca5a89c1fa6dbfc6a6589d1a9a3002 git change content</span><br><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ git reset --hard HEAD^</span><br><span class="line">HEAD 现在位于 7175b59 git change content</span><br><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ cat test.md</span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h4 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h4><blockquote>
<p>添加远程仓库</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin [remote repo url]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>推送到远程仓库</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加远程仓库后第一次推送</span></span><br><span class="line">git push -u origin master</span><br><span class="line"><span class="comment">#非第一推送</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从远程仓库克隆</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> [remote repo url]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从远程仓库获取更新</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>
<p>更新可能有冲突，这时使用git status可以看到有哪些文件冲突，逐一修改后，使用 add/commit提交修改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a123</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="string">HEAD</span></span><br><span class="line"><span class="string">b456</span></span><br><span class="line"><span class="string">=======</span></span><br><span class="line"><span class="string">b789</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6853e5ff961e684d3a6c02d4d06183b5ff330dcc</span></span><br><span class="line"><span class="string">c</span></span><br></pre></td></tr></table></figure>
<p>以上说明b这一行有冲突，&lt;&lt;&lt;&lt;&lt;&lt;&lt;与=======之间（上面部分）是我们修改的，======与&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间是别人修改的。</p>
<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>分支可以看作并行的版本库，他们可以互不干扰，在必要的时候又可以合并修改。</p>
<blockquote>
<p>查看分支</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看本地分支</span></span><br><span class="line">git branch</span><br><span class="line"><span class="comment">#查看所有分支，包括远程</span></span><br><span class="line">git branch -a</span><br><span class="line"><span class="comment">#查看远程分支情况</span></span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建本地分支</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch [branchName]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>推送本地分支到远程仓库</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin [branchName]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>分支切换</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout [branchName]</span><br><span class="line"><span class="comment">#创建一个分支并切换到新创建的分支</span></span><br><span class="line">git checkout -b [branchName]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除分支</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除本地分支</span></span><br><span class="line">git branch -d [branchName]</span><br><span class="line"><span class="comment">#删除远程分支，或者将一个已删除的本地分支推送到远程分支</span></span><br><span class="line">git push origin --delete [branchName]</span><br><span class="line"><span class="comment">#或者使用</span></span><br><span class="line">git push origin :[branchName]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>分支合并</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ git branch</span><br><span class="line">  master</span><br><span class="line">* testBranch</span><br><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ cat test.md</span><br><span class="line"><span class="built_in">test</span> <span class="keyword">for</span> merger</span><br><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ git checkout master</span><br><span class="line">切换到分支 <span class="string">&#x27;master&#x27;</span></span><br><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ cat test.md</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ git merge testBranch</span><br><span class="line">更新 7175b59..473eec8</span><br><span class="line">Fast-forward</span><br><span class="line"> test.md | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">无文件要提交，干净的工作区</span><br><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ cat test.md</span><br><span class="line"><span class="built_in">test</span> <span class="keyword">for</span> merger</span><br></pre></td></tr></table></figure>
<p>步骤：</p>
<blockquote>
<ol>
<li>切换到待合并分支上，git pull更新。</li>
<li>切换到要合并的主分支上，git pull更新。</li>
<li>git merge [待合并branchName]合并分支。</li>
<li>git status 查看合并状态。</li>
<li>解决冲突文件。</li>
<li>git add/commit 提交已发解决的冲突文件。</li>
<li>合并结束。</li>
</ol>
</blockquote>
<p>在合并后如果后悔，可以使用rest命令进行版本回退。</p>
<h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>在日常开发中，有的文件，比如一些开发环境相关的文件，如果你提交了，可能造成别人无法正常运行项目，毕竟每个人的环境配置不可能一模一样，特别是在协同开发下。所以对于一些文件，我们需要本地保留，但同时又不想把它提交到版本仓库中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> *.iml&gt;&gt;.gitignore</span><br></pre></td></tr></table></figure>
<p>新建一个.gitignore后缀的文件，将需要忽略的文件或文件夹添加到此文件中，每个一行。</p>
<h4 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h4><p>用于将修改暂存到git栈中，并将工作区内容恢复到最近一次的提交。</p>
<blockquote>
<ol>
<li>git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到git栈中。如果要使用消息，使用git stash save “message”。</li>
<li>git stash pop: 从git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。</li>
<li>git stash list: 显示git栈内的所有备份，可以利用这个列表来决定从哪个地方恢复。</li>
<li>git stash clear: 清空git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。</li>
<li>git stash apply [version]:将当前工作空间置为指定的暂存状态，通过暂存版本号。<br>适用场景，想要保存当前修改，但又不想提交当前修改时使用。</li>
</ol>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ vim test.md</span><br><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ git stash save <span class="string">&quot;1&quot;</span></span><br><span class="line">Saved working directory and index state On master: 1</span><br><span class="line">HEAD 现在位于 473eec8 te</span><br><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ vim test.md</span><br><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ git stash save <span class="string">&quot;2&quot;</span></span><br><span class="line">Saved working directory and index state On master: 2</span><br><span class="line">HEAD 现在位于 473eec8 te</span><br><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ git stash list</span><br><span class="line">stash@&#123;0&#125;: On master: 2</span><br><span class="line">stash@&#123;1&#125;: On master: 1</span><br><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ git stash apply stash@&#123;1&#125;</span><br><span class="line">位于分支 master</span><br><span class="line">尚未暂存以备提交的变更：</span><br><span class="line">  （使用 <span class="string">&quot;git add &lt;文件&gt;...&quot;</span> 更新要提交的内容）</span><br><span class="line">  （使用 <span class="string">&quot;git checkout -- &lt;文件&gt;...&quot;</span> 丢弃工作区的改动）</span><br><span class="line"></span><br><span class="line">	修改：     test.md</span><br><span class="line"></span><br><span class="line">修改尚未加入提交（使用 <span class="string">&quot;git add&quot;</span> 和/或 <span class="string">&quot;git commit -a&quot;</span>）</span><br><span class="line">dream@dream:~/IdeaProjects/<span class="built_in">test</span>$ cat test.md</span><br><span class="line"><span class="built_in">test</span> <span class="keyword">for</span> stash1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议使用git stash save “message” 做标记，否则一旦多个版本，自己都不知道哪个对应什么修改= =</p>
</blockquote>
<h4 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h4><p>标签常用于标记版本信息，标签就像一个不会变化的分支，被打上标签后，检出的工作空间状态就是打标签时刻的状态。</p>
<blockquote>
<p>查看标签</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#列出所有标签</span></span><br><span class="line">git tag</span><br><span class="line"><span class="comment">#列出符合条件的标签</span></span><br><span class="line">git tag -l <span class="string">&#x27;someKeyworldsAsREGEXP&#x27;</span></span><br></pre></td></tr></table></figure>
<p>列出的tag列表顺序与打标签的顺序无关。</p>
<blockquote>
<p>给分支打标签</p>
</blockquote>
<p>git标签分为轻量级标签和附注标签。轻量标签是指向提交的引用，如果只是临时性的标注代码，使用轻量级标签；附注标签则是一个相对独立的对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用GNU Privacy Guard (GPG)来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#给当前分支此时的状态打上轻量级标签</span></span><br><span class="line">git tag [tagName] -m [tag describe]</span><br><span class="line"><span class="comment">#给当前分支此时的状态打上附注标签</span></span><br><span class="line">git tag -a [tagName] -m [tag describe]</span><br><span class="line"><span class="comment">#查看标签信息</span></span><br><span class="line">git show [tagName]</span><br><span class="line"><span class="comment">#给指定的commit打上标签</span></span><br><span class="line">git tag [tagName] -m [tag describe] [commitId]</span><br><span class="line">git tag -a [tagName] -m [tag describe] [commitId]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>切换到指定标签</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#切换到指定标签，此时工作区的状态变回打标签时的状态</span></span><br><span class="line"><span class="comment">#并且此时处于一个空的临时分支，可以依赖此时的工作空间状态创建新的分支</span></span><br><span class="line">git checkout [tagName]</span><br></pre></td></tr></table></figure>


<blockquote>
<p>删除标签</p>
</blockquote>
<p>如果要修改标签，只能先删除再重新打</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -d [tagName]</span><br></pre></td></tr></table></figure>


<blockquote>
<p>发布标签</p>
</blockquote>
<p>进行push操作时，标签是不会被提交到远程仓库的。需要显示的提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将某个指定标签提交到远程仓库</span></span><br><span class="line">git push origin [tagName]</span><br><span class="line"><span class="comment">#将本地所有标签提交到远程服务器</span></span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>

<blockquote>
<p>标签签署</p>
</blockquote>
<p>标签签署需要生成公鈅和私钥。<br>生成签名密钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --gen-key</span><br></pre></td></tr></table></figure>
<p>按提示输入信息，有默认选项的没有必要的话可以直接回车。<br>给tag签名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#正常</span></span><br><span class="line">git tag -s [tagName] -m [tag describe]</span><br><span class="line"><span class="comment">#如果报密钥不可用</span></span><br><span class="line">git tag -u [上一步生成key时的姓名]  -s [tagName] -m [tag describe]</span><br></pre></td></tr></table></figure>
<p>查看签署信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git show [tagName]</span><br></pre></td></tr></table></figure>
<p>其他的开发者如果没有验证通过，是不能够修改你签署过的标签的。验证标签必须拥有签署者的公鈅，放到key ring[<em>位置在生成密钥时提示的路径，密钥也在其中</em>] 中。然后使用以下命令验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -v [tagName]</span><br></pre></td></tr></table></figure>

<h3 id="恢复已删除分支"><a href="#恢复已删除分支" class="headerlink" title="恢复已删除分支"></a>恢复已删除分支</h3><p>如果不小心删除了分支，可以使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reflog show</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -g</span><br></pre></td></tr></table></figure>
<p>查看提交记录，然后使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch [name] commitId</span><br></pre></td></tr></table></figure>
<p>来从一个commitId恢复分支出来，新分支名称就是[name]。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git推送本地已有代码到远程分支</title>
    <url>/2015/07/07/git-remote/</url>
    <content><![CDATA[<h2 id="git-将本地仓库推送到远程仓库"><a href="#git-将本地仓库推送到远程仓库" class="headerlink" title="git 将本地仓库推送到远程仓库 **"></a>git 将本地仓库推送到远程仓库 **</h2><ol>
<li><p>首先要在远程的git仓库上新建仓库，并记录地址，例如，我们创建的地址是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git@git.yanglong.com:root/example.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>gitbash进入本地已有代码的项目根文件夹下，执行下面的代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add ./</span><br><span class="line">git commit -m <span class="string">&quot;init&quot;</span></span><br><span class="line">git remote add origin git@git.yanglong.com:root/example.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Happen-Before</title>
    <url>/2017/04/14/happen-before/</url>
    <content><![CDATA[<h2 id="关于happen-before"><a href="#关于happen-before" class="headerlink" title="关于happen-before"></a>关于happen-before</h2><h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a><a href=""https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html#MemoryVisibility"">原文</a></h3><ol>
<li>Each action in a thread happens-before every action in that thread that comes later in the program’s order.   </li>
<li>An unlock (synchronized block or method exit) of a monitor happens-before every subsequent lock (synchronized block or method entry) of that same monitor. And because the happens-before relation is transitive, all actions of a thread prior to unlocking happen-before all actions subsequent to any thread locking that monitor.</li>
<li>A write to a volatile field happens-before every subsequent read of that same field. Writes and reads of volatile fields have similar memory consistency effects as entering and exiting monitors, but do not entail mutual exclusion locking.</li>
<li>A call to start on a thread happens-before any action in the started thread.</li>
<li>All actions in a thread happen-before any other thread successfully returns from a join on that thread. </li>
</ol>
<hr>
<h3 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h3><ol>
<li>一个线程对monitor解锁之前的所有写操作都对下一个对此monitor加锁的线程可见。即在加锁顺序上，上一个对资源加锁的线程所做的所有操作都对下一个加锁的线程可见。</li>
<li>如果线程1对volatile变量进行写操作，那么线程1此时及之前的所有写操作（不仅是volatile变量）对后续读取此volatile变量的线程可见。</li>
<li>线程写入的所有变量，对调用了此线程的jion()方法并成功返回的线程可见。即线程会在join()方法处执行完，且线程写入的变量对调用了此线程join()方法的线程可见。</li>
<li>线程中上一个写操作及之前的所有写操作在该线程执行下一个动作时对该线程可见。就是在一个单独的线程中，按照程序代码时间顺序执行操作。</li>
<li>线程的start方法在线程的任何操作之前。</li>
<li>happen before具有传递性，如果存在A&gt;B(&gt;可理解为A happen before B)，B&gt;C，则A&gt;C</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO的分类</title>
    <url>/2015/06/13/hexo-category/</url>
    <content><![CDATA[<p>** 环境说明**</p>
<blockquote>
<p>博客根目录I:\IDEAWorkspace\blog<br>主题根目录：I:\IDEAWorkspace\blog\themes\yilia</p>
</blockquote>
<h2 id="分类配置文件说明"><a href="#分类配置文件说明" class="headerlink" title="分类配置文件说明"></a>分类配置文件说明</h2><p>首先在博客根目录下有一个  <strong>_config.yml</strong>  配置文件，此配置文件是全局配置文件，具体配置信息参考网上，这里只说分类，打开此文件找到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br></pre></td></tr></table></figure>

<p>如上，保持默认即可，此配置的意思是分类的目录为 <em>categories</em> 我们的md文件在服务器运行时的访问路径是</p>
<blockquote>
<p>127.0.0.1:4000/categories/{我们定义的分类}</p>
</blockquote>
<p>那么分类如何定义呢？</p>
<span id="more"></span>
<h2 id="定义分类"><a href="#定义分类" class="headerlink" title="定义分类"></a>定义分类</h2><p>首先，打开主题根目录（I:\IDEAWorkspace\blog\themes\yilia\）下的  <strong>layout</strong>  文件夹，看有没有</p>
<blockquote>
<p>category.ejs</p>
</blockquote>
<p>文件，如果没有，新建一个，并写入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;%- partial(<span class="string">&#x27;_partial/archive&#x27;</span>, &#123;pagination: config.category, index: <span class="literal">true</span>&#125;) %&gt;</span><br></pre></td></tr></table></figure>
<p>打开同级目录下的  <strong>_partial/post</strong>  文件夹，查看有没有</p>
<blockquote>
<p>category.ejs</p>
</blockquote>
<p>文件，如果没有，新建一个，并写入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (post.categories &amp;&amp; post.categories.length)&#123; %&gt;</span><br><span class="line">	&lt;div class=<span class="string">&quot;article-category tagcloud&quot;</span>&gt;</span><br><span class="line">	&lt;%- list_categories(post.categories, &#123;</span><br><span class="line">	  show_count: <span class="literal">false</span>,</span><br><span class="line">	  class: <span class="string">&#x27;article-category&#x27;</span>,</span><br><span class="line">	  style: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">	  separator: <span class="string">&#x27;&#x27;</span></span><br><span class="line">	&#125;) %&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，打开根目录（I:\IDEAWorkspace\blog）下  <strong>scaffolds</strong>  目录，打开里面的3个md文件，并在每个文件中添加一行</p>
<blockquote>
<p>categories:</p>
</blockquote>
<p>例如  <strong>post.md</strong>  添加完后如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里只是让我们运行</p>
<blockquote>
<p>hexo new page “pageName”</p>
</blockquote>
<p>的时候生成如下的文件内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: pageName</span><br><span class="line">date: 2015-06-13 17:09:56</span><br><span class="line">categories:</span><br><span class="line">tags:</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>###接下来我们给文章添加分类，并让分类能够列出所有一样的分类文章</p>
<p>####给文章添加分类<br>新建一个md文件，填入内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: hexo的分类</span><br><span class="line">date: 2015-06-13 17:09:56</span><br><span class="line">categories: [hexo]</span><br><span class="line">tags: [博客,hexo,hexo github]</span><br><span class="line">---</span><br><span class="line">分类测试</span><br></pre></td></tr></table></figure>
<p>保存。<br>####使分类能够访问<br>转到主题根目录下（I:\IDEAWorkspace\blog\themes\yilia），打开  <strong>_config.yml</strong>  找到</p>
<blockquote>
<p>menu</p>
</blockquote>
<p>我的类似：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  主页: /</span><br><span class="line">  所有文章: /archives</span><br></pre></td></tr></table></figure>
<p>添加一个分类：</p>
<blockquote>
<p>hexo: /categories/hexo/</p>
</blockquote>
<p>变成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  主页: /</span><br><span class="line">  所有文章: /archives</span><br><span class="line">  <span class="comment"># 随笔: /tags/随笔</span></span><br><span class="line">  hexo: /categories/hexo/</span><br></pre></td></tr></table></figure>
<p>运行以下命令在本地查看效果：</p>
<ol>
<li>hexo clean</li>
<li>hexo s -g</li>
</ol>
<h2 id="可以看到，文章分类的访问路径组成，首先在项目根目录下配置分类的访问路径，本例中是默认的"><a href="#可以看到，文章分类的访问路径组成，首先在项目根目录下配置分类的访问路径，本例中是默认的" class="headerlink" title="可以看到，文章分类的访问路径组成，首先在项目根目录下配置分类的访问路径，本例中是默认的"></a>可以看到，文章分类的访问路径组成，首先在项目根目录下配置分类的访问路径，本例中是默认的</h2><blockquote>
<p>categories</p>
</blockquote>
<p>这步生成链接一部分：</p>
<blockquote>
<p>127.0.0.1:4000/categories/</p>
</blockquote>
<p>然后通过md文件中的</p>
<blockquote>
<p>categories: [hexo]</p>
</blockquote>
<p>来生成具体分类目录：</p>
<blockquote>
<p>127.0.0.1:4000/categories/hexo</p>
</blockquote>
<p>接着，设置主题的菜单分类：</p>
<blockquote>
<p>hexo: /categories/hexo/</p>
</blockquote>
<p>让文章分类和主题菜单分类导航关联起来，可以看到主题中的分类导航的链接必须是他之前2步走完生成的链接。</p>
<p>##中文分类映射<br>在项目的根目录的配置文件有这样的一个配置项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br></pre></td></tr></table></figure>
<p>我们设置分类可能有中文，那么访问路径就带有中文，所以要把他们转换掉，这时候就可以设置分类映射：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">		中文分类名1: eng1</span><br><span class="line">		中文分类名2: eng2</span><br><span class="line">tag_map:</span><br></pre></td></tr></table></figure>
<p>注意英文  <strong>:</strong>  和后面的内容间有空格，那么md文件中使用中文分类，然后在主题的配置文件中的分类导航像这样配置就好了：</p>
<blockquote>
<p>中文分类名1: /categories/eng1</p>
</blockquote>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>hexo github</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO初使用</title>
    <url>/2015/06/05/hexo-guide/</url>
    <content><![CDATA[<h2 id="首先安装node-js"><a href="#首先安装node-js" class="headerlink" title="首先安装node js"></a>首先安装node js</h2><h2 id="安装npm可以省略，最新版的node已经集成"><a href="#安装npm可以省略，最新版的node已经集成" class="headerlink" title="安装npm可以省略，最新版的node已经集成"></a>安装npm可以省略，最新版的node已经集成</h2><h3 id="首先进入某个目录，此例子为D"><a href="#首先进入某个目录，此例子为D" class="headerlink" title="首先进入某个目录，此例子为D:\"></a>首先进入某个目录，此例子为D:\</h3><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\&gt;npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>###初始化博客</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\&gt;hexo init blog</span><br></pre></td></tr></table></figure>
<p>###进入blog并安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\&gt;<span class="built_in">cd</span> blog</span><br><span class="line">D:\blog&gt;npm install</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>###启动服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\blog&gt;hexo server</span><br></pre></td></tr></table></figure>
<p>###到这一步，如果，没有错误，则人博客安装成功，在浏览器输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:4000</span><br></pre></td></tr></table></figure>
<p>可以看到hexo已经成功</p>
<h2 id="设置使用自己喜欢的主题"><a href="#设置使用自己喜欢的主题" class="headerlink" title="设置使用自己喜欢的主题"></a>设置使用自己喜欢的主题</h2><p>首先关闭服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+c</span><br></pre></td></tr></table></figure>
<p>询问是否输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">y</span><br></pre></td></tr></table></figure>
<p>终止服务器</p>
<p>hexo有很多的开源主题，可以自己搜索一个，这里用一个小清新的主题<a href="https://github.com/litten/hexo-theme-yilia" title="hexo主题">yilia</a></p>
<h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">浏览器打开 https://github.com/litten/hexo-theme-yilia/archive/master.zip 进行下载</span><br></pre></td></tr></table></figure>
<h3 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h3><p>将下载到的zip选择解压到当前目录，并改变文件夹名称为yilia<br>将yilia移动到D:\blog\themes文件夹下<br>打开D:\blog_config.yml文件找到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">theme: landscape</span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">theme: yilia</span><br></pre></td></tr></table></figure>

<p>在命令行中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\blog&gt;hexo server</span><br></pre></td></tr></table></figure>
<p>重启服务器，访问 127.0.0.1:4000 查看主题已经改变</p>
<h2 id="部署安装到github"><a href="#部署安装到github" class="headerlink" title="部署安装到github"></a>部署安装到github</h2><h3 id="前驱条件"><a href="#前驱条件" class="headerlink" title="前驱条件"></a>前驱条件</h3><ol>
<li>首先到<a href="https://github.com/" title="gitHub">github</a>注册账号，并新建一个仓库（具体步骤略），需要注意仓库的名称就是 yourAccountName.github.io,页面不要关闭，本例仓库：dr-yanglong.github.com</li>
<li>安装<a href="http://git-scm.com/downloads" title="git">git</a>,并生成SSH key，具体步骤参照<a href="http://git.oschina.net/wzw/git-quick-start">git 入门</a>，测试能够完全访问到github</li>
</ol>
<h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><p>在D:\blog下面右键，选择</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Git Init Here</span><br></pre></td></tr></table></figure>
<p>然后再右键，选择</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Git Bash</span><br></pre></td></tr></table></figure>
<p>在弹出CMD命令窗口稳定后，输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>接着用编辑器（记事本/下载<a href="http://www.sublimetext.com/2">sublime</a>）打开</p>
<blockquote>
<p>_config.yml</p>
</blockquote>
<p>从70行修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: git@github.com:DR-YangLong/dr-yanglong.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>注意每个 <strong>“:”</strong> 后面有空格，并且 <strong>“repository”</strong> 后面是你的git的仓库地址，在你创建完仓库的那个页面有</p>
<h4 id="执行命令部署到github"><a href="#执行命令部署到github" class="headerlink" title="执行命令部署到github"></a>执行命令部署到github</h4><p>最后一步，执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>
<p>将博客部署到github</p>
<p>打开github仓库页面，F5刷新，如果看到有很多代码，点击右边的</p>
<blockquote>
<p>Settings</p>
</blockquote>
<p>在打开的页面找到：</p>
<blockquote>
<p>GitHub Pages</p>
</blockquote>
<p>如果下面显示类似：</p>
<blockquote>
<p> Your site is published at <a href="http://dr-yanglong.github.io">http://dr-yanglong.github.io</a>. </p>
</blockquote>
<p>那么，你的博客就弄好了，接下来就是改一些名称，图片之类的。怎么改可以参照<a href="http://hexo.io/zh-cn/">Hexo官网</a>全中文，相信没压力。</p>
<h2 id="下面是一些命令"><a href="#下面是一些命令" class="headerlink" title="下面是一些命令"></a>下面是一些命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;postName&quot;</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo new page <span class="string">&quot;pageName&quot;</span> <span class="comment">#新建页面</span></span><br><span class="line">hexo generate <span class="comment">#生成静态页面至public目录</span></span><br><span class="line">hexo server <span class="comment">#开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span></span><br><span class="line">hexo deploy <span class="comment">#将.deploy目录部署到GitHub</span></span><br><span class="line">hexo <span class="built_in">help</span>  <span class="comment"># 查看帮助</span></span><br><span class="line">hexo version  <span class="comment">#查看Hexo的版本</span></span><br><span class="line"></span><br><span class="line">hexo deploy -g  <span class="comment">#生成加部署==hexo d -g</span></span><br><span class="line">hexo server -g  <span class="comment">#生成加预览==hexo s -g</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#简写</span></span><br><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>hexo github</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP响应码和说明</title>
    <url>/2015/07/07/http-code/</url>
    <content><![CDATA[<h1 id="HTTP响应码和说明"><a href="#HTTP响应码和说明" class="headerlink" title="HTTP响应码和说明"></a>HTTP响应码和说明</h1><p>2xx  成功<br>200  正常；请求已完成。<br>201  正常；紧接 POST 命令。<br>202  正常；已接受用于处理，但处理尚未完成。<br>203  正常；部分信息 — 返回的信息只是一部分。<br>204  正常；无响应 — 已接收请求，但不存在要回送的信息。<br>3xx  重定向<br>301  已移动 — 请求的数据具有新的位置且更改是永久的。<br>302  已找到 — 请求的数据临时具有不同 URI。<br>HTTP 303  请参阅其它 — 可在另一 URI 下找到对请求的响应，且应使用 GET 方法检索此响应。<br>HTTP 304  未修改 — 未按预期修改文档。<br>HTTP 305  使用代理 — 必须通过位置字段中提供的代理来访问请求的资源。<br>HTTP 306  未使用 — 不再使用；保留此代码以便将来使用。<br>HTTP 4xx  客户机中出现的错误<br>HTTP 400  错误请求 — 请求中有语法问题，或不能满足请求。<br>HTTP 401  未授权 — 未授权客户机访问数据。<br>HTTP 402  需要付款 — 表示计费系统已有效。<br>HTTP 403  禁止 — 即使有授权也不需要访问。<br>HTTP 404  找不到 — 服务器找不到给定的资源；文档不存在。<br>HTTP 407  代理认证请求 — 客户机首先必须使用代理认证自身。<br>HTTP 415  介质类型不受支持 — 服务器拒绝服务请求，因为不支持请求实体的格式。<br>HTTP 5xx  服务器中出现的错误<br>HTTP 500  内部错误 — 因为意外情况，服务器不能完成请求。<br>HTTP 501  未执行 — 服务器不支持请求的工具。<br>HTTP 502  错误网关 — 服务器接收到来自上游服务器的无效响应。<br>HTTP 503  无法获得服务 — 由于临时过载或维护，服务器无法处理请求。</p>
<hr>
<span id="more"></span>
<p>HTTP 400 - 请求无效<br>HTTP 401.1 - 未授权：登录失败<br>HTTP 401.2 - 未授权：服务器配置问题导致登录失败<br>HTTP 401.3 - ACL 禁止访问资源<br>HTTP 401.4 - 未授权：授权被筛选器拒绝<br>HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败<br>HTTP 403 - 禁止访问<br>HTTP 403 - 对 Internet 服务管理器 (HTML) 的访问仅限于 Localhost<br>HTTP 403.1 禁止访问：禁止可执行访问<br>HTTP 403.2 - 禁止访问：禁止读访问<br>HTTP 403.3 - 禁止访问：禁止写访问<br>HTTP 403.4 - 禁止访问：要求 SSL<br>HTTP 403.5 - 禁止访问：要求 SSL 128<br>HTTP 403.6 - 禁止访问：IP 地址被拒绝<br>HTTP 403.7 - 禁止访问：要求客户证书<br>HTTP 403.8 - 禁止访问：禁止站点访问<br>HTTP 403.9 - 禁止访问：连接的用户过多<br>HTTP 403.10 - 禁止访问：配置无效<br>HTTP 403.11 - 禁止访问：密码更改<br>HTTP 403.12 - 禁止访问：映射器拒绝访问<br>HTTP 403.13 - 禁止访问：客户证书已被吊销<br>HTTP 403.15 - 禁止访问：客户访问许可过多<br>HTTP 403.16 - 禁止访问：客户证书不可信或者无效<br>HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效<br>HTTP 404.1 - 无法找到 Web 站点<br>HTTP 404 - 无法找到文件<br>HTTP 405 - 资源被禁止<br>HTTP 406 - 无法接受<br>HTTP 407 - 要求代理身份验证<br>HTTP 410 - 永远不可用<br>HTTP 412 - 先决条件失败<br>HTTP 414 - 请求 - URI 太长</p>
<p>HTTP 500 - 内部服务器错误<br>HTTP 500.100 - 内部服务器错误 - ASP 错误<br>HTTP 500-11 服务器关闭<br>HTTP 500-12 应用程序重新启动<br>HTTP 500-13 - 服务器太忙<br>HTTP 500-14 - 应用程序无效<br>HTTP 500-15 - 不允许请求 global.asa<br>Error 501 - 未实现<br>HTTP 502 - 网关错误</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>http status</tag>
      </tags>
  </entry>
  <entry>
    <title>continue，break和goto</title>
    <url>/2017/05/16/java-continue/</url>
    <content><![CDATA[<h1 id="java之continue，break，goto"><a href="#java之continue，break，goto" class="headerlink" title="java之continue，break，goto"></a>java之continue，break，goto</h1><p>先说goto，goto是java中保留关键字，实际并未使用，goto在c中很强大，直接中断当前执行流程跳转到标记所在的流程点开始执行，但是这种能力不好掌控。<br>java中可以使用continue和break加标签达到类似的效果。</p>
<h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>continue在循环内部使用时，中断后面的代码执行，直接开始下一次循环。结合标签使用时，直接执行标签后面的循环代码的下一次循环：           </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//continue单层循环，output:13579</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">continue</span>;<span class="comment">//当偶数时跳过后面的执行语句，直接继续increment语句</span></span><br><span class="line">        <span class="comment">//打印j</span></span><br><span class="line">        System.out.print(j);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;\n===========&quot;</span>);</span><br><span class="line">    <span class="comment">//等同上面</span></span><br><span class="line">    outer:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">continue</span> outer;</span><br><span class="line">        System.out.print(i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;\n===========&quot;</span>);</span><br><span class="line">    outer:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//跳到outer处的increment语句执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">continue</span> outer;</span><br><span class="line">            System.out.println(<span class="string">&quot;inner:&quot;</span> + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//j的循环每次continue到i++，使得此处永不执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;outer:&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>break在循环内部使用时，中断后面代码执行并跳出<strong>当前</strong>循环，执行循环后面的代码，结合标签使用时，表示结束标签后的代码块执行，转而执行后面的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//output:012</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">2</span>)<span class="keyword">break</span>;</span><br><span class="line">    System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * outer:1</span></span><br><span class="line"><span class="comment"> * inner not break:2</span></span><br><span class="line"><span class="comment"> * outer:3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i++&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">2</span>) <span class="keyword">break</span>;<span class="comment">//i&lt;2时结束内层循环</span></span><br><span class="line">        System.out.println(<span class="string">&quot;inner not break:&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;outer:&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * break-inner[j]:0</span></span><br><span class="line"><span class="comment"> * break-inner[j]:1</span></span><br><span class="line"><span class="comment"> * break-inner[j]:2</span></span><br><span class="line"><span class="comment"> * break-end</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">outer:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;<span class="number">5</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">3</span>)<span class="keyword">break</span> outer;<span class="comment">//外层循环第一次执行，内层循环第4次执行时，中断标签后的循环代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;break-inner[j]:&quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;break-outer[i]:&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;break-end&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="continue和break结合"><a href="#continue和break结合" class="headerlink" title="continue和break结合"></a>continue和break结合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * level_4[m]-0</span></span><br><span class="line"><span class="comment"> * level_2[k]-0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">level_1:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;<span class="number">2</span>; j++) &#123;</span><br><span class="line">    level_2:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;<span class="number">3</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">2</span>)<span class="keyword">break</span> level_1;<span class="comment">//k&lt;2时执行level_3</span></span><br><span class="line">        level_3:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;<span class="number">2</span>; l++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k==<span class="number">1</span>)<span class="keyword">continue</span> level_2;<span class="comment">//只有k=0时执行了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt;<span class="number">2</span>; m++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(m==<span class="number">1</span>)<span class="keyword">break</span> level_3;<span class="comment">//只有k=0&amp;&amp;m=0时执行了，当m&gt;0时直接结束了level_3语句块</span></span><br><span class="line">                System.out.println(<span class="string">&quot;level_4[m]-&quot;</span>+m);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;level_3[l]-&quot;</span>+l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//k=0&amp;&amp;m=0执行，之后循环k=1，触发level_3的continue level_2，</span></span><br><span class="line">        <span class="comment">//直接k=2，然后触发break level_1，结束整段代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;level_2[k]-&quot;</span>+k);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;level_1[j]-&quot;</span>+j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM参数</title>
    <url>/2017/04/20/jvm-argument/</url>
    <content><![CDATA[<h2 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">含义</th>
<th align="center">默认值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-server</td>
<td align="center">启用server模式</td>
<td align="center">–</td>
<td align="center">启用server模式启动时较慢，编译将在启动时完成，在运行时能获得更好的性能</td>
</tr>
<tr>
<td align="center">-client</td>
<td align="center">启用client模式</td>
<td align="center">–</td>
<td align="center">启用client模式，jvm不会对编译阶段优化，启动较快，运行时性能较低</td>
</tr>
<tr>
<td align="center">-Xms</td>
<td align="center">初始堆大小</td>
<td align="center">物理内存的1/64(&lt;1GB&gt;)</td>
<td align="center">默认空余堆内存小于40%时（通过MinHeapFreeRatio参数调整），jvm就会增大堆内存，直到为-Xmx的值。</td>
</tr>
<tr>
<td align="center">-Xmx</td>
<td align="center">最大堆大小</td>
<td align="center">物理内存的1/4(&lt;1GB)</td>
<td align="center">默认空余堆内存大于70%时（通过MaxHeapFreeRatio参数调整），jvm会减少堆内存，直到-Xms的值。</td>
</tr>
<tr>
<td align="center">-Xmn</td>
<td align="center">年轻代大小，jdk&gt;=1.4</td>
<td align="center">不设置此值，年轻代默认为堆的1/3</td>
<td align="center">此值的大小是eden+2个survivor的大小</td>
</tr>
<tr>
<td align="center">-XX:NewRatio</td>
<td align="center">年轻代与年老代的比值倒数</td>
<td align="center">2</td>
<td align="center">设为4，表示年轻代:年老代=1:4，年轻代占堆内存1/(4+1)，如果设置Xms=Xmx且设置了Xmn，该参数不需要设置</td>
</tr>
<tr>
<td align="center">-XX:SurvivorRatio</td>
<td align="center">1个Survivor与Eden的比值倒数</td>
<td align="center">8</td>
<td align="center">设置为6，则Survivo:Eden=1:6，那么2个Survivor总共占年轻代的2/(6+1+1)大小</td>
</tr>
<tr>
<td align="center">-XX:PermSize</td>
<td align="center">设置持久代初始大小</td>
<td align="center">物理内存的1/64</td>
<td align="center">JDK1.8之前适用</td>
</tr>
<tr>
<td align="center">-XX:MaxPermSize</td>
<td align="center">设置持久代最大值</td>
<td align="center">物理内存的1/4</td>
<td align="center">JDK1.8之前适用</td>
</tr>
<tr>
<td align="center">-Xss</td>
<td align="center">每个线程的栈大小</td>
<td align="center">JDK5以后默认为1M，之前为256K</td>
<td align="center">在相同的物理内存下，减少此值能够生成更多的线程，但不会无限生产，受操作系统限制，大小需要根据具体应用设置</td>
</tr>
<tr>
<td align="center">-XX:ThreadStackSize</td>
<td align="center">栈深度</td>
<td align="center">根据操作系统不同而不同</td>
<td align="center">设为0表示使用操作系统默认栈深度</td>
</tr>
<tr>
<td align="center">-XX:LargePageSizeInBytes</td>
<td align="center">内存页大小</td>
<td align="center">–</td>
<td align="center">内存页大小不能设置太大，会影响perm大小</td>
</tr>
<tr>
<td align="center">-XX:+UseFastAccessorMethods</td>
<td align="center">启用原始类型快速优化</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr>
<td align="center">-XX:+DisableExplicitGC</td>
<td align="center">关闭System.gc()</td>
<td align="center">–</td>
<td align="center">关闭后，代码中调用此方法失效</td>
</tr>
<tr>
<td align="center">-XX:MaxTenuringThreshold</td>
<td align="center">对象最大年龄</td>
<td align="center">15</td>
<td align="center">每经过一次垃圾回收，存活下来的对象年龄+1，达到此值时，对象从年轻代移动到年老代，如果设置为0，则对象直接在年老代中分配，该参数只有在串行GC时有效</td>
</tr>
<tr>
<td align="center">-XX:+AggressiveOpts</td>
<td align="center">加快编译</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr>
<td align="center">-XX:+UseBiasedLocking</td>
<td align="center">启用偏向锁</td>
<td align="center">–</td>
<td align="center">启用锁优化，在锁低竞争程序中，启用偏向锁有助于性能提升，在锁竞争激烈的程序中，启用偏向锁会降低性能</td>
</tr>
<tr>
<td align="center">-Xnoclassgc</td>
<td align="center">禁用垃圾回收</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr>
<td align="center">-XX:SoftRefLRUPolicyMSPerMB</td>
<td align="center">每MB空闲空间中软引用的存活时间</td>
<td align="center">1s</td>
<td align="center">默认单位为秒</td>
</tr>
<tr>
<td align="center">-XX:PretenureSizeThreshold</td>
<td align="center">对象超过此参数设置的值时直接在年老代分配</td>
<td align="center">0</td>
<td align="center">单位为字节，0时此参数不起作用，且采用Parallel Scavenge GC时无效</td>
</tr>
<tr>
<td align="center">-XX:TLABWasteTargetPercent</td>
<td align="center">TLAB（Thread-local allocation buffer）占eden区的百分比</td>
<td align="center">1%</td>
<td align="center">–</td>
</tr>
<tr>
<td align="center">-XX:+CollectGen0First</td>
<td align="center">full GC前是否先进行一次young GC</td>
<td align="center">false</td>
<td align="center">–</td>
</tr>
</tbody></table>
<span id="more"></span>
<h2 id="辅助信息参数"><a href="#辅助信息参数" class="headerlink" title="辅助信息参数"></a>辅助信息参数</h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">含义</th>
<th align="center">默认值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-XX:+PrintGC</td>
<td align="center">打印GC信息</td>
<td align="center">–</td>
<td align="center">打印为GC简要信息，非稳定参数，已经标记为manageable</td>
</tr>
<tr>
<td align="center">-verbose:gc</td>
<td align="center">打印GC信息</td>
<td align="center">–</td>
<td align="center">GC简要信息，上面的稳定版本</td>
</tr>
<tr>
<td align="center">-XX:+PrintGCDetails</td>
<td align="center">打印GC详细信息</td>
<td align="center">–</td>
<td align="center">打印GC详细信息</td>
</tr>
<tr>
<td align="center">-XX:+PrintGCTimeStamps</td>
<td align="center">输出GC的时间戳（以基准时间的形式）</td>
<td align="center">–</td>
<td align="center">输出形式:–[GC[DefNew: 4416K-&gt;0K(4928K), 0.0001897 secs] 4790K-&gt;374K(15872K), 0.0002232 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</td>
</tr>
<tr>
<td align="center">-XX:+PrintGCApplicationStoppedTime</td>
<td align="center">打印垃圾回收期间程序暂停的时间。可与上面混合使用</td>
<td align="center">–</td>
<td align="center">输出形式:Total time for which application threads were stopped: 0.0468229 seconds</td>
</tr>
<tr>
<td align="center">-XX:+PrintGCApplicationConcurrentTime</td>
<td align="center">打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用</td>
<td align="center">–</td>
<td align="center">输出形式:Application time: 0.5291524 seconds</td>
</tr>
<tr>
<td align="center">-XX:+PrintHeapAtGC</td>
<td align="center">打印GC前后的详细堆栈信息</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr>
<td align="center">-Xloggc:filename</td>
<td align="center">设置打印日志文件</td>
<td align="center">–</td>
<td align="center">设置绝对路径</td>
</tr>
<tr>
<td align="center">-XX:+PrintClassHistogram</td>
<td align="center">垃圾回收前打印Histogram情况</td>
<td align="center">–</td>
<td align="center">使用G1收集器时有效</td>
</tr>
<tr>
<td align="center">-XX:+PrintTLAB</td>
<td align="center">打印TLAB空间的使用情况</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr>
<td align="center">XX:+PrintTenuringDistribution</td>
<td align="center">打印每次minor GC后新的存活周期的阈值</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
</tbody></table>
<blockquote>
<p>GC日志分析</p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"> [GC (Allocation Failure) 13817.377: [ParNew: 587356K-&gt;21969K(652288K), 0.0280778 secs] 815480K-&gt;250094K(1479680K), 0.0281542 secs] [Times: user=0.06 sys=0.00, real=0.03 secs] </span><br><span class="line">GC (Allocation Failure) ：引起GC的原因。</span><br><span class="line">[ParNew: 587356K-&gt;21969K(652288K), 0.0280778 secs]：GC的类型，ParNew为新生代垃圾收集器，说明是Minor GC，587356K为GC前新生代内存使用量，21969K为GC后新生代内存使用用，(652288K)为新生代总内存大小。</span><br><span class="line">815480K-&gt;250094K(1479680K)：815480K为Minor GC前堆内存总使用量，250094K为GC后堆内存总是用量，(1479680K)为堆总内存大小。</span><br><span class="line">时间为GC耗时。</span><br><span class="line">[Times: user=0.06 sys=0.00, real=0.03 secs]：user为程序耗时，是参与GC的所有cpu（cpu核心）耗时总和，sys为系统（内核）耗时，real为GC真正耗时</span><br><span class="line"></span><br><span class="line">[Full GC (System.gc()) 13952.460: [CMS: 228124K-&gt;185622K(827392K), 1.9256164 secs] 350869K-&gt;185622K(1479680K), [Metaspace: 313411K-&gt;313411K(557056K)], 1.9271636 secs] [Times: user=0.91 sys=0.97, real=1.93 secs] </span><br><span class="line">使用System.gc()进行FullGC，年老代使用CMS垃圾收集器，GC前年老代使用内存为228124K，GC后使用185622K，年老代总内存827392K，整个堆GC前使用350869K，GC后使用185622K，总共内存为1479680K，Metaspace GC前使用313411K，GC后使用313411K，整个Metaspace内存大小为557056K。</span><br></pre></td></tr></table></figure>

<h2 id="垃圾收集器参数"><a href="#垃圾收集器参数" class="headerlink" title="垃圾收集器参数"></a>垃圾收集器参数</h2><p>-XX:+UseSerialGC：使用Serial+Serial Old收集器组合。<br>-XX:+UseParNewGC：使用ParNew+Serial Old收集器组合。<br>-XX:+UseParallelGC：使用Parallel Scavenge+Serial Old收集器组合。<br>-XX:+UseParallelOldGC：使用Parallel Scavenge+Parallel Old收集器组合。<br>-XX:+UseConcMarkSweepGC：使用ParNew+CMS+Serial Old收集器组合，Serial Old收集器作为CMS出现“Concurrent Mode Failure”时的后备收集器。</p>
<h3 id="使用Parallel-Scavenge垃圾收集器可用的参数："><a href="#使用Parallel-Scavenge垃圾收集器可用的参数：" class="headerlink" title="使用Parallel Scavenge垃圾收集器可用的参数："></a>使用Parallel Scavenge垃圾收集器可用的参数：</h3><blockquote>
<p>-XX:MaxGCPauseMillis：必须设为&gt;0的整数，垃圾收集最大停顿时间。</p>
</blockquote>
<blockquote>
<p>-XX:GCTimeRatio：垃圾收集器运行时间和用户程序运行时间比值倒数，如95，则允许5%的GC时间。</p>
</blockquote>
<blockquote>
<p>-XX:UseAdaptiveSizePolicy：功能开关，设置此参数后，不需要配置新生代大小，Eden和Survivor比例，对象分代年龄参数，JVM动态调整堆中各个区域的大小以及对象分代年龄，提供合适的GC停顿时间。</p>
</blockquote>
<h3 id="使用CMS垃圾收集器参数："><a href="#使用CMS垃圾收集器参数：" class="headerlink" title="使用CMS垃圾收集器参数："></a>使用CMS垃圾收集器参数：</h3><blockquote>
<p>-XX:+UseCMSInitiatingOccupancyOnly：使JVM一直使用手动设置的JVM参数，不自动优化调节。</p>
</blockquote>
<blockquote>
<p>-XX:+CMSParallelInitialMarkEnabled：初始标记阶段使用多线程并行。</p>
</blockquote>
<blockquote>
<p>-XX:+CMSScavengeBeforeRemark：在进行重新标记之前，先进行一次young gc，这个参数可以防止年轻代中引用了年老代中的对象，导致这些年老代对象无法回收，例如ArrayList动态扩容时，ArrayList中的数组存在跨代引用，导致OOM。</p>
</blockquote>
<blockquote>
<p>-XX:+CMSParallelRemarkEnabled：在重新标记时使用多线程并行。</p>
</blockquote>
<blockquote>
<p>-XX:CMSInitiatingOccupancyFraction：设置CMS收集器在老年代空间被使用多少后出发垃圾收集，默认值为68%。有效设置此值能减少“Concurrent Mode Failure”发生概率，基本公式：(Tenured-Eden-Survivor)/Tenured。</p>
</blockquote>
<blockquote>
<p>-XX:+UseCMSCompactAtFullCollection：由于CMS收集器会产生碎片，此参数设置表示CMS收集器顶不住要进行Full GC时开启内存碎片整理，默认是开启的。</p>
</blockquote>
<blockquote>
<p>-XX:+CMSFullGCBeforeCompaction：设置CMS收集器在进行若干次垃圾收集后再进行一次内存碎片整理过程，通常与UseCMSCompactAtFullCollection参数一起使用，降低Full GC发生概率。</p>
</blockquote>
<h3 id="所有并行并发收集器适用参数"><a href="#所有并行并发收集器适用参数" class="headerlink" title="所有并行并发收集器适用参数"></a>所有并行并发收集器适用参数</h3><p>-XX:ParallelGCThreads：用于垃圾收集的线程数量，一般设置为CPU核心数。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集器与内存分配</title>
    <url>/2017/10/08/jvm-gc/</url>
    <content><![CDATA[<h1 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h1><blockquote>
<p>并行收集器：多个GC线程同时运行，在GC线程运行时，挂起用户线程。</p>
</blockquote>
<blockquote>
<p>并发收集器：多个GC线程同时运行，在某个GC阶段GC线程和用户线程同时运行，但有的阶段还需要挂起用户线程。</p>
</blockquote>
<h2 id="程序计数器，虚拟机栈，本地方法栈和方法区内存回收"><a href="#程序计数器，虚拟机栈，本地方法栈和方法区内存回收" class="headerlink" title="程序计数器，虚拟机栈，本地方法栈和方法区内存回收"></a>程序计数器，虚拟机栈，本地方法栈和方法区内存回收</h2><p>程序计数器，虚拟机栈和本地方法栈内存自动完成回收。方法区内存在full gc时被回收。</p>
<h2 id="判断对象是否需要回收"><a href="#判断对象是否需要回收" class="headerlink" title="判断对象是否需要回收"></a>判断对象是否需要回收</h2><p>计算对象是否需要回收2种判断方法，引用计数法和可达性分析法。<br>引用计数算法：对一个对象被引用的次数计数，为0则可以回收，缺点时但存在循环引用时无法真正彻底回收。<br>可达性分析算法：将称为GC Roots的对象作为起始点，向下搜寻，搜寻经过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，这个对象可以回收。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可作为GC Roots的对象：</span><br><span class="line">1. 虚拟机栈里栈帧中本地变量表中引用的对象。</span><br><span class="line">2. 方法区中类静态属性引用的对象。</span><br><span class="line">3. 方法区中常量引用的对象。</span><br><span class="line">4. 本地方法栈中JNI（native方法）引用的对象。</span><br></pre></td></tr></table></figure>
<p>java采用的是可达性分析算法。</p>
<span id="more"></span>
<h3 id="java引用"><a href="#java引用" class="headerlink" title="java引用"></a>java引用</h3><ol>
<li>强引用：Strong Reference,使用new关键字创建的引用，只要强引用还在，垃圾回收器不会回收被引用的对象。</li>
<li>软引用：Soft Reference,有用但非必需的对象。系统在发生内存溢出前会标记被引用对象，回收下面2中类型引用的对象，如果空间还不足，则回收软引用的对象，还不足则抛出内存溢出异常。</li>
<li>弱引用：Weak Reference,非必须对象，比软引用更弱，只要有垃圾回收，这些对象都会被回收。</li>
<li>虚引用：Phantom Reference，最弱的引用，<strong>对象是否有虚引用，不对其生存时间有影响</strong>，为一个对象设置虚引用关联的唯一目的就是在这个对象被垃圾收集器回收时收到一个系统通知。必须和ReferenceQueue组合使用，在队列中的对象都是已经被GC收集的对象，在虚引用对象上调用get方法均返回null。</li>
</ol>
<h3 id="回收对象"><a href="#回收对象" class="headerlink" title="回收对象"></a>回收对象</h3><p>在确定对象需要回收时，它会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法：</p>
<ol>
<li>对象是否覆盖finalize()。</li>
<li>被覆盖的finalize()是否执行过。<br>当对象没有覆盖finalize()方法或finalize()已经被执行过，则虚拟机认为没必要执行finalize()方法。<br>当对象被判断为有必要执行finalize()方法后，对象会被放到F-Queue队列中，由虚拟机自动建立一个低优先级的Finalizer线程去执行对象finalize()方法。注意，虚拟机会触发finalize()方法，但不保证会等待它执行结束。之后GC将会对F-Queue队列中的对象进行第二次标记，如果在finalize()执行中，对象将自己的引用重新与引用链上的任何一个对象建立联系，第二次标记时它将被移出“即将回收的集合”。<br>GC将在“即将回收的集合”中的对象回收。<br>回收的情况：</li>
<li>没有覆盖finalize()；</li>
<li>覆盖finalize()，但在方法中没有与引用链上的其他对象建立联系。</li>
</ol>
<h2 id="常见垃圾收集算法"><a href="#常见垃圾收集算法" class="headerlink" title="常见垃圾收集算法"></a>常见垃圾收集算法</h2><p>几种常见的垃圾收集算法。</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>Mark-Sweep算法，分为“标记”和“清除”两个阶段：首先标记出需要回收的对象，在标记完成后统一回收所有被标记的对象。是最基础的算法。<br>缺点：</p>
<ol>
<li>两个阶段的效率都不高。</li>
<li>标记清除后的内存空间不连续，有可能大对象在垃圾收集后还是无法分配，触发再次垃圾回收。<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3>Copying算法，将内存按容量分为大小相等的2块，每次只使用其中一块，当这块内存用完时，将还存活的对象复制到另外一块上面，将这块一次性完全清理掉。</li>
</ol>
<ul>
<li>优点：内存分配时不用考虑碎片问题，只要移动堆顶指针，按顺序分配内存，实现简单，运行高效</li>
<li>缺点：内存缩小为原来的一半，浪费空间。当对象存活率高时，效率变低。<br>对复制算法的改进，将内存分为3块，一块较大，另外两块较小且相等。每次使用较大的和较小的一块，当回收时将存活的复制到另外一块较小的，清理刚使用的较大的和其中较小的一块，再次使用时，使用较大的和未被清理的较小一块。<br>在hotspot中，分为3块，1块Eden和2块Survivor，默认比例为8:1:1。survivor一块为form，一块为to。先使用Eden和from，然后将存活的对象复制到to，清理Eden和from，然后使用Eden和to，下次则将存活的复制到from，清理Eden和to，使用Eden和from，如此往复。如果在回收时未使用的survivor区空间不够，则需要年老代担保，剩下的对象将直接进入年老代分配。<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3>主要用于年老代，标记过程同标记清除算法一样，但后续不是对可回收对象进行清理，而是让所有存活对象向一端移动，然后清理掉边界以外的内存。<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3>分代收集算法是根据对象存活周期将内存分分为几块，一般分为新生代和年老代，然后根据各个年代的特点采用最适当的收集算法。一般新生代使用复制算法，年老代采用标记-清除算法或标记-整理算法。</li>
</ul>
<h2 id="Hotspot-jvm算法实现"><a href="#Hotspot-jvm算法实现" class="headerlink" title="Hotspot jvm算法实现"></a>Hotspot jvm算法实现</h2><p>使用可达性分析算法进行对象是否可回收判断，在类加载的时候使用一组OopMap数据结构记录对象内各个偏移量指向的数据类型，在GC扫描时直接获得哪些地方存放着对象引用，快速完成GC Roots的枚举。<br>GC只会在用户线程到达SafePoint时进行，安全点选取是以“具备让程序长时间执行的特征为准”，最明显的特征是指令序列的复用，例如方法调用、循环跳转、异常跳转等。让用户线程中断的方式有2种，抢先式中断和主动式中断：抢先式中断，在GC发生时将用户线程全部挂起，如果发现有的线程没有到达安全点，则恢复线程，让它执行到安全点。主动式中断则是简单的设置一个标志位，各个线程执行时主动轮询这个标志，发现中断标志为真时就自动中断挂起，轮询标志的地方和安全点是重合的。<br>安全区域用于解决在GC前就挂起的线程运行问题，当线程执行到安全区域时，首先标记自己进入安全区域，当这段时间JVM发起GC时，就不用管这些线程，当这些线程要离开安全区域时，首先检查系统是否完成了根节点的枚举或整个GC过程，如果完成了，线程继续执行，否则线程继续挂起等待，直到收到可以离开安全区域的信号。<br>Hotspot对不同分代区域使用不同的垃圾收集算法实现的垃圾收集器。</p>
<h2 id="jvm垃圾收集器"><a href="#jvm垃圾收集器" class="headerlink" title="jvm垃圾收集器"></a>jvm垃圾收集器</h2><p>新生代垃圾收集器：Serial，ParNew，Parallel Scavenge<br>年老代垃圾收集器：Serial Old，Parallel Old，CMS<br>跨代垃圾收集器：G1</p>
<h3 id="新生代垃圾收集器"><a href="#新生代垃圾收集器" class="headerlink" title="新生代垃圾收集器"></a>新生代垃圾收集器</h3><p>新生代收集器都使用<strong>复制算法</strong>。</p>
<blockquote>
<p>Serial</p>
</blockquote>
<p>最基本的，单线程垃圾收集器。进行垃圾收集时，暂停其他所有用户线程，直到它收集结束。</p>
<blockquote>
<p>ParNew</p>
</blockquote>
<p>Serial收集器的多线程版本。进行垃圾收集时暂停其他所有用户线程，直到它收集结束。在单核心CPU中，ParNew性能不会优于Serial。使用-XX:+UseConcMarkSweepGC时的默认新生代收集器。</p>
<blockquote>
<p>Parallel Scavenge收集器</p>
</blockquote>
<p>吞吐量优先的收集器，多线程垃圾收集器，进行垃圾收集时，暂停所有用户线程，直到垃圾收集结束。吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。使用参数-XX:MaxGCPauseMillis和-XX:GCTimeRation控制GC时间。<br>-XX:MaxGCPauseMillis <strong>关注停顿时间</strong> ，大于0的毫秒数，收集器 <strong>尽可能保证</strong> 垃圾收集花费时间不超过设定值，需要根据实际情况合理设置。如果过小，会影响系统吞吐量。<br>-XX:GCTimeRation <strong>关注吞吐量</strong> ，大于0小于100的整数n，代表系统运行用户代码和垃圾收集时间的比值（n=用户运行代码时间/垃圾收集时间=n/1）。GC所占时间比率为1/(1+n)<br>-XX:+UseAdaptiveSizePolicy 不需要手动指定新生代大小，新生代中eden和survivor的比例，晋升年老代对象大小等细节参数，虚拟机会根据当前系统运行情况收集性能监控数据，动态调整这些参数以提供合适的停顿时间或最大吞吐量。</p>
<h3 id="年老代垃圾收集器"><a href="#年老代垃圾收集器" class="headerlink" title="年老代垃圾收集器"></a>年老代垃圾收集器</h3><blockquote>
<p>Serial Old</p>
</blockquote>
<p>单线程收集器，使用 “标记-整理”算法，进行垃圾收集时，暂停所有用户线程，直到垃圾收集结束。client模式下虚拟机使用。作为使用-XX:+UseConcMarkSweepGC开启CMS收集器收集失败时的后备预案。</p>
<blockquote>
<p>Parallel Old</p>
</blockquote>
<p>Parallel Scavenge的年老代版本，使用多线程和“标记-整理”算法。进行垃圾收集时，暂停所有用户线程，直到垃圾收集结束。</p>
<blockquote>
<p>CMS</p>
</blockquote>
<p>以获取<strong>最短回收停顿时间</strong>为目标的收集器。适合希望系统停顿时间最短的系统，如WEB系统。基于 <strong>“标记-清除”</strong> 算法的 <strong>多线程并发</strong> 收集器。<br>收集过程分为4个步骤： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始标记：暂停用户所有线程，进行GC Roots可直接到达对象的标记</span><br><span class="line">并发标记：用户线程和GC线程一起运行</span><br><span class="line">重新标记：暂停用户所有线程，对并发标记阶段用户线程运行导致标记产生变动的对象进行修正标记</span><br><span class="line">并发清除：用户线程和GC线程一起运行</span><br></pre></td></tr></table></figure>
<p>CMS收集器由于可以和用户线程并发进行，所以停顿时间较低，CMS通常配合ParNew或Serial收集器使用。</p>
<p>有3个明显缺点：</p>
<ol>
<li><p>CMS收集器默认开启垃圾回收线程数为(CPU数量+3)/4，也就是当CPU在4个以上时，并发回收垃圾收集线程不少于25%的CPU资源，并且随着CPU数量增加而下降。CPU数量=CPU物理核心数，一个核心一个线程。可以使用参数限制GC回收线程数量。当CPU数量不足4个时，由于线程切换，CMS收集器性能并不好。    </p>
</li>
<li><p>CMS收集器由于是并发标记阶段和用户线程一起运行，所以还会有一部分垃圾无法在当次垃圾(浮动垃圾)回收中处理。由于在进行垃圾回收最后阶段时用户线程还在运行，如果此时回收未在年老代空间分配完之前完成或剩余空间不够，可能引起“Concurrent Mode Failure”导致使用Serial Old进行Full GC。使用-XX:CMSInitiatingOccupancyFraction可以设定触发CMS执行垃圾回收时的容量阈值，默认68，当年老代容量达到68%时执行GC。解决cms失败的2个方式：降低触发阈值，但会造成频繁GC；增大新生代，同时降低触发阈值，调整full gc时压缩碎片的频次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMSInitiatingOccupancyFraction大小的确定：</span><br><span class="line">&#123;年老代-(eden+survivor)&#125;&#x2F;年老代*100%</span><br></pre></td></tr></table></figure></li>
<li><p>CMS基于“标记-清除”算法实现，在收集结束后会产生大量空间碎片，空间碎片会造成大对象无法分配问题。CMS收集器提供了-XX:+UseCMSCompactAtFullCollection在full gc之前开启碎片的合并整理，但在碎片整理时，停顿时间不得不变长，配合使用另外一个参数-XX:CMSFullGCsBeforeCompaction设定在进行了多少次不压缩的full gc后进行一次带压缩的full gc，以此减少停顿时间。</p>
</li>
</ol>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1收集器用来替换CMS收集器，整体基于“标记-整理”算法，局部基于“复制”算法，多线程并发收集器。G1同时用于新生代和年老代，且可指定最长垃圾回收停顿时间。<br>G1不在物理内存中划分出整块的新生代或年老代，而是将堆划分为多个大小相等的region，region可能用于新生代也可用于年老代。在内存回收时，优先回收垃圾较多的region。<br>大致分为4个步骤：</p>
<ol>
<li>初始标记 暂停用户所有线程，进行GC Roots可直接到达的对象标记。</li>
<li>并发标记 同用户线程一起运行，对垃圾对象进行标记。</li>
<li>最终标记 暂停用户所有线程，修正标记。</li>
<li>筛选回收 （目前）暂停用户所有线程，对回收价值高的region进行垃圾回收。</li>
</ol>
<h2 id="何时进行Minor-GC-Major-GC-full-GC-OOM触发条件"><a href="#何时进行Minor-GC-Major-GC-full-GC-OOM触发条件" class="headerlink" title="何时进行Minor GC,Major GC,full GC,OOM触发条件"></a>何时进行Minor GC,Major GC,full GC,OOM触发条件</h2><p>Minor GC为新生代GC，当新生代空间不够触发。<br>Major GC为年老代GC，一般触发时即使full gc，但在CMS中，在年老代空间超过阈值时触发CMS GC，即Major GC，并不触发full gc。<br>full gc，进行元数据区（方法区），新生代，年老代的gc，在年老代空间满或空间不够年轻代晋升年老代时需要的空间时触发，或在年老代提供的担保容量小于历次晋升到年老代对象的平均大小或不允许担保失败时。<br>经过GC，空间仍然不够新生对象存放，触发OOM。</p>
<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p>对象优先在Eden分配。大对象（例如超长字符串，数组）直接进入年老代。长期存活的对象进入年老代（默认经过15次GC，可用调节参数）。如果Survivor空间中相同年龄所有对象大小总和超过survivor空间的一半，年龄大于或等于该年龄的对象直接进入年老代，无须等到jvm设置的年龄要求。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Kryo序列化</title>
    <url>/2018/02/06/kryo/</url>
    <content><![CDATA[<h1 id="Kryo序列化"><a href="#Kryo序列化" class="headerlink" title="Kryo序列化"></a>Kryo序列化</h1><p>新版kryo提供了工厂类和序列化池，不用自己实现序列化池了。</p>
<h2 id="工场类："><a href="#工场类：" class="headerlink" title="工场类："></a>工场类：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.Kryo;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.Serializer;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.pool.KryoFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * functional describe:Kryo工厂类，&lt;code&gt;registerMap&lt;/code&gt;为需要自定义注册的类及其序列化器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DR.YangLong [410357434@163.com]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0    2018/2/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomKryoFactory</span> <span class="keyword">implements</span> <span class="title">KryoFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//有并发需求的话改为线程安全的map</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Class, Serializer&gt; registerMap;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Kryo <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Kryo kryo = <span class="keyword">new</span> Kryo();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != registerMap &amp;&amp; registerMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            registerMap.forEach((k, v) -&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    kryo.register(k, v);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    kryo.register(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> kryo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HashMap&lt;Class, Serializer&gt; <span class="title">getRegisterMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> registerMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRegisterMap</span><span class="params">(HashMap&lt;Class, Serializer&gt; registerMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registerMap = registerMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h3 id="序列化器"><a href="#序列化器" class="headerlink" title="序列化器"></a>序列化器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.Kryo;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.io.Input;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.io.Output;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.pool.KryoPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * functional describe: 使用kryo自身池实现序列化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DR.YangLong [410357434@163.com]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0    2018/2/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KryoSerializer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CustomKryoFactory factory;</span><br><span class="line">    <span class="keyword">private</span> KryoPool pool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KryoSerializer</span><span class="params">(CustomKryoFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">        <span class="keyword">this</span>.pool = <span class="keyword">new</span> KryoPool.Builder(factory).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 2进制数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException IO异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Kryo kryo = pool.borrow();</span><br><span class="line">            ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            Output output = <span class="keyword">new</span> Output(outputStream);</span><br><span class="line">            kryo.writeClassAndObject(output, obj);</span><br><span class="line">            pool.release(kryo);</span><br><span class="line">            output.close();</span><br><span class="line">            bytes = outputStream.toByteArray();</span><br><span class="line">            <span class="comment">//help gc</span></span><br><span class="line">            output = <span class="keyword">null</span>;</span><br><span class="line">            outputStream = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 输入的2进制字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException IO异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bytes != <span class="keyword">null</span> &amp;&amp; bytes.length != <span class="number">0</span>) &#123;</span><br><span class="line">            Object obj;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Kryo kryo = pool.borrow();</span><br><span class="line">                Input input = <span class="keyword">new</span> Input(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">                obj = kryo.readClassAndObject(input);</span><br><span class="line">                input.close();</span><br><span class="line">                pool.release(kryo);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                bytes = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.lvkebang.xmall.common.lang.StringSeriesTools;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.util.Assert;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * functional describe:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DR.YangLong [410357434@163.com]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0    2018/2/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KryoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//随机生成字符串</span></span><br><span class="line">        String str= StringSeriesTools.getRanDomStr(<span class="number">8</span>,<span class="number">1</span>);</span><br><span class="line">        CustomKryoFactory factory=<span class="keyword">new</span> CustomKryoFactory();</span><br><span class="line">        KryoSerializer serializer=<span class="keyword">new</span> KryoSerializer(factory);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes=serializer.serialize(str);</span><br><span class="line">        Object obj=serializer.deserialize(bytes);</span><br><span class="line">        Assert.isTrue(str.equals(obj.toString()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java内存区域与对象</title>
    <url>/2016/07/04/memory/</url>
    <content><![CDATA[<h1 id="java内存区域与内存溢出"><a href="#java内存区域与内存溢出" class="headerlink" title="java内存区域与内存溢出"></a>java内存区域与内存溢出</h1><h2 id="java的内存区域"><a href="#java的内存区域" class="headerlink" title="java的内存区域"></a>java的内存区域</h2><p>常规的认识中，java的内存区域分为堆和栈，这其实是个很泛的划分。</p>
<h3 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h3><ul>
<li>堆内存：所有线程共享的区域，存放对象实例。</li>
<li>方法区（永久代、非堆内存）：所有线程共享此区域，存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据。在逻辑上属于堆内存一部分，但为了区别开，通常叫做Non-Heap(非堆)。永久代只是GC分代收集中的概念，并不等同于方法区，在jdk1.8之后，废弃了方法区，引入了元数据区（MetaSpace），此区域为直接内存，可自动扩容，避免了PermGen的溢出错误。</li>
<li>运行时常量池：属于方法区一部分。Class文件中除了类的模板、字段、方法、接口等描述信息外，还有一项信息是常量池信息。常量池用于存放编译期生成的各种字面量和符号的引用。运行期产生的常量也可以放入，典型的比如字符串常量。JDK1.7之后已经从方法区移除。</li>
<li>虚拟机栈：描述了java方法执行的内存模型。存储方法执行都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链表，方法出口等信息，方法的调用到执行完毕对应栈帧的出栈和入栈。</li>
<li>本地方法栈：记录native方法的信息，具体信息根据虚拟机实现而定。</li>
<li>程序计数器：很小的内存空间，记录当前线程所执行的字节码指令地址。</li>
<li>直接内存：使用native函数库直接分配的堆外内存，大小不受java堆大小限制，只会受到物理机内存限制。</li>
</ul>
<span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">堆内存布局：分为年轻代和年老代，年轻代占1&#x2F;3容量，年老代占2&#x2F;3容量。</span><br><span class="line">年轻代又分为Eden和2个survivor，eden占8&#x2F;10，每个survivor占1&#x2F;10。</span><br><span class="line"></span><br><span class="line">年轻代中对象经过指定次数（默认15）的GC后存活，则转移到年老代中，通过 -XX:MaxTenuringThreshold指定。</span><br><span class="line">如下情况对象会直接进入年老代：</span><br><span class="line">1. 对象大小超过-XX:PretenureSizeThreshold设置的大小的直接进入年老代。</span><br><span class="line">2. 如果Survivo空间中相同年龄的所有对象大小总和大于Survivor空间的一半，年龄大于该年龄的对象直接进入年老代。</span><br></pre></td></tr></table></figure>

<h3 id="OutOfMemory"><a href="#OutOfMemory" class="headerlink" title="OutOfMemory"></a>OutOfMemory</h3><p>除了程序计数器，都会抛出，当创建对象时无法申请到空间时抛出。栈内存比较特殊，根据JVM的具体实现，当JVM对栈的实现是动态扩展的时候，如果扩展时无法申请到足够的内存时抛出。</p>
<h3 id="StackOverflowError"><a href="#StackOverflowError" class="headerlink" title="StackOverflowError"></a>StackOverflowError</h3><p>栈抛出，当线程请求的栈深度超过虚拟机所允许的深度时抛出。使用-Xss参数可控制栈内存容量。</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>对象的创建过程：</p>
<ol>
<li>定位类符号引用，检查此符号代表的类已经被加载，解析和初始化过，如果没有，执行类加载过程。</li>
<li>类加载检查通过后，为新对象分配内存。</li>
<li>将对象分配的除对象头部分的内存空间都初始化为0。</li>
<li>对对象进行必要的设置，包括：对象头信息填充，对象init方法的执行，将对象的属性值进行设置。</li>
</ol>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>此处参考<a href="https://segmentfault.com/a/1190000004574249">https://segmentfault.com/a/1190000004574249</a>。<br><img src="./object-in-memory.png" alt="JVM中对象内存布局"><br>对象在内存中分为3个区域：对象头，实例数据，对齐填充，前2个区域一定有，对齐填充是为了补齐，jvm要求对象地址必须是8byte的整数倍。</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头分为，Mark Word，klass，如果是数组结构数据，还有一个数组长度。</p>
<blockquote>
<p>Mark Word</p>
</blockquote>
<p>无论在32还是64系统，无论是否开启压缩，mark word都占一个位宽，即32位系统下为32bit，64位下为64bit。<br>在未锁定状态下，32位系统中：<br>有25bit用于存储hashcode，4bit用于存储对象分代年龄，2bit存储锁标志位，1bit固定为0。<br>在64位系统下：<br>31bit用于hashcode，4bit分代年龄，2bit锁标志位，1bit固定为0，未使用25bit。<br>32位系统在锁定状态时存储的内容：<br><img src="./mark-word-32bit.png" alt="JVM中对象内存布局"></p>
<p>64位系统在锁定状态时存储的内容：<br><img src="./mark-word-64bit.png" alt="JVM中对象内存布局"></p>
<blockquote>
<p>Klass</p>
</blockquote>
<p>类型指针，指向类。默认占一个位宽。64位系统下开启指针压缩，此部分占4byte，即变成32位下的大小。</p>
<blockquote>
<p>数据长度</p>
</blockquote>
<p>整型数据4byte。</p>
<p>对象头大小计算：<br>32位：<br>4byte(mark word)+4byte(klass)=8byte<br>64位未压缩:<br>8byte(mark word)+8byte(klass)=16byte<br>开启压缩:<br>8byte(mark word)+4byte(klass)=12byte    </p>
<p>数组，额外加4byte。</p>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><table>
<thead>
<tr>
<th>Primitive Type</th>
<th align="center">Memory Required(bytes)</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td align="center">1</td>
</tr>
<tr>
<td>byte</td>
<td align="center">1</td>
</tr>
<tr>
<td>short</td>
<td align="center">2</td>
</tr>
<tr>
<td>char</td>
<td align="center">2</td>
</tr>
<tr>
<td>int</td>
<td align="center">4</td>
</tr>
<tr>
<td>float</td>
<td align="center">4</td>
</tr>
<tr>
<td>long</td>
<td align="center">8</td>
</tr>
<tr>
<td>double</td>
<td align="center">8</td>
</tr>
<tr>
<td>reference</td>
<td align="center">32位4,64位8(开启压缩4)</td>
</tr>
<tr>
<td>实例数据存储顺序受到虚拟机分配策略参数和源码中的定义顺序影响，默认分配存储顺序策略为：longs/doubles、ints、shorts/chars、bytes/booleans、oops(普通对象引用指针)，父类的变量定义为在子类前面，如果开启CompactFields参数为true，子类中较窄的变量也可能会插入到父类变量空隙中。</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>当前两部分的数据大小之和不是8byte的倍数时，则有此部分数据，补充为8byte的倍数。如果已经是8byte的数据，则这部分不存在。这部分数据没有意义。</p>
<h2 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h2><p>对象访问有2种方式：句柄访问和指针访问。</p>
<h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p>对象的reference中存放句柄在句柄池中的地址，通过这个地址定位到句柄，句柄包含2部分内容：实例数据指针和对象类型指针。通过实例数据指针可以到实例池中获得指向的对象实例数据，通过对象类型指针可以得到对象类型数据。</p>
<h3 id="指针访问"><a href="#指针访问" class="headerlink" title="指针访问"></a>指针访问</h3><p>对象的reference中直接存储对象地址，此地址可以直接访问对象实例数据，实例数据中包含有指向对象类型的指针。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>使用句柄的好处是在对象被移动时只会改变句柄中的实例数据指针。reference不用修改。<br>使用指针的方式好处在速度更快，节省一次指针定位的时间。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis动态表</title>
    <url>/2015/09/17/mybatis-dynamic/</url>
    <content><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>有很多的数据，但是数据结构完全一致，根据数据来源存放不同的表，数据库中间件完全能做到，但代价太大。由于只是简单入库，所以使用MyBatis中的${}表达式替换表名进行入库，同时返回入库记录id。<br>对只使用EL (${})，同时使用ONGL(#{})以及混用做测试。jdbc链接最好指定允许多查询</p>
<blockquote>
<p>allowMultiQueries=true        </p>
</blockquote>
<span id="more"></span>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByPrimaryKey&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">statementType</span>=<span class="string">&quot;STATEMENT&quot;</span>&gt;</span></span><br><span class="line">       select</span><br><span class="line">       *</span><br><span class="line">       from $&#123;tableName&#125;</span><br><span class="line">       where id = $&#123;id&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByDataHash&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">       select count(0) from $&#123;tableName&#125; where data_md5=#&#123;dataMd5&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByPrimaryKey&quot;</span> <span class="attr">statementType</span>=<span class="string">&quot;STATEMENT&quot;</span>&gt;</span></span><br><span class="line">   delete from $&#123;tableName&#125;</span><br><span class="line">   where id = $&#123;id&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;insertByNativeSQL&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">       $&#123;nativeSQL&#125;;</span><br><span class="line">       SELECT last_insert_id() as id</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;insertByMap&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">       insert into $&#123;tableName&#125;</span><br><span class="line">       <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;(&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;)&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != null&quot;</span>&gt;</span></span><br><span class="line">               id,</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;comId != null&quot;</span>&gt;</span></span><br><span class="line">               com_id,</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;comName != null&quot;</span>&gt;</span></span><br><span class="line">               com_name,</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;values (&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;)&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != null&quot;</span>&gt;</span></span><br><span class="line">               #&#123;id&#125;,</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;comId != null&quot;</span>&gt;</span></span><br><span class="line">               #&#123;comId&#125;,</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;comName != null&quot;</span>&gt;</span></span><br><span class="line">               #&#123;comName&#125;,</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">trim</span>&gt;</span>;</span><br><span class="line">       select last_insert_id() as id</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;insertSelective&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">       insert into $&#123;tableName&#125;</span><br><span class="line">       <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;(&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;)&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;comId != null&quot;</span>&gt;</span></span><br><span class="line">               com_id,</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;comName != null&quot;</span>&gt;</span></span><br><span class="line">               com_name,</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;appDomain != null&quot;</span>&gt;</span></span><br><span class="line">               app_domain,</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;values (&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;)&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;comId != null&quot;</span>&gt;</span></span><br><span class="line">               #&#123;comId&#125;,</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;comName != null&quot;</span>&gt;</span></span><br><span class="line">               #&#123;comName&#125;,</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;appDomain != null&quot;</span>&gt;</span></span><br><span class="line">               #&#123;appDomain&#125;,</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">trim</span>&gt;</span>;</span><br><span class="line">       select last_insert_id() as id</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;insertByDomain&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">       insert into $&#123;tableName&#125;</span><br><span class="line">       <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;(&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;)&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;data.id != null&quot;</span>&gt;</span></span><br><span class="line">               id,</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;data.comId != null&quot;</span>&gt;</span></span><br><span class="line">               com_id,</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;data.comName != null&quot;</span>&gt;</span></span><br><span class="line">               com_name,</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;values (&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;)&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;data.id != null&quot;</span>&gt;</span></span><br><span class="line">               #&#123;data.id&#125;,</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;data.comId != null&quot;</span>&gt;</span></span><br><span class="line">               #&#123;data.comId&#125;,</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;data.comName != null&quot;</span>&gt;</span></span><br><span class="line">               #&#123;data.comName&#125;,</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">trim</span>&gt;</span>;</span><br><span class="line">       select last_insert_id() as id</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteByPrimaryKey</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id, <span class="meta">@Param(&quot;tableName&quot;)</span> String tableName)</span></span>;</span><br><span class="line"><span class="function">Integer <span class="title">insertSelective</span><span class="params">(<span class="meta">@Param(&quot;comId&quot;)</span> Integer comId, <span class="meta">@Param(&quot;comName&quot;)</span> String comName, <span class="meta">@Param(&quot;appDomain&quot;)</span> String appDomain,<span class="meta">@Param(&quot;tableName&quot;)</span> String tableName)</span></span>;</span><br><span class="line"><span class="function">Integer <span class="title">insertByMap</span><span class="params">(Map map)</span></span>;</span><br><span class="line"><span class="function">ComData <span class="title">selectByPrimaryKey</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id, <span class="meta">@Param(&quot;tableName&quot;)</span> String tableName)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertByNativeSQL</span><span class="params">(<span class="meta">@Param(&quot;nativeSQL&quot;)</span> String SQL)</span></span>;</span><br><span class="line"><span class="function">Integer <span class="title">insertByDomain</span><span class="params">(<span class="meta">@Param(&quot;tableName&quot;)</span> String tableName, <span class="meta">@Param(&quot;data&quot;)</span> ComData data)</span></span>;</span><br><span class="line"><span class="function">Integer <span class="title">selectByDataHash</span><span class="params">(<span class="meta">@Param(&quot;tableName&quot;)</span>String tableName,<span class="meta">@Param(&quot;dataMd5&quot;)</span>String dataMd5)</span></span>;</span><br></pre></td></tr></table></figure>


<p>说明，只是用EL表达式时，必须指定statementType=”STATEMENT”，混用时只能使用默认的”PREPARED”。</p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis快速入门</title>
    <url>/2015/09/17/mybatis-guide/</url>
    <content><![CDATA[<blockquote>
<p>本文只对MyBatis快速使用简介，想要了解更多信息，请前往<a href=""http://mybatis.github.io/mybatis-3/zh/index.html"" title="userGuide">MyBatis</a>查看官方帮助文档，部分示例也来源于此。       </p>
</blockquote>
<p>因为新入同事对MyBatis不熟悉，所以写下这个指导，只含有基础常用的说明。基于Spring framework整合，MyBatis采用xml配置文件的方式。</p>
<span id="more"></span>
<h2 id="MyBtis映射文件"><a href="#MyBtis映射文件" class="headerlink" title="MyBtis映射文件"></a>MyBtis映射文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.dao.UserStarMapper&quot;</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.model.UserStar&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;starId&quot;</span> <span class="attr">property</span>=<span class="string">&quot;starId&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;objectId&quot;</span> <span class="attr">property</span>=<span class="string">&quot;objectId&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;objectType&quot;</span> <span class="attr">property</span>=<span class="string">&quot;objectType&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;CHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;starDate&quot;</span> <span class="attr">property</span>=<span class="string">&quot;starDate&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;TIMESTAMP&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span> &gt;</span></span><br><span class="line">    starId, userId, objectId, objectType, starDate</span><br><span class="line">  <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByPrimaryKey&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span> &gt;</span></span><br><span class="line">    select </span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span> /&gt;</span></span><br><span class="line">    from user_star</span><br><span class="line">    where starId = #&#123;starId,jdbcType=BIGINT&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span> &gt;</span></span><br><span class="line">    delete from user_star</span><br><span class="line">    where starId = #&#123;starId,jdbcType=BIGINT&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.model.UserStar&quot;</span> &gt;</span></span><br><span class="line">    insert into user_star (starId, userId, objectId, </span><br><span class="line">      objectType, starDate)</span><br><span class="line">    values (#&#123;starId,jdbcType=BIGINT&#125;, #&#123;userId,jdbcType=BIGINT&#125;, #&#123;objectId,jdbcType=BIGINT&#125;, </span><br><span class="line">      #&#123;objectType,jdbcType=CHAR&#125;, #&#123;starDate,jdbcType=TIMESTAMP&#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertSelective&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.model.UserStar&quot;</span> &gt;</span></span><br><span class="line">    insert into user_star</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;(&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;)&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;starId != null&quot;</span> &gt;</span></span><br><span class="line">        starId,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userId != null&quot;</span> &gt;</span></span><br><span class="line">        userId,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;objectId != null&quot;</span> &gt;</span></span><br><span class="line">        objectId,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;objectType != null&quot;</span> &gt;</span></span><br><span class="line">        objectType,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;starDate != null&quot;</span> &gt;</span></span><br><span class="line">        starDate,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;values (&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;)&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;starId != null&quot;</span> &gt;</span></span><br><span class="line">        #&#123;starId,jdbcType=BIGINT&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userId != null&quot;</span> &gt;</span></span><br><span class="line">        #&#123;userId,jdbcType=BIGINT&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;objectId != null&quot;</span> &gt;</span></span><br><span class="line">        #&#123;objectId,jdbcType=BIGINT&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;objectType != null&quot;</span> &gt;</span></span><br><span class="line">        #&#123;objectType,jdbcType=CHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;starDate != null&quot;</span> &gt;</span></span><br><span class="line">        #&#123;starDate,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByPrimaryKeySelective&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.model.UserStar&quot;</span> &gt;</span></span><br><span class="line">    update user_star</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userId != null&quot;</span> &gt;</span></span><br><span class="line">        userId = #&#123;userId,jdbcType=BIGINT&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;objectId != null&quot;</span> &gt;</span></span><br><span class="line">        objectId = #&#123;objectId,jdbcType=BIGINT&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;objectType != null&quot;</span> &gt;</span></span><br><span class="line">        objectType = #&#123;objectType,jdbcType=CHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;starDate != null&quot;</span> &gt;</span></span><br><span class="line">        starDate = #&#123;starDate,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where starId = #&#123;starId,jdbcType=BIGINT&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.model.UserStar&quot;</span> &gt;</span></span><br><span class="line">    update user_star</span><br><span class="line">    set userId = #&#123;userId,jdbcType=BIGINT&#125;,</span><br><span class="line">      objectId = #&#123;objectId,jdbcType=BIGINT&#125;,</span><br><span class="line">      objectType = #&#123;objectType,jdbcType=CHAR&#125;,</span><br><span class="line">      starDate = #&#123;starDate,jdbcType=TIMESTAMP&#125;</span><br><span class="line">    where starId = #&#123;starId,jdbcType=BIGINT&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="MyBatis-XML文件节点介绍"><a href="#MyBatis-XML文件节点介绍" class="headerlink" title="MyBatis XML文件节点介绍"></a>MyBatis XML文件节点介绍</h2><h3 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h3><p>resultMap用于将查询出来的数据库列数据封装到pojo，配合select节点的resultMap属性使用。一个xml文件可以有多个不同id的resultMap<br>属性：</p>
<blockquote>
<p>id：一个namespace下只能有一个，标示这个resultMap      </p>
</blockquote>
<blockquote>
<p>type:与此resultMap绑定的pojo      </p>
</blockquote>
<p>子节点：</p>
<blockquote>
<ol>
<li>id:主键      </li>
<li>result:其他列       </li>
</ol>
</blockquote>
<p>column：数据库列名，如果查询时取了别名，这地方就是别名；property：数据库列名在pojo中对应的属性名，jdbcType列数据库类型名。</p>
<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>对应insert SQL，属性：</p>
<blockquote>
<ol>
<li>id: 对应DAO接口中的方法名</li>
<li>parameterType：参数类型，指定java类名，参数类型默认为map，下同</li>
<li>useGeneratedKeys：主键是否自增，true/false</li>
<li>keyProperty：主键对应的pojo中属性名        </li>
</ol>
</blockquote>
<p>insert使用主键自增时返回值为影响行数，并不是主键，要获取主键需要指定useGeneratedKeys=true且指定keyProperty，执行完后在pojo中获取keyProperty指定的属性值即为id值。</p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>对应delete SQL，属性：</p>
<blockquote>
<ol>
<li>id: 对应DAO接口中的方法名</li>
<li>parameterType：参数类型，指定java类名      </li>
</ol>
</blockquote>
<p>返回影响行数。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>对应查询SQL，属性：</p>
<blockquote>
<ol>
<li>id: 对应DAO接口中的方法名</li>
<li>parameterType：参数类型，指定java类名</li>
<li>resultMap：指定返回的resultMap，值为resultMap的id，与resultType 2选一</li>
<li>resultType：指定返回的java pojo，此时pojo的属性名必须和查询出的列名一致，与resultMap 2选一</li>
</ol>
</blockquote>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>对应更新SQL，属性:</p>
<blockquote>
<ol>
<li>id: 对应DAO接口中的方法名</li>
<li>parameterType：参数类型，指定java类名      </li>
</ol>
</blockquote>
<p>返回影响行数。</p>
<h2 id="xml文件与DAO绑定"><a href="#xml文件与DAO绑定" class="headerlink" title="xml文件与DAO绑定"></a>xml文件与DAO绑定</h2><blockquote>
<p>从MyBatis以后，使用 namespace 与DAO接口进行绑定<br>各节点通过id属性与DAO接口的各个方法绑定：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserStarMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteByPrimaryKey</span><span class="params">(Long starId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(UserStar record)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertSelective</span><span class="params">(UserStar record)</span></span>;</span><br><span class="line">    <span class="function">UserStar <span class="title">selectByPrimaryKey</span><span class="params">(Long starId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKeySelective</span><span class="params">(UserStar record)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKey</span><span class="params">(UserStar record)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数的传递：当只有一个参数时，可使用parameterType指定类型，传递多个参数时，需要封装为map类型，此时parameterType可以省略或指定为”map”，与spring整合后，可以使用注解绑定多个参数到map</p>
<blockquote>
<p>int selectNum(@Param(“userId”) Long userId, @Param(“featureId”) Long feature, @Param(“draft”) String draftFlag,@Param(“status”) String status, @Param(“pushFlag”) String push);      </p>
</blockquote>
<p>@Param的value属性将封装为map的key，参数的值将封装为map的value。     </p>
<p>获取参数：在SQL中使用<strong>#{}</strong>表达式取值或<strong>${}</strong>表达式取值，</p>
<blockquote>
<p>#{pojo.name}，${pojo.num}       </p>
</blockquote>
<p>#表示取值，$表示值替换，2者的区别，如传入String类型的”b”，前者在SQL中为</p>
<blockquote>
<p>select * from table where a=’b’       </p>
</blockquote>
<p>后者为</p>
<blockquote>
<p>select * from table where a=b</p>
</blockquote>
<p>类似于使用PreparedStatement和Statement。尽量使用#避免SQL注入，$可以使用在动态表等地方。</p>
<h2 id="简单查询返回数据与pojo绑定"><a href="#简单查询返回数据与pojo绑定" class="headerlink" title="简单查询返回数据与pojo绑定"></a>简单查询返回数据与pojo绑定</h2><blockquote>
<ol>
<li>select节点通过指定 resultMap 属性，然后resultMap通过type属性与pojo绑定     </li>
<li>select节点通过 resultType 与pojo绑定        </li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserStar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long starId;</span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line">    <span class="keyword">private</span> Long objectId;</span><br><span class="line">    <span class="keyword">private</span> String objectType;</span><br><span class="line">    <span class="keyword">private</span> Date starDate;</span><br><span class="line">    <span class="comment">//getter and setter...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>查询返回数据与pojo绑定时，在select节点使用resultMap或resultType，2者选一，resultType的值为java类全限定名（com.example.model.UserStar），或者SimpleClassName(UserStar,Spring环境下或配置了typeAliases)。</p>
<h2 id="进阶-动态SQL"><a href="#进阶-动态SQL" class="headerlink" title="进阶,动态SQL"></a>进阶,动态SQL</h2><p>当需要使用一个sql完成不同条件组合查询时，如果分开写，就会冗余很多的代码，此时可以使用动态SQL来完成一个SQL不同组合条件的查询。同理，在java中使用for循环批量新增修改数据时，在性能上有所欠缺，此时也可以使用动态SQL来进行批量处理。</p>
<h3 id="执行批量操作-foreach"><a href="#执行批量操作-foreach" class="headerlink" title="执行批量操作-foreach"></a>执行批量操作-foreach</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//省略节点属性</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id....</span>&gt;</span></span><br><span class="line">select u.id </span><br><span class="line">from user u</span><br><span class="line">where u.parent in</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id,jdbcType=BIGINT&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">结果：</span><br><span class="line">select u.id </span><br><span class="line">from user u</span><br><span class="line">where u.parent in(1,2,3,4)</span><br><span class="line"></span><br><span class="line">//省略节点属性</span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id...</span>&gt;</span></span><br><span class="line">insert into user(name,pwd) values </span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;users&quot;</span> <span class="attr">open</span>=<span class="string">&quot;&quot;</span> <span class="attr">close</span>=<span class="string">&quot;&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">item</span>=<span class="string">&quot;user&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">            (#&#123;user.name,jdbcType=VARCHAR&#125;,#&#123;user.pwd,jdbcType=VARCHAR&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">结果：</span><br><span class="line">insert into user(name,pwd) values(&#x27;a&#x27;,&#x27;a&#x27;),(&#x27;b&#x27;,&#x27;b&#x27;),(&#x27;c&#x27;,&#x27;c&#x27;)</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>collection:集合变量在参数map中的key，没有使用@Param指定时List实例将会以“list”作为key，而数组实例的key将是“array”</li>
<li>open:每次循环开始前输出</li>
<li>close:每次循环结束输出</li>
<li>separator:2次循环间的间隔输出</li>
<li>item:每次循环取出来的对象</li>
<li>index:循环下标变量</li>
</ol>
</blockquote>
<h3 id="条件判断-if"><a href="#条件判断-if" class="headerlink" title="条件判断-if"></a>条件判断-if</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">and:</span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=null and name!=null&quot;</span>&gt;</span></span><br><span class="line"> id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">or:</span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=null or name!=null&quot;</span>&gt;</span></span><br><span class="line"> id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>与java一致，test为true时输出节点的值，false时跳过，test的多条件写法，且使用AND,或使用OR</p>
</blockquote>
<h3 id="条件筛选trim-choose-where-set"><a href="#条件筛选trim-choose-where-set" class="headerlink" title="条件筛选trim,choose,where,set"></a>条件筛选trim,choose,where,set</h3><h4 id="trim动态拼装SQL"><a href="#trim动态拼装SQL" class="headerlink" title="trim动态拼装SQL"></a>trim动态拼装SQL</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertSelective&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.model.UserStar&quot;</span> &gt;</span></span><br><span class="line">    insert into user_star</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;(&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;)&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;starId != null&quot;</span> &gt;</span></span><br><span class="line">        starId,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userId != null&quot;</span> &gt;</span></span><br><span class="line">        userId,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;objectId != null&quot;</span> &gt;</span></span><br><span class="line">        objectId,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;objectType != null&quot;</span> &gt;</span></span><br><span class="line">        objectType,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;starDate != null&quot;</span> &gt;</span></span><br><span class="line">        starDate,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;values (&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;)&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;starId != null&quot;</span> &gt;</span></span><br><span class="line">        #&#123;starId,jdbcType=BIGINT&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userId != null&quot;</span> &gt;</span></span><br><span class="line">        #&#123;userId,jdbcType=BIGINT&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;objectId != null&quot;</span> &gt;</span></span><br><span class="line">        #&#123;objectId,jdbcType=BIGINT&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;objectType != null&quot;</span> &gt;</span></span><br><span class="line">        #&#123;objectType,jdbcType=CHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;starDate != null&quot;</span> &gt;</span></span><br><span class="line">        #&#123;starDate,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;dynamicTrimTest&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span>  </span><br><span class="line">    select * from t_blog   </span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;and |or&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span>  </span><br><span class="line">            title = #&#123;title&#125;  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;content != null&quot;</span>&gt;</span>  </span><br><span class="line">            and content = #&#123;content&#125;  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;owner != null&quot;</span>&gt;</span></span><br><span class="line">            or owner = #&#123;owner&#125;  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>prefix:开头输出</li>
<li>suffix:结束输出</li>
<li>suffixOverrides:自动判断开头或者结尾，如果有符合suffixOverrides表达式的值则去掉        </li>
</ol>
</blockquote>
<h4 id="choose动态取一条件查询"><a href="#choose动态取一条件查询" class="headerlink" title="choose动态取一条件查询"></a>choose动态取一条件查询</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">      AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">      AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">      AND featured = 1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>和java的switch一样，顺序匹配，匹配则中断，生成sql然后执行。</p>
<h4 id="where动态条件查询"><a href="#where动态条件查询" class="headerlink" title="where动态条件查询"></a>where动态条件查询</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">使用if的动态，会造成and跟在where后的错误：</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  WHERE </span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">    state = #&#123;state&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">    AND author_name like #&#123;author.name&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">使用where动态改造：</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>where会自动去掉多余的and和or，等价于</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;WHERE&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;AND |OR &quot;</span>&gt;</span></span><br><span class="line">  ... </span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="set动态更新"><a href="#set动态更新" class="headerlink" title="set动态更新"></a>set动态更新</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span></span><br><span class="line">  update Author</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>只更新符合条件的字段，等价于</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="复杂关联查询时的返回数据绑定association-collection等参见MyBatis相关主题"><a href="#复杂关联查询时的返回数据绑定association-collection等参见MyBatis相关主题" class="headerlink" title="复杂关联查询时的返回数据绑定association,collection等参见MyBatis相关主题"></a>复杂关联查询时的返回数据绑定association,collection等参见<a href=""http://mybatis.github.io/mybatis-3/zh/sqlmap-xml.html#Result_Maps"" title="goto">MyBatis相关主题</a></h3>]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA原生NIO示例</title>
    <url>/2017/05/09/nio-native/</url>
    <content><![CDATA[<h2 id="抽象类，抽象通用方法"><a href="#抽象类，抽象通用方法" class="headerlink" title="抽象类，抽象通用方法"></a>抽象类，抽象通用方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * functional describe:selector监听处理方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DR.YangLong [410357434@163.com]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0    2018/7/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractNio</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selector 选择器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listen</span><span class="params">(Selector selector)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//阻塞，直到有链接</span></span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                handlerKey(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到时间通知后具体的处理方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handlerKey</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * functional describe: nio服务端，接受客户端连接，读取客户端发送的消息打印到控制台，并返回消息。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DR.YangLong [410357434@163.com]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0    2018/4/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> <span class="keyword">extends</span> <span class="title">AbstractNio</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">2048</span>;</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer sendBuffer = ByteBuffer.allocate(BUFFER_SIZE);</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer receiveBuffer = ByteBuffer.allocate(BUFFER_SIZE);</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">openServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line">        serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">&quot;start server on port:&quot;</span> + port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handlerKey</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel server;</span><br><span class="line">        SocketChannel client;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">//1.服务端启动后，首先注册读事件，等待客户端输入</span></span><br><span class="line">            server = (ServerSocketChannel) key.channel();</span><br><span class="line">            client = server.accept();</span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">//2.当服务端可读时，读取客户端输入，然后注册写事件</span></span><br><span class="line">            client = (SocketChannel) key.channel();</span><br><span class="line">            receiveBuffer.clear();</span><br><span class="line">            count = client.read(receiveBuffer);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                receiveBuffer.flip();</span><br><span class="line">                String msg = <span class="keyword">new</span> String(receiveBuffer.array(), <span class="number">0</span>, receiveBuffer.limit());</span><br><span class="line">                System.out.println(<span class="string">&quot;server received msg:&quot;</span> + msg);</span><br><span class="line">                client.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">            <span class="comment">//3.当服务端可写时，向客户端发送数据，然后注册读事件</span></span><br><span class="line">            sendBuffer.clear();</span><br><span class="line">            client = (SocketChannel) key.channel();</span><br><span class="line">            String msg = <span class="string">&quot;msg from server&quot;</span>;</span><br><span class="line">            sendBuffer.put(msg.getBytes());</span><br><span class="line">            sendBuffer.flip();</span><br><span class="line">            client.write(sendBuffer);</span><br><span class="line">            client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">9997</span>;</span><br><span class="line">        NioServer nioServer = <span class="keyword">new</span> NioServer();</span><br><span class="line">        nioServer.openServer(port);</span><br><span class="line">        nioServer.listen(nioServer.getSelector());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Selector <span class="title">getSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSelector</span><span class="params">(Selector selector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.selector = selector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * functional describe: nio客户端，连接服务端，向服务端发送消息，接收服务端消息。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DR.YangLong [410357434@163.com]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0    2018/4/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioClient</span> <span class="keyword">extends</span> <span class="title">AbstractNio</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">2048</span>;</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer sendBuffer = ByteBuffer.allocate(BUFFER_SIZE);</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer receiveBuffer = ByteBuffer.allocate(BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connectedServer</span><span class="params">(<span class="keyword">final</span> String ip, <span class="keyword">final</span> <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(ip, port));</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">        System.out.println(<span class="string">&quot;client connect to server!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handlerKey</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel client;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">            <span class="comment">//1.客户端连接上时，注册写事件</span></span><br><span class="line">            client = (SocketChannel) key.channel();</span><br><span class="line">            <span class="keyword">if</span> (client.isConnectionPending()) &#123;</span><br><span class="line">                client.finishConnect();</span><br><span class="line">            &#125;</span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            client.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">//2.客户端可读时，读取从服务端发送过来的数据，然后注册写事件</span></span><br><span class="line">            client = (SocketChannel) key.channel();</span><br><span class="line">            receiveBuffer.clear();</span><br><span class="line">            count = client.read(receiveBuffer);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                receiveBuffer.flip();</span><br><span class="line">                String msg = <span class="keyword">new</span> String(receiveBuffer.array(), <span class="number">0</span>, receiveBuffer.limit());</span><br><span class="line">                System.out.println(<span class="string">&quot;client received msg:&quot;</span> + msg);</span><br><span class="line">                client.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">            <span class="comment">//3.客户端可写时，向服务端发送数据，并注册读事件</span></span><br><span class="line">            sendBuffer.clear();</span><br><span class="line">            client = (SocketChannel) key.channel();</span><br><span class="line">            String msg = <span class="string">&quot;msg from client&quot;</span>;</span><br><span class="line">            sendBuffer.put(msg.getBytes());</span><br><span class="line">            sendBuffer.flip();</span><br><span class="line">            client.write(sendBuffer);</span><br><span class="line">            client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        NioClient client = <span class="keyword">new</span> NioClient();</span><br><span class="line">        client.connectedServer(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9997</span>);</span><br><span class="line">        client.listen(client.getSelector());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Selector <span class="title">getSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSelector</span><span class="params">(Selector selector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.selector = selector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>nio</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro动态权限实现</title>
    <url>/2015/07/07/shiro-dynamic-perms/</url>
    <content><![CDATA[<h1 id="关于Shiro实现资源匹配权限的方式及实现动态权限思路"><a href="#关于Shiro实现资源匹配权限的方式及实现动态权限思路" class="headerlink" title="关于Shiro实现资源匹配权限的方式及实现动态权限思路"></a>关于Shiro实现资源匹配权限的方式及实现动态权限思路</h1><p>shiro使用filter的进行权限认证和过滤，其原理是将url和权限标识配对，生成filterchain，当请求进入时，对用户进行验权，因而要实现动态权限，只要更新filterchain即可。<a href="https://github.com/DR-YangLong/webarchitecture/tree/master/dr-common/src/main/java/com/dr/architecture/common/shiro" title="shiro动态权限">源码</a></p>
<h2 id="首先查看shiro的filterchain的生成"><a href="#首先查看shiro的filterchain的生成" class="headerlink" title="首先查看shiro的filterchain的生成"></a>首先查看shiro的filterchain的生成</h2><p>在文档中可以看到，shiro的filter实例都是由</p>
<blockquote>
<p> ShiroFilterFactoryBean</p>
</blockquote>
<p>来生成，其主要属性包含</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SecurityManager securityManager;</span><br><span class="line">   <span class="keyword">private</span> Map&lt;String, Filter&gt; filters;</span><br><span class="line">   <span class="keyword">private</span> Map&lt;String, String&gt; filterChainDefinitionMap; <span class="comment">//资源权限对应map</span></span><br><span class="line">   <span class="keyword">private</span> String loginUrl;</span><br><span class="line">   <span class="keyword">private</span> String successUrl;</span><br><span class="line">   <span class="keyword">private</span> String unauthorizedUrl;</span><br><span class="line">   <span class="keyword">private</span> AbstractShiroFilter instance;</span><br></pre></td></tr></table></figure>
<p>其中<strong>filterChainDefinitionMap</strong>属性就是我们所要动态改变的，</p>
<span id="more"></span>
<p>他实现了spring的2个核心接口</p>
<blockquote>
<p>FactoryBean, BeanPostProcessor</p>
</blockquote>
<p>2个最主要的方法：</p>
<blockquote>
<p>protected AbstractShiroFilter createInstance();</p>
</blockquote>
<p>负责创建filter</p>
<blockquote>
<p>protected FilterChainManager createFilterChainManager();</p>
</blockquote>
<p>负责创建FilterChainManager,这个FilterChainManager就负责管理所有的filter和filterchain，那么我们要实现动态权限，就需要通过他进行对filter的操作。我们要用到他的主要方法就一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createChain</span><span class="params">(String chainName, String chainDefinition)</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用url和权限字符串来添加一个filter，由于filter是在map中维护的，因而我们就可以实现filter的动态替换，新增。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ol>
<li>我们必须有个动态获取url–permission的dao</li>
<li>我们要用dao获得的url–permission生成filter添加/替换FilterChainManager中的filter，实现者是一个service</li>
<li>我们要实现service，就要获取到FilterChainManager</li>
</ol>
<p>首先根据ShiroFilterFactoryBean的属性，我们知道要获取的</p>
<blockquote>
<p>Map&lt;String, String&gt; filterChainDefinitionMap</p>
</blockquote>
<p>这样的东西，而且通过分析，他是一个LinkedHashMap，并且我们按shiro的默认权限字符串</p>
<blockquote>
<p>roles[1,2,3],perms[1,2,3]</p>
</blockquote>
<p>这样的方式来进行验证，当然，你也可以自定义权限filter的别名，在获取时候变一下就好。<br>那么我们的DAO接口是这样的，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DynamicPermissionDao</span> </span>&#123;</span><br><span class="line">  <span class="function">Map&lt;String,String&gt; <span class="title">findDefinitionsMap</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JdbcPermissionDao</span> <span class="keyword">extends</span> <span class="title">DynamicPermissionDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取url到权限的对应字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">LinkedHashMap&lt;String, String&gt; <span class="title">generateDefinitions</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了保证多来源，进行了接口继承。<br>接下来我们要进行service接口的设计，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * com.shiro</span></span><br><span class="line"><span class="comment"> * functional describe:动态权限配置Service</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DR.YangLong [410357434@163.com]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0 2015/1/17 10:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DynamicPermissionService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源权限的配置字符串模板</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREMISSION_STRING=<span class="string">&quot;perms[&#123;0&#125;]&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 角色权限的配置字符串模板</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROLE_STRING=<span class="string">&quot;roles[&#123;0&#125;]&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化时获取当前已定义的filterchains</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新框架资源权限配置，需要线程同步,此方法会动态添加definitions</span></span><br><span class="line"><span class="comment">     * 如果有重复的url，新的map将覆盖以前的map</span></span><br><span class="line"><span class="comment">     * 也就是说，以前链接的权限配置会被新的权限配置覆盖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">updatePermission</span><span class="params">(Map&lt;String, String&gt; newDefinitions)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要线程同步,此方法会加载静态配置，DynamicPermissionDao查询出来的配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reloadPermission</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的实现类要实现动态添加/替换的功能，必定要想办法获取FilterChainManager，通过分析filterFactoryBean我们知道，他最终的目的是用来生成</p>
<blockquote>
<p>AbstractShiroFilter</p>
</blockquote>
<p>而AbstractShiroFilter中有</p>
<blockquote>
<p>FilterChainResolver</p>
</blockquote>
<p>他的实际类型是</p>
<blockquote>
<p>PathMatchingFilterChainResolver</p>
</blockquote>
<p>那么通过PathMatchingFilterChainResolver我们可以获取到</p>
<blockquote>
<p>FilterChainManager</p>
</blockquote>
<p>那么，最核心的问题就解决了，所以最终的service接口的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        Copyright  DR.YangLong</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment">        you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">        You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">        distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">        See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">        limitations under the License.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> com.dr.architecture.common.shiro.dynamic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.config.Ini;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.util.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.web.config.IniFilterChainResolverFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.web.filter.mgt.DefaultFilterChainManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.web.servlet.AbstractShiroFilter;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * functional describe:shiro动态权限管理，&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 配置权限时，尽量不要使用/**来配置（重置时将被清除，如果要使用，在&#123;<span class="doctag">@link</span> JdbcPermissionDao&#125;实现类中最后添加key=&quot;/**&quot;，value=&quot;anon&quot;），每个链接都应该配置独立的权限信息&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DR.YangLong [410357434@163.com]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0 2015/1/17 11:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicPermissionServiceImpl</span> <span class="keyword">implements</span> <span class="title">DynamicPermissionService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DynamicPermissionServiceImpl.class);</span><br><span class="line">    <span class="keyword">private</span> AbstractShiroFilter shiroFilter;</span><br><span class="line">    <span class="keyword">private</span> DynamicPermissionDao dynamicPermissionDao;</span><br><span class="line">    <span class="keyword">private</span> String definitions = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;初始化filter加权限信息，在servlet的init方法之前。&quot;</span>);</span><br><span class="line">        reloadPermission();</span><br><span class="line">        logger.debug(<span class="string">&quot;初始化filter权限信息成功，开始执行servlet的init方法。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reloadPermission</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;reload资源权限配置开始！&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Map&lt;String, String&gt; pers = generateSection();</span><br><span class="line">            DefaultFilterChainManager manager = getFilterChainManager();</span><br><span class="line">            manager.getFilterChains().clear();</span><br><span class="line">            addToChain(manager, pers);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;reload资源权限配置发生错误！&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.debug(<span class="string">&quot;reload资源权限配置结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DefaultFilterChainManager <span class="title">getFilterChainManager</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取过滤管理器</span></span><br><span class="line">        PathMatchingFilterChainResolver filterChainResolver = (PathMatchingFilterChainResolver) shiroFilter</span><br><span class="line">                .getFilterChainResolver();</span><br><span class="line">        DefaultFilterChainManager manager = (DefaultFilterChainManager) filterChainResolver.getFilterChainManager();</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToChain</span><span class="params">(DefaultFilterChainManager manager, Map&lt;String, String&gt; definitions)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (definitions == <span class="keyword">null</span> || CollectionUtils.isEmpty(definitions)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移除/**的过滤器链，防止新加的权限不起作用。</span></span><br><span class="line">        manager.getFilterChains().remove(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : definitions.entrySet()) &#123;</span><br><span class="line">            String url = entry.getKey();</span><br><span class="line">            String chainDefinition = entry.getValue().trim().replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            manager.createChain(url, chainDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">updatePermission</span><span class="params">(Map&lt;String, String&gt; newDefinitions)</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;更新资源配置开始！&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取和清空初始权限配置</span></span><br><span class="line">            DefaultFilterChainManager manager = getFilterChainManager();</span><br><span class="line">            newDefinitions.put(<span class="string">&quot;/**&quot;</span>,<span class="string">&quot;anon&quot;</span>);</span><br><span class="line">            addToChain(manager, newDefinitions);</span><br><span class="line">            logger.debug(<span class="string">&quot;更新资源权限配置成功。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;更新资源权限配置发生错误!&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将静态配置的资源与要添加的动态资源整合在一起，生成shiro使用的权限map</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@see</span> org.apache.shiro.spring.web.ShiroFilterFactoryBean#setFilterChainDefinitions(String)&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Section</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Ini.<span class="function">Section <span class="title">generateSection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Ini ini = <span class="keyword">new</span> Ini();</span><br><span class="line">        ini.load(definitions); <span class="comment">// 加载资源文件节点串定义的初始化权限信息</span></span><br><span class="line">        Ini.Section section = ini.getSection(IniFilterChainResolverFactory.URLS); <span class="comment">// 使用默认节点</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(section)) &#123;</span><br><span class="line">            section = ini.getSection(Ini.DEFAULT_SECTION_NAME);<span class="comment">//如不存在默认节点切割,则使用空字符转换</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 加载非初始化定义的权限信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String, String&gt; permissionMap = loadDynamicPermission();</span><br><span class="line">        <span class="keyword">if</span> (permissionMap != <span class="keyword">null</span> &amp;&amp; !permissionMap.isEmpty()) &#123;</span><br><span class="line">            section.putAll(permissionMap);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> section;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载动态权限资源配置,map&lt;ant url,comma-delimited chain definition&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title">loadDynamicPermission</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; map=dynamicPermissionDao.findDefinitionsMap();</span><br><span class="line">        map.put(<span class="string">&quot;/**&quot;</span>,<span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DynamicPermissionDao <span class="title">getDynamicPermissionDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dynamicPermissionDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDynamicPermissionDao</span><span class="params">(DynamicPermissionDao dynamicPermissionDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dynamicPermissionDao = dynamicPermissionDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractShiroFilter <span class="title">getShiroFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shiroFilter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShiroFilter</span><span class="params">(AbstractShiroFilter shiroFilter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shiroFilter = shiroFilter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDefinitions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> definitions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefinitions</span><span class="params">(String definitions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.definitions = definitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，shiro动态权限基本实现了。所要做的不过是实现dao的接口，将service作为bean配置到spring配置文件中。<br>就像这样</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;shiroFilter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;securityManager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;securityManager&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;loginUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/sso/login&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;unauthorizedUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/sso/login&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;successUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/home/index&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;filters&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">util:map</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;authc&quot;</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.shiro.web.filter.authc.PassThruAuthenticationFilter&quot;</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">util:map</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;property name=&quot;filterChainDefinitions&quot;&gt;</span></span><br><span class="line"><span class="comment">           &lt;value&gt;</span></span><br><span class="line"><span class="comment">               /els/share/**=anon</span></span><br><span class="line"><span class="comment">               /teachers/t/invite/** = anon</span></span><br><span class="line"><span class="comment">               /camp/comp/s/**=authc,roles[student]</span></span><br><span class="line"><span class="comment">               /favicon.ico=anon</span></span><br><span class="line"><span class="comment">               /** = authc,roles[student]</span></span><br><span class="line"><span class="comment">           &lt;/value&gt;</span></span><br><span class="line"><span class="comment">       &lt;/property&gt;--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;filterChainDefinitionsFactory&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;com.yanglong.common.shiro.dynamic.DynamicPermissionServiceImpl&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dynamicPermissionDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jdbcPermissionDao&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;shiroFilter&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;shiroFilter&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;definitions&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">              /favicon.ico=anon</span><br><span class="line">              /sso/logout = logout</span><br><span class="line">          <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcPermissionDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yanglong.core.shiro.JdbcPermissionDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>shiro</tag>
        <tag>shiro 动态权限</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro集群环境下丢失session</title>
    <url>/2015/07/07/shiro-session/</url>
    <content><![CDATA[<p>#Shiro在集群环境下会丢失session解决<br>Shiro在集群时可能会选择Redis，ehcache，membercache等作为集群缓存，存放登陆认证的信息，有时候会存在丢失session的情况，通过分析，shiro自己实现了一个session，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSession</span> <span class="keyword">implements</span> <span class="title">ValidatingSession</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Serialization reminder:</span></span><br><span class="line">    <span class="comment">// You _MUST_ change this number if you introduce a change to this class</span></span><br><span class="line">    <span class="comment">// that is NOT serialization backwards compatible.  Serialization-compatible</span></span><br><span class="line">    <span class="comment">// changes do not require a change to this number.  If you need to generate</span></span><br><span class="line">    <span class="comment">// a new number in this case, use the JDK&#x27;s &#x27;serialver&#x27; program to generate it.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7125642695178165650L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO - complete JavaDoc</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(SimpleSession.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MILLIS_PER_SECOND = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MILLIS_PER_MINUTE = <span class="number">60</span> * MILLIS_PER_SECOND;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MILLIS_PER_HOUR = <span class="number">60</span> * MILLIS_PER_MINUTE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//serialization bitmask fields. DO NOT CHANGE THE ORDER THEY ARE DECLARED!</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> bitIndexCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ID_BIT_MASK = <span class="number">1</span> &lt;&lt; bitIndexCounter++;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> START_TIMESTAMP_BIT_MASK = <span class="number">1</span> &lt;&lt; bitIndexCounter++;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP_TIMESTAMP_BIT_MASK = <span class="number">1</span> &lt;&lt; bitIndexCounter++;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_ACCESS_TIME_BIT_MASK = <span class="number">1</span> &lt;&lt; bitIndexCounter++;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMEOUT_BIT_MASK = <span class="number">1</span> &lt;&lt; bitIndexCounter++;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXPIRED_BIT_MASK = <span class="number">1</span> &lt;&lt; bitIndexCounter++;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HOST_BIT_MASK = <span class="number">1</span> &lt;&lt; bitIndexCounter++;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ATTRIBUTES_BIT_MASK = <span class="number">1</span> &lt;&lt; bitIndexCounter++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Serializable id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Date startTimestamp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Date stopTimestamp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Date lastAccessTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">long</span> timeout;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">boolean</span> expired;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Map&lt;Object, Object&gt; attributes;</span><br></pre></td></tr></table></figure>

<p>可以看到，很多属性是<strong>transient</strong>修饰的，也就是说，当我们不使用JDK原生序列化机制时，这些属性不会被序列化，特别是源码注释也说明了这一点，而我们使用的序列化器往往考虑到性能，使用的是ASM或反射机制来实现的序列化，因而在没有是否序列化transient属性的设置时，往往默认不序列化，例如Kryo，已经是一个定死的属性，不序列化transient属性。<br>那么解决的方式也很简单：</p>
<ol>
<li>使用兼容原生序列化机制的序列化器。</li>
<li>重新SimpleSession</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>shiro</tag>
        <tag>shiro 丢失session</tag>
      </tags>
  </entry>
  <entry>
    <title>Fremark集成Shiro标签</title>
    <url>/2015/06/13/shiro-tags/</url>
    <content><![CDATA[<p>#Shiro整合Freemark标签<br>写个java类，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        Copyright  DR.YangLong</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment">        you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">        You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">        distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">        See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">        limitations under the License.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> com.dr.architecture.common.shiro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dr.architecture.common.shiro.tags.ShiroTags;</span><br><span class="line"><span class="keyword">import</span> freemarker.template.TemplateException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * com.up360.extension.security.shiro</span></span><br><span class="line"><span class="comment"> * functional describe:shiro freemark标签 https://github.com/jagregory/shiro-freemarker-tags</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DR.YangLong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0  datetime:2014/12/10 16:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroFreemarkTagsConfigurer</span> <span class="keyword">extends</span> <span class="title">FreeMarkerConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TemplateException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">this</span>.getConfiguration().setSharedVariable(<span class="string">&quot;shiro&quot;</span>, <span class="keyword">new</span> ShiroTags());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在配置spring的视图解析器时，将<strong>FreeMarkerConfigurer</strong>替换为此类即可。具体可参考shiro-freemarker-tags项目中的说明。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>shiro</tag>
        <tag>shiro freemark标签</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring无法通过接口注入实现类</title>
    <url>/2015/06/25/spring-di/</url>
    <content><![CDATA[<h1 id="关于Spring-无法注入接口的实现类，通常报错类似："><a href="#关于Spring-无法注入接口的实现类，通常报错类似：" class="headerlink" title="关于Spring 无法注入接口的实现类，通常报错类似："></a>关于Spring 无法注入接口的实现类，通常报错类似：</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.IllegalArgumentException: Cannot convert value of type [xxxx] to required type [xxxxImpl] <span class="keyword">for</span> property <span class="string">&#x27;xxxx&#x27;</span>: no matching editors or conversion strategy found</span><br></pre></td></tr></table></figure>

<h2 id="首先检查aop设置，确认当前配置文件中配置了"><a href="#首先检查aop设置，确认当前配置文件中配置了" class="headerlink" title="首先检查aop设置，确认当前配置文件中配置了"></a>首先检查aop设置，确认<strong>当前配置文件中</strong>配置了</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;aop:aspectj-autoproxy proxy-target-<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;true&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<h2 id="其次"><a href="#其次" class="headerlink" title="其次"></a>其次</h2><p>重命名你的接口，然后实现类实现的接口也更新为新的接口名称。</p>
<h1 id="如果还不能解决，确认依赖jar包完整和其他配置无误。"><a href="#如果还不能解决，确认依赖jar包完整和其他配置无误。" class="headerlink" title="如果还不能解决，确认依赖jar包完整和其他配置无误。"></a>如果还不能解决，确认依赖jar包完整和其他配置无误。</h1>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
        <tag>spring 依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security流程简要分析</title>
    <url>/2018/09/24/spring-security/</url>
    <content><![CDATA[<h1 id="Spring-Security认证授权基本结构"><a href="#Spring-Security认证授权基本结构" class="headerlink" title="Spring Security认证授权基本结构"></a>Spring Security认证授权基本结构</h1><p><img src="./Spring_Security.bmp" alt="web下大概流程图"></p>
<h2 id="Spring-Security的Filter"><a href="#Spring-Security的Filter" class="headerlink" title="Spring Security的Filter"></a>Spring Security的Filter</h2><p>Spring Security通过一系列的Fliter来进行认证授权。<br>通过SecurityFilterAutoConfiguration注册一系列的SecurityFilter到FilterChainProxy，对请求进行一层层过滤。<br>Spring Security内置的Fliter，按照顺序如下：</p>
<ol>
<li>ChannelProcessingFilter，如果你访问的 channel 错了，那首先就会在 channel 之间进行跳转，如 http 变为 https。</li>
<li>SecurityContextPersistenceFilter，一开始进行request的时候在SecurityContextHolder中建立一个SecurityContext，然后在请求结束的时候，任何对SecurityContext的改变都可以被copy到HttpSession。</li>
<li>ConcurrentSessionFilter，因为它需要使用 SecurityContextHolder 的功能，而且更新对应 session 的最后更新时间，以及通过SessionRegistry 获取当前的 SessionInformation 以检查当前的session 是否已经过期，过期则会调用 LogoutHandler。</li>
<li>认证处理Filter，如 UsernamePasswordAuthenticationFilter，CasAuthenticationFilter，BasicAuthenticationFilter 等，以至于 SecurityContextHolder 可以被更新为包含一个有效的 Authentication 请求。</li>
<li>SecurityContextHolderAwareRequestFilter，它将会把HttpServletRequest 封装成一个继承自 HttpServletRequestWrapper 的 SecurityContextHolderAwareRequestWrapper，同时使用SecurityContext 实现了 HttpServletRequest 中与安全相关的方法。</li>
<li>JaasApiIntegrationFilter，如果 SecurityContextHolder 中拥有的 Authentication 是一个 JaasAuthenticationToken，那么该 Filter 将使用包含在 JaasAuthenticationToken 中的 Subject 继续执行 FilterChain。</li>
<li>RememberMeAuthenticationFilter，如果之前的认证处理机制没有更新 SecurityContextHolder，并且用户请求包含了一个 Remember-Me 对应的 cookie，那么一个对应的 Authentication 将会设给 SecurityContextHolder。</li>
<li>AnonymousAuthenticationFilter，如果之前的认证机制都没有更新 SecurityContextHolder 拥有的 Authentication，那么一个AnonymousAuthenticationToken 将会设给 SecurityContextHolder。</li>
<li>ExceptionTransactionFilter，用于处理在 FilterChain 范围内抛出的 AccessDeniedException 和 AuthenticationException，并把它们转换为对应的Http错误码返回或者对应的页面。</li>
<li>FilterSecurityInterceptor，保护 Web URI，并且在访问被拒绝时抛出异常。</li>
</ol>
<p>其中，通常需要扩展的地方在4这个位置。可以通过AbstractConfiguredSecurityBuilder的addFilter方法进行添加，addFilter方法可指定添加位置，自定义的Filter要添加到FilterSecurityInterceptor之前ConcurrentSessionFilter之后。</p>
<span id="more"></span>
<h2 id="WEB-http认证授权"><a href="#WEB-http认证授权" class="headerlink" title="WEB http认证授权"></a>WEB http认证授权</h2><p>request请求经过认证处理Filter时，此filter从request中获取需要的账号，凭证，生成未认证的Authentication，委托给AuthenticationManager进行认证，实际上是由AuthenticationManager的实现类ProviderManager进行认证，ProviderManager持有多个AuthenticationProvider实例，循环找出支持当前Authentication的provider实例，进行认证，在provider中，首先使用UserdetailsService的loadUserByUsername获取单前用户名对应的用户在系统中的信息，之后对用户状态进行检查，如果通过检查，则使用PasswordEncoder进行凭证对比，如果一致，则认证成功，否则认证失败。无论认证成功或失败，ProviderManager都会通过预先配置的AuthenticationEventPublisher发布相应事件。另外可以在认证处理filter中预先设置成功或失败的Handler，对认证失败或成功进行自定义的处理。</p>
<h2 id="扩展点"><a href="#扩展点" class="headerlink" title="扩展点"></a>扩展点</h2><p>一般web程序而言，扩展自己的认证流程。以下步骤即可：</p>
<ol>
<li>自定义Authentication，继承自AbstractAuthenticationToken。</li>
<li>自定义AuthenticationProvider,实现AuthenticationProvider接口。supports方法支持1中定义的Authentication。authenticate方法根据自身业务，加载系统中用户，与request中用户做对比，完成认证授权。</li>
<li>自定义认证Filter，继承自AbstractAuthenticationProcessingFilter，实现attemptAuthentication方法，从request中生成1中定义的Authentication，使用AuthenticationManager进行认证。</li>
<li>通过WebSecurityConfigurerAdapter将自定义的provider配置到AuthenticationManagerBuilder，将自定义的认证filter配置到HttpSecurity。</li>
</ol>
<p>另外，自定义的AuthenticationProvider中，获取用户信息和对比用户凭证也可扩展。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
        <tag>spring security</tag>
      </tags>
  </entry>
  <entry>
    <title>SVN迁移到Git</title>
    <url>/2019/06/16/svn%E8%BF%81%E7%A7%BB%E5%88%B0git/</url>
    <content><![CDATA[<h1 id="svn迁移到git"><a href="#svn迁移到git" class="headerlink" title="svn迁移到git"></a>svn迁移到git</h1><p>为什么要从svn迁移到git？<br>svn适合项目管理，将项目产出（包括交付代码）在svn上进行管理，有细粒度的权限控制，但不适合代码管理，svn分支和tag太重，使用svn不容易做到开发流程管控，而且极容易出现代码相互覆盖，git配合git flow可以很容易做到代码开发流程管控。</p>
<h2 id="如何从svn迁移到git"><a href="#如何从svn迁移到git" class="headerlink" title="如何从svn迁移到git"></a>如何从svn迁移到git</h2><ol>
<li>git svn命令，git提供了此命令，使使用svn可以使用git命令。</li>
<li>将svn迁出到本地使用git初始化为git仓库。</li>
<li>在git服务器新建仓库。</li>
<li>将本地代码推送到远程git仓库。</li>
</ol>
<h3 id="安装git-svn"><a href="#安装git-svn" class="headerlink" title="安装git-svn"></a>安装git-svn</h3><p>CentOS:</p>
<blockquote>
<p>yum install -y git-svn</p>
</blockquote>
<p>MacOSX:</p>
<blockquote>
<p>brew install git subversion</p>
</blockquote>
<p>其他操作系统自理。</p>
<span id="more"></span>

<h3 id="git远程准备"><a href="#git远程准备" class="headerlink" title="git远程准备"></a>git远程准备</h3><p>去要迁移的svn代码库，看代码库有多少个svn账号使用此代码库，新建svn用户到git用户的映射文件，格式如下</p>
<blockquote>
<p>[svn用户名]=[git用户名][&lt;git用户email&gt;]</p>
</blockquote>
<p>中括号为变量标识符，一个文件如下user.txt：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">zhang_san=张三&lt;zhang_san@leapmotor.com&gt;</span><br><span class="line">yang_long=杨龙&lt;yang_long@leapmotor.com&gt;</span><br></pre></td></tr></table></figure>

<p>如果git服务端没有svn的用户，可以先建用户。</p>
<h3 id="检出svn代码库"><a href="#检出svn代码库" class="headerlink" title="检出svn代码库"></a>检出svn代码库</h3><p>使用git命令检出svn代码库。</p>
<h4 id="从标准svn代码库检出"><a href="#从标准svn代码库检出" class="headerlink" title="从标准svn代码库检出"></a>从标准svn代码库检出</h4><p>SVN仓库使用标准的了/trunk, /branches和/tags的目录结构,并没有使用其他目录。<br>检出命令：</p>
<blockquote>
<p>git svn clone –stdlayout –authors-file=<userfile> <svn-repo>/<project> <git-repo-name></p>
</blockquote>
<p>例子：</p>
<blockquote>
<p>git svn clone –stdlayout –authors-file=userinfo.txt <a href="https://svn.example.com/web">https://svn.example.com/web</a> web</p>
</blockquote>
<h4 id="从非标准svn代码库检出"><a href="#从非标准svn代码库检出" class="headerlink" title="从非标准svn代码库检出"></a>从非标准svn代码库检出</h4><p>SVN仓库目录不标准。<br>检出命令：      </p>
<blockquote>
<p>git svn clone –trunk=/trunk –branches=<branche_n> –branches=<branche_n> –tags=<branche_n> –authors-file=<userfile> <svn-repo>/<project> <git-repo-name></p>
</blockquote>
<p>例子：      </p>
<blockquote>
<p>git svn clone –trunk=/trunk –branches=/branches –branches=/bugfixes –branches=/releases –tags=/tags –authors-file=userinfo.txt <a href="https://svn.example.com/web">https://svn.example.com/web</a> web</p>
</blockquote>
<h3 id="处理svn分支"><a href="#处理svn分支" class="headerlink" title="处理svn分支"></a>处理svn分支</h3><p>列出当前分支</p>
<blockquote>
<p>git branch</p>
</blockquote>
<p>将svn的tag分支转换为git的tag</p>
<blockquote>
<p>git tag <tagname> <svn tag branche></p>
</blockquote>
<p>删除已经转换好的svn分支</p>
<blockquote>
<p>git branch -r -d <svn tag branch></p>
</blockquote>
<h3 id="本地代码推送到git远程仓库"><a href="#本地代码推送到git远程仓库" class="headerlink" title="本地代码推送到git远程仓库"></a>本地代码推送到git远程仓库</h3><p>在本地代码库根目录执行</p>
<blockquote>
<p>git init</p>
</blockquote>
<blockquote>
<p>git remote add origin &lt;git地址&gt;</p>
</blockquote>
<blockquote>
<p>git push origin master –tags </p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>系统重构与重写</title>
    <url>/2015/07/08/system-refactoring/</url>
    <content><![CDATA[<h1 id="关于系统重构"><a href="#关于系统重构" class="headerlink" title="关于系统重构"></a>关于系统重构</h1><p>其实对于系统重构，首先应该分清<strong>重写</strong>和<strong>重构的区别</strong>。</p>
<blockquote>
<p>重构：在现有基础上进行扩展整合和代码及业务流程梳理。<br>重写：顾明思议，重新进行一个全新系统的开发。</p>
</blockquote>
<p>##为什么要进行系统重构</p>
<ol>
<li>过于复杂的代码结构满足不了新的需求。</li>
<li>生产力开始受到明显的影响。</li>
<li>系统维护性降低。</li>
</ol>
<p>##什么时候开始重构<br>引用老外的话说，当你的代码出现badsmell时就应该启动重构。</p>
<ol>
<li><p>重复的代码。</p>
<blockquote>
<p>如果你在一个以上的地点看到相同的程序结构，那么可以肯定：设法将他们合二为一。</p>
</blockquote>
</li>
<li><p>过长的函数。</p>
<blockquote>
<p>越短的函数会存活的时间更长，存活的更好。</p>
</blockquote>
</li>
<li><p>过长的类。</p>
<blockquote>
<p>如果想利用单一的类做很多的事情，那么该类的内部会出现很多的instance变量，重复代码就要接踵而至了。</p>
</blockquote>
</li>
<li><p>过长的参数列。</p>
<blockquote>
<p>太长的参数列难以理解，太多的参数会造成前后不一致，不易使用，一旦你需要更多的数据，就不得不修改它。</p>
</blockquote>
</li>
<li><p>发散式变化。</p>
<blockquote>
<p>一旦我修改软件，我希望只在一处修改就好，如果不能做到这点，该坏味道就出现了。</p>
</blockquote>
</li>
<li><p>烟雾弹式修改。</p>
<blockquote>
<p>一旦软件进行修改，你必须去对多个类的内部做小修改，该坏味道出现了。</p>
</blockquote>
</li>
<li><p>依恋情结。</p>
<blockquote>
<p>函数对某个类的兴趣高过对自己所处之host类的兴趣，坏味道出现了。</p>
</blockquote>
</li>
</ol>
<span id="more"></span>
<p>重构的含义：</p>
<blockquote>
<p>重构（名词）：对软件内部结构的一种调整，目的是在不改变“软件之可观察行为”的前提下，提高其可理解性，降低其修改成本。重构之前，首先检查自己是否有一套可靠的测试机制。<br>——Martin Fowler，《重构》</p>
</blockquote>
<h2 id="重构并不是万金油"><a href="#重构并不是万金油" class="headerlink" title="重构并不是万金油"></a>重构并不是万金油</h2><p>重构并不能解决所有的问题，到了一定的阶段，不可避免的要进行系统重写。</p>
<h1 id="关于系统重写"><a href="#关于系统重写" class="headerlink" title="关于系统重写"></a>关于系统重写</h1><p>系统重写，也就是将软件的实现重写一遍。</p>
<h2 id="为什么是重写而不是重构与什么时候开始重写"><a href="#为什么是重写而不是重构与什么时候开始重写" class="headerlink" title="为什么是重写而不是重构与什么时候开始重写"></a>为什么是重写而不是重构与什么时候开始重写</h2><ol>
<li>将原先一个无安全需求的系统改造为安全性良好的系统。大多数情况下重构解决不了问题。</li>
<li>现有代码根本不能正常运作。你可能只是试着做点测试，然后就发现代码中满是错误，根本无法稳定运作。</li>
<li>新需求的开发成本会超过开发一个新的软件的成本，这时候旧软件该寿终正寝了。</li>
<li>系统存在很多奇点，一个不可用导致整个系统不可用。</li>
<li>整个架构存在问题。</li>
</ol>
<h1 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h1><p>中国当前的真个IT大环境和社会一样浮躁，架构师在推动重构和重写时基本无法推动，因为绝大部分公司老板不了解重构与重写带来的变化，只要听到要延长进度，基本不会允许，所以这在绝大多数情况下是软件本身质量和软件产生经济价值的权衡，“既然能用，为什么要花费更多的时间来重构甚至重写呢？！”其实每个程序猿，每个架构师都希望做出完美的系统，然而现实是骨感的，所以很多架构师和程序猿总是从一个坑跳到另一个坑。当然如果你现处于一个开发的架构不错，拥有开发规范，从上而下推动codereview的一个公司，恭喜你，你所在的公司其实非常不错了。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>系统重构</tag>
        <tag>系统重写</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库的脏读、幻读、不可重复读</title>
    <url>/2016/06/06/transaction-feature/</url>
    <content><![CDATA[<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><p>在看elasticsearch时看到译者注释数据库事务，感觉不太准确，写这文章，复习下。</p>
<h2 id="数据库事务的特征"><a href="#数据库事务的特征" class="headerlink" title="数据库事务的特征"></a>数据库事务的特征</h2><p>数据库事务特征ACID。</p>
<blockquote>
<p>A Atomicity 原子性</p>
</blockquote>
<p>事务是一个原子性质的操作单元，事务里面的对数据库的操作要么都执行，要么都不执行，</p>
<blockquote>
<p>C Consistent 一致性</p>
</blockquote>
<p>在事务开始之前和完成之后，数据都必须保持一致状态，必须保证数据库的完整性。也就是说，数据必须符合数据库的规则。</p>
<blockquote>
<p>I Isolation 隔离性</p>
</blockquote>
<p>数据库允许多个并发事务同事对数据进行操作，隔离性保证各个事务相互独立，事务处理时的中间状态对其它事务是不可见的，以此防止出现数据不一致状态。可通过事务隔离级别设置：包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）</p>
<blockquote>
<p>D Durable 持久性</p>
</blockquote>
<p>一个事务处理结束后，其对数据库的修改就是永久性的，即使系统故障也不会丢失。</p>
<span id="more"></span>
<h2 id="脏读、幻读、不可重复读"><a href="#脏读、幻读、不可重复读" class="headerlink" title="脏读、幻读、不可重复读"></a>脏读、幻读、不可重复读</h2><ul>
<li>脏读：一个事务还未提交，另外一个事务访问此事务修改的数据，并使用，读取了事务中间状态数据。</li>
<li>幻读：一个事务读取2次，得到的记录条数不一致，由于2次读取之间另外一个事务对数据进行了增删。</li>
<li>不可重复读：一个事务读取同一条记录2次，得到的结果不一致，由于在2次读取之间另外一个事务对此行数据进行了修改。</li>
</ul>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>设置不同的事务隔离级别：</p>
<blockquote>
<p>未授权读取</p>
</blockquote>
<p>也称为读未提交（Read Uncommitted）：允许脏读取，但不允许更新丢失。如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。</p>
<blockquote>
<p>授权读取</p>
</blockquote>
<p>也称为读提交（Read Committed）：允许不可重复读取，但不允许脏读取。这可以通过“瞬间共享读锁”和“排他写锁”实现。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。</p>
<blockquote>
<p>可重复读取（Repeatable Read）</p>
</blockquote>
<p>可重复读取（Repeatable Read）：禁止不可重复读取和脏读取，但是有时可能出现幻读数据。这可以通过“共享读锁”和“排他写锁”实现。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。</p>
<blockquote>
<p>序列化（Serializable）</p>
</blockquote>
<p>序列化（Serializable）：提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。</p>
<p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>transaction</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu编译JDK7</title>
    <url>/2016/06/30/ubuntu-build-jdk7/</url>
    <content><![CDATA[<h1 id="ubuntu下编译JDK7"><a href="#ubuntu下编译JDK7" class="headerlink" title="ubuntu下编译JDK7"></a>ubuntu下编译JDK7</h1><h2 id="心里准备"><a href="#心里准备" class="headerlink" title="心里准备"></a>心里准备</h2><p>安装会遇到各种问题，需要静下心来解决，很多问题谷歌上的和自己本身的不一样，但总的来说编译完成的时候还是觉得很高兴的。<br>各种错的参考地址：<a href="http://www.centoscn.com/image-text/install/2015/0908/6140.html">http://www.centoscn.com/image-text/install/2015/0908/6140.html</a><br>后面才发现的= =，之前折腾好久</p>
<h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><h3 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dream@dream:~/jvm/openjdk$ uname -a</span><br><span class="line">Linux dream 4.4.0-28-generic <span class="comment">#47-Ubuntu SMP Fri Jun 24 10:09:13 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure>
<p>ubuntu 64位，16.04LTS</p>
<h3 id="jdk"><a href="#jdk" class="headerlink" title="jdk"></a>jdk</h3><p>因为jdk的编译很多也是java编写的，所以也需要一个基础版本的jdk用来编译它，叫bootsrap jdk。</p>
<ol>
<li>bootstrap jdk：sun的jdk6u45，注意尽量不要使用编译目标的同版本或以后版本，会出一些问题。尽量安装编译目标的readme中的环境来。下载并解压。</li>
<li>目标版本：openjdk7，下载并解压。</li>
</ol>
<span id="more"></span>
<h2 id="编译所需环境"><a href="#编译所需环境" class="headerlink" title="编译所需环境"></a>编译所需环境</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ccache make gcc g++ ca-certificates ca-certificates-java</span><br><span class="line">sudo apt-get install libX11-dev libxext-dev libxrender-dev libxtst-dev</span><br><span class="line">sudo apt-get install libasound2-dev libcups2-dev libfreetype6-dev</span><br><span class="line">sudo apt-get install ALSA libcups2-dev</span><br></pre></td></tr></table></figure>
<p>个人环境不同，有的依赖组件在编译时报错会提示，如果出错提示，再安装即可。</p>
<h3 id="编译使用脚本"><a href="#编译使用脚本" class="headerlink" title="编译使用脚本"></a>编译使用脚本</h3><p>虽然脚本中有unset jdk环境变量，但是最好还是将自己设置的环境变量注释掉。</p>
<blockquote>
<p>2个需要注意和修改的地方ALT_BOOTDIR修改为自己的bootsrap jdk根目录，ALT_OUTPUTDIR修改为想要存放编译结果的目录</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="comment">#语言选项，这个必须设置，否则编译好后会出现一个HashTable的NPE错</span></span><br><span class="line"><span class="built_in">export</span> LANG=C</span><br><span class="line"></span><br><span class="line"><span class="comment">#Bootstrap JDK的安装路径。必须设置。</span></span><br><span class="line"><span class="built_in">export</span> ALT_BOOTDIR=/home/dream/Downloads/jdk1.6.0_45</span><br><span class="line"></span><br><span class="line"><span class="comment">#允许自动下载依赖</span></span><br><span class="line"><span class="built_in">export</span> ALLOW_DOWNLOADS=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#并行编译的线程数，设置为和CPU内核数量一致即可</span></span><br><span class="line"><span class="built_in">export</span> HOTSPOT_BUILD_JOBS=4</span><br><span class="line"><span class="built_in">export</span> ALT_PARALLEL_COMPILE_JOBS=4</span><br><span class="line"></span><br><span class="line"><span class="comment">#比较本次build出来的映像与先前版本的差异。这个对我们来说没有意义，必须设置为false，否则sanity检查会报缺少先前版本JDK的映像。如果有设置dev或者DEV_ONLY=true的话这个不显式设置也行。</span></span><br><span class="line"><span class="built_in">export</span> SKIP_COMPARE_IMAGES=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用预编译头文件，不加这个编译会更慢一些</span></span><br><span class="line"><span class="built_in">export</span> USE_PRECOMPILED_HEADER=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#要编译的内容</span></span><br><span class="line"><span class="built_in">export</span> BUILD_LANGTOOLS=<span class="literal">true</span></span><br><span class="line"><span class="comment">#export BUILD_JAXP=false</span></span><br><span class="line"><span class="comment">#export BUILD_JAXWS=false</span></span><br><span class="line"><span class="comment">#export BUILD_CORBA=false</span></span><br><span class="line"><span class="built_in">export</span> BUILD_HOTSPOT=<span class="literal">true</span></span><br><span class="line"><span class="built_in">export</span> BUILD_JDK=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#要编译的版本</span></span><br><span class="line"><span class="comment">#export SKIP_DEBUG_BUILD=false</span></span><br><span class="line"><span class="comment">#export SKIP_FASTDEBUG_BUILD=true</span></span><br><span class="line"><span class="comment">#export DEBUG_NAME=debug</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#把它设置为false可以避开javaws和浏览器Java插件之类的部分的build。</span></span><br><span class="line">BUILD_DEPLOY=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#把它设置为false就不会build出安装包。因为安装包里有些奇怪的依赖，但即便不build出它也已经能得到完整的JDK映像，所以还是别build它好了。</span></span><br><span class="line">BUILD_INSTALL=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#编译结果所存放的路径</span></span><br><span class="line"><span class="built_in">export</span> ALT_OUTPUTDIR=/home/dream/jvm/build</span><br><span class="line"></span><br><span class="line"><span class="comment">#这两个环境变量必须去掉，不然会有很诡异的事情发生（我没有具体查过这些“”诡异的事情”，Makefile脚本检查到有这2个变量就会提示警告“）</span></span><br><span class="line"><span class="built_in">unset</span> JAVA_HOME</span><br><span class="line"><span class="built_in">unset</span> CLASSPATH</span><br><span class="line"></span><br><span class="line">make 2&gt;&amp;1 | tee <span class="variable">$ALT_OUTPUTDIR</span>/build.log</span><br></pre></td></tr></table></figure>

<p>将上面的脚本存放到待编译的jdk根目录下，本人的是make.sh文件，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chmod u+x make.sh</span><br></pre></td></tr></table></figure>

<h3 id="修改一些文件"><a href="#修改一些文件" class="headerlink" title="修改一些文件"></a>修改一些文件</h3><p>由于一些小bug，会导致编译失败。我们修改一些文件。</p>
<blockquote>
<p>修改日期时间配置文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdk&#x2F;src&#x2F;share&#x2F;classes&#x2F;java&#x2F;util&#x2F;CurrencyData.properties</span><br><span class="line">535行</span><br><span class="line">TR&#x3D;TRL;2004-12-31-22-00-00;TRY</span><br><span class="line">修改为当前年份的10年内，eg:</span><br><span class="line">今年2016，那么修改为</span><br><span class="line">TR&#x3D;TRL;2015-12-31-22-00-00;TRY</span><br><span class="line">这个是根据地区码定的时间，所以最好是把此文件中所有涉及的时间日期按上面的规则修改。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改虚拟机make文件</p>
</blockquote>
<p>这个会导致编译jvm失败，报Err 2，不支持的操作系统，原因是部支持当前linux内核版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hotspot&#x2F;make&#x2F;linux&#x2F;Makefile</span><br><span class="line">234行</span><br><span class="line">SUPPORTED_OS_VERSION &#x3D; 2.4% 2.5% 2.6% 3%</span><br><span class="line">为</span><br><span class="line">SUPPORTED_OS_VERSION &#x3D; 2.4% 2.5% 2.6% 3% 4%</span><br></pre></td></tr></table></figure>

<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>在编译目标的jdk根目录下执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh make.sh</span><br></pre></td></tr></table></figure>
<p>进行编译。<br>我的4核4线程的编译结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#-- Build times ----------</span><br><span class="line">Target all_product_build</span><br><span class="line">Start 2016-06-30 10:36:48</span><br><span class="line">End   2016-06-30 10:49:06</span><br><span class="line">00:01:03 corba</span><br><span class="line">00:02:52 hotspot</span><br><span class="line">00:00:11 jaxp</span><br><span class="line">00:00:15 jaxws</span><br><span class="line">00:07:37 jdk</span><br><span class="line">00:00:20 langtools</span><br><span class="line">00:12:18 TOTAL</span><br></pre></td></tr></table></figure>
<p>最后进入编译结果存放的j2sdk-image目录，就是编译的jdk，可以作为完整的jdk使用。测试一下：<br>进入此目录的bin目录下执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dream@dream:~/jvm/build/j2sdk-image/bin$ ./java -version</span><br><span class="line">openjdk version <span class="string">&quot;1.7.0-internal&quot;</span></span><br><span class="line">OpenJDK Runtime Environment (build 1.7.0-internal-root_2016_06_30_10_36-b00)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 24.0-b56, mixed mode)</span><br></pre></td></tr></table></figure>
<p>显示root是因为我使用的是</p>
<blockquote>
<p>sudo sh make.sh</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu编译JDK7</title>
    <url>/2017/01/07/ubuntu-dns/</url>
    <content><![CDATA[<h1 id="ubutu不能正确解析域名解决办法"><a href="#ubutu不能正确解析域名解决办法" class="headerlink" title="ubutu不能正确解析域名解决办法"></a>ubutu不能正确解析域名解决办法</h1><p>最简单的办法是，系统设置，网络，找到</p>
<h2 id="方法一，修改-etc-resolv-conf"><a href="#方法一，修改-etc-resolv-conf" class="headerlink" title="方法一，修改/etc/resolv.conf"></a>方法一，修改<strong>/etc/resolv.conf</strong></h2><p>添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nameserver 223.5.5.5</span><br><span class="line">nameserver 223.6.6.6</span><br><span class="line">nameserver 180.76.76.76</span><br><span class="line">nameserver 202.101.172.35</span><br><span class="line">nameserver 61.153.177.196</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 8.8.4.4</span><br><span class="line">nameserver 222.172.200.68</span><br><span class="line">nameserver 61.166.150.123</span><br></pre></td></tr></table></figure>
<p>这个方法重启就会失效。</p>
<span id="more"></span>
<h2 id="方法二，修改-etc-resolvconf-resolv-conf-d-base"><a href="#方法二，修改-etc-resolvconf-resolv-conf-d-base" class="headerlink" title="方法二，修改/etc/resolvconf/resolv.conf.d/base"></a>方法二，修改<strong>/etc/resolvconf/resolv.conf.d/base</strong></h2><p>文件原本是空的，添加DNS服务器地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nameserver 223.5.5.5</span><br><span class="line">nameserver 223.6.6.6</span><br><span class="line">nameserver 180.76.76.76</span><br><span class="line">nameserver 202.101.172.35</span><br><span class="line">nameserver 61.153.177.196</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 8.8.4.4</span><br><span class="line">nameserver 222.172.200.68</span><br><span class="line">nameserver 61.166.150.123</span><br></pre></td></tr></table></figure>
<p>此方法我的17.04版本不起作用。但同样的另一种修改起作用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/resolvconf/resolv.conf.d/</span><br><span class="line">touch tail</span><br><span class="line">vim tail</span><br><span class="line"><span class="comment">#新加以下内容</span></span><br><span class="line">nameserver 223.5.5.5</span><br><span class="line">nameserver 223.6.6.6</span><br><span class="line">nameserver 180.76.76.76</span><br><span class="line">nameserver 202.101.172.35</span><br><span class="line">nameserver 61.153.177.196</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 8.8.4.4</span><br><span class="line">nameserver 222.172.200.68</span><br><span class="line">nameserver 61.166.150.123</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样会起作用，但是如果你用dchp的话，就有一个问题，这些dns的优先级会低于dchp获取的dns。</p>
<h2 id="方法三，修改dchp文件"><a href="#方法三，修改dchp文件" class="headerlink" title="方法三，修改dchp文件"></a>方法三，修改dchp文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/dhcp/dhclient.conf</span><br><span class="line"><span class="comment">#找到prepend domain-name-servers 127.0.0.1;这行，大概在25行位置。去掉注释符号，修改为：</span></span><br><span class="line">prepend domain-name-servers 223.5.5.5,223.6.6.6,180.76.76.76,202.101.172.35;</span><br></pre></td></tr></table></figure>
<p>这种方法保证了自定义dns在dchp之前。</p>
<h2 id="方法四，安装dnsmasq"><a href="#方法四，安装dnsmasq" class="headerlink" title="方法四，安装dnsmasq"></a>方法四，安装dnsmasq</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install dnsmasq</span><br><span class="line">sudo gedit &#x2F;etc&#x2F;dnsmasq.conf</span><br><span class="line">#修改 #resolv-file&#x3D;为resolv-file&#x3D;&#x2F;etc&#x2F;resolv.dnsmasq.conf</span><br></pre></td></tr></table></figure>
<p>如果修改过/etc/resolv.conf，先还原，然后运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/resolv.conf /etc/resolv.dnsmasq.conf</span><br></pre></td></tr></table></figure>
<p>修改网络里的dns为</p>
<blockquote>
<p>127.0.0.1</p>
</blockquote>
<p>重启dnsmasq</p>
<blockquote>
<p>sudo /etc/init.d/dnsmasq restart</p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下安装JDK</title>
    <url>/2015/05/13/ubuntu-jdk/</url>
    <content><![CDATA[<h3 id="1-下载JDK"><a href="#1-下载JDK" class="headerlink" title="1.下载JDK"></a>1.下载JDK</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;从官网<a href="http://www.sun.com" title="下载">JDK</a>下载解压放到/usr/lib/jdk/jdk8中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/profile</span><br></pre></td></tr></table></figure>
<p>末尾添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jdk/jdk8</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=/usr/lib/jdk/jdk8/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib:<span class="variable">$JRE_HOME</span>/lib:<span class="variable">$CLASSPATH</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin:<span class="variable">$JAVA_HOME</span>:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># for hadoop if exist</span></span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/usr/<span class="built_in">local</span>/hadoop</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_HOME</span>/bin</span><br></pre></td></tr></table></figure>

<p>配置系统默认jdk，300是一个优先级数值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/java java /usr/lib/jdk/jdk8/bin/java 300</span><br><span class="line">sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jdk/jdk8/bin/javac 300</span><br><span class="line">sudo update-alternatives --config java 选择安装的jdk</span><br><span class="line">sudo update-alternatives --config javac</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jdk</tag>
        <tag>linux</tag>
        <tag>ubuntu jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC整合UEditor</title>
    <url>/2015/10/05/ueditor/</url>
    <content><![CDATA[<h1 id="百度编辑器服务端整合"><a href="#百度编辑器服务端整合" class="headerlink" title="百度编辑器服务端整合"></a>百度编辑器服务端整合</h1><p>基于Spring MVC的项目中使用百度编辑器，记录备忘。</p>
<h1 id="服务端代码："><a href="#服务端代码：" class="headerlink" title="服务端代码："></a>服务端代码：</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化百度编辑器，可传入其他参数生成不同的编辑器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/ueditor/init&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initUeditor</span><span class="params">(HttpServletResponse response,HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        <span class="comment">//配置路径，首先获取webpp根目录绝对路径</span></span><br><span class="line">        String rootPath = request.getSession().getServletContext().getRealPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">		<span class="comment">//将config.json放到与ueditor.config.js同一级的目录下。将ueditor所有文件放入到wapapp-static-ueditor下</span></span><br><span class="line">		<span class="comment">//设置获取服务端配置文件地址修正路径，此路径同时作用于文件上传</span></span><br><span class="line">        rootPath=rootPath+<span class="string">&quot;static&quot;</span>;</span><br><span class="line">        PrintWriter writer=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String exec = <span class="keyword">new</span> ActionEnter(request, rootPath).exec();</span><br><span class="line">            writer = response.getWriter();</span><br><span class="line">            writer.write(exec);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;百度编辑器初始化错误！&quot;</span>,e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(writer!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h2><blockquote>
<p>百度编辑器初始化配置    </p>
</blockquote>
<h3 id="ueditor-config-js"><a href="#ueditor-config-js" class="headerlink" title="ueditor.config.js"></a>ueditor.config.js</h3><p>2个地方:<br>1.第22行，URL的设置，表示请求编辑器初始化css，js的请求地址，一般为静态资源映射目录。</p>
<blockquote>
<p>注意百度编辑器会以他的源码文件夹为根目录自行拼接请求地址，eg：<br>源码结构：<br>+utf8-jsp<br> –+third-party<br> –ueditor.config.js<br> –……<br>那么会以“URL+/third-party/…”这种形式请求</p>
</blockquote>
<p>web目录结构为：</p>
<blockquote>
<p>+webapp<br> –+static<br>    –+ueditor<br>       –ueditor.config.js<br>       –……</p>
</blockquote>
<p>那么URL一行改为：</p>
<blockquote>
<p>var URL = “/static/ueditor/“;</p>
</blockquote>
<p>2.第34行，serverUrl的设置，表示请求服务器端配置和上传资源的链接地址，百度编辑器所有的请求都只通过这个请求地址，通过action参数进行分发执行不同的功能。<br>此设置与22行的URL无关。</p>
<blockquote>
<p>我设置的服务器端请求初始化配置的的地址为“/ueditor/init”，那么将设置为“serverUrl: “/ueditor/init””。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">	<span class="comment">/*var URL = window.UEDITOR_HOME_URL || getUEBasePath();*/</span></span><br><span class="line">    <span class="keyword">var</span> URL = <span class="string">&quot;/static/ueditor/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置项主体。注意，此处所有涉及到路径的配置别遗漏URL变量。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">window</span>.UEDITOR_CONFIG = &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//为编辑器实例添加一个路径，这个不能被注释</span></span><br><span class="line">		UEDITOR_HOME_URL: URL</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务器统一请求接口路径</span></span><br><span class="line">        ,</span><br><span class="line">        <span class="comment">//serverUrl: URL + &quot;jsp/controller.jsp&quot;</span></span><br><span class="line">        serverUrl: <span class="string">&quot;/ueditor/init&quot;</span></span><br><span class="line">		...</span><br></pre></td></tr></table></figure>

<h3 id="config-json"><a href="#config-json" class="headerlink" title="config.json"></a>config.json</h3><p>imageUrlPrefix，图片访问路径前缀，由于百度编辑器默认保存图片的路径是根据webapp根目录绝对路径，然后在后面拼接上”imagePathFormat“路径的方式进行图片的保存并返回此路径对应的访问路径。<br>一般情况是我们将图片放到了静态资源所在的地方，可能不会。本例””imagePathFormat”: “/upload/image/{yyyy}{mm}{dd}/{time}{rand:6}”“，那么按配置会生成如下的图片保存地址：</p>
<blockquote>
<p>webapp绝对路径+”/upload/image/{yyyy}{mm}{dd}/{time}{rand:6}.{上传的图片的格式后缀}“</p>
</blockquote>
<p>然而我们上传的controller是要将静态资源统一放入static目录下。所以访问路径要加个前缀”static”：</p>
<blockquote>
<p>ageUrlPrefix”: “/static”, /* 图片访问路径前缀 */</p>
</blockquote>
<p>到这百度编辑器已经可以显示出来，但图片上传还是不可用。</p>
<h2 id="文件图片上传"><a href="#文件图片上传" class="headerlink" title="文件图片上传"></a>文件图片上传</h2><p>下载百度java端代码，百度默认使用commons组件，然而我们使用的是Spring MVC，spring对commons组件进行了封装，使得上传后获取不到文件。<br>代开源码目录upload包下BinaryUploader.java，对“public static final State save(HttpServletRequest request,Map&lt;String, Object&gt; conf)”方法进行改造。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> State <span class="title">save</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">			Map&lt;String, Object&gt; conf)</span> </span>&#123;</span><br><span class="line">		InputStream fileStream = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (!ServletFileUpload.isMultipartContent(request)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> BaseState(<span class="keyword">false</span>, AppInfo.NOT_MULTIPART_CONTENT);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//修改了百度使用原生的commons上传方式</span></span><br><span class="line">			DefaultMultipartHttpServletRequest multipartRequest=(DefaultMultipartHttpServletRequest)request;</span><br><span class="line">			Iterator&lt;String&gt; fileNames=multipartRequest.getFileNames();</span><br><span class="line">			MultipartFile file=<span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">while</span> (fileNames.hasNext())&#123;</span><br><span class="line">				file=multipartRequest.getFiles(fileNames.next()).get(<span class="number">0</span>);</span><br><span class="line">				fileStream=file.getInputStream();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (fileStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> BaseState(<span class="keyword">false</span>, AppInfo.NOTFOUND_UPLOAD_DATA);</span><br><span class="line">			&#125;</span><br><span class="line">			String savePath = (String) conf.get(<span class="string">&quot;savePath&quot;</span>);</span><br><span class="line">			String originFileName = file.getOriginalFilename();</span><br><span class="line">			String suffix = FileType.getSuffixByFilename(originFileName);</span><br><span class="line"></span><br><span class="line">			originFileName = originFileName.substring(<span class="number">0</span>,</span><br><span class="line">					originFileName.length() - suffix.length());</span><br><span class="line">			savePath = savePath + suffix;</span><br><span class="line">			<span class="keyword">long</span> maxSize = ((Long) conf.get(<span class="string">&quot;maxSize&quot;</span>)).longValue();</span><br><span class="line">			<span class="keyword">if</span> (!validType(suffix, (String[]) conf.get(<span class="string">&quot;allowFiles&quot;</span>))) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> BaseState(<span class="keyword">false</span>, AppInfo.NOT_ALLOW_FILE_TYPE);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			savePath = PathFormat.parse(savePath, originFileName);</span><br><span class="line"></span><br><span class="line">			String physicalPath = (String) conf.get(<span class="string">&quot;rootPath&quot;</span>) + savePath;</span><br><span class="line">			State storageState = StorageManager.saveFileByInputStream(fileStream,</span><br><span class="line">					physicalPath, maxSize);</span><br><span class="line">			fileStream.close();</span><br><span class="line">			<span class="keyword">if</span> (storageState.isSuccess()) &#123;</span><br><span class="line">				storageState.putInfo(<span class="string">&quot;url&quot;</span>, PathFormat.format(savePath));</span><br><span class="line">				storageState.putInfo(<span class="string">&quot;type&quot;</span>, suffix);</span><br><span class="line">				storageState.putInfo(<span class="string">&quot;original&quot;</span>, originFileName + suffix);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> storageState;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> BaseState(<span class="keyword">false</span>, AppInfo.PARSE_REQUEST_ERROR);</span><br><span class="line">		&#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> BaseState(<span class="keyword">false</span>, AppInfo.IO_ERROR);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>确认spring mvc配置文件配置文件上传组件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- file upload--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 5M --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;52428800&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UEditor</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>UEditor</tag>
      </tags>
  </entry>
  <entry>
    <title>Failed to build vmnet. Failed to execute the build Command</title>
    <url>/2016/12/21/vmplayer-vmnet/</url>
    <content><![CDATA[<h1 id="Kernel-4-9-无法安装VMPlayer-vmnet问题解决"><a href="#Kernel-4-9-无法安装VMPlayer-vmnet问题解决" class="headerlink" title="Kernel 4.9+无法安装VMPlayer vmnet问题解决"></a>Kernel 4.9+无法安装VMPlayer vmnet问题解决</h1><p>今天一早升级线上服务器的open ssh，然后升级了下自己的ubuntu，采用的是apt update+upgrade命令。<br>之后悲剧的发现vmplayer跪了，用度娘找了下，就只有一篇有价值的文章，说在国外论坛看到的，下载了个patch文件。<br>后来看了看，不适用，最后用手机热点翻墙（公司2M小水管，国内打开网页速度都感人），终于在<a href="http://rglinuxtech.com/?p=1838">http://rglinuxtech.com/?p=1838</a><br>看到了问题所在和解决方案，在这里重复下解决方案。其他内核版本也可以参照此方法解决。</p>
<h2 id="日志异常"><a href="#日志异常" class="headerlink" title="日志异常"></a>日志异常</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">I125: Setting destination path <span class="keyword">for</span> vmnet to <span class="string">&quot;/lib/modules/4.9.0-11-generic/misc/vmnet.ko&quot;</span>.</span><br><span class="line">I125: Extracting the vmnet <span class="built_in">source</span> from <span class="string">&quot;/usr/lib/vmware/modules/source/vmnet.tar&quot;</span>.</span><br><span class="line">I125: Successfully extracted the vmnet <span class="built_in">source</span>.</span><br><span class="line">I125: Building module with <span class="built_in">command</span> <span class="string">&quot;/usr/bin/make -j4 -C /tmp/modconfig-Zu8VZj/vmnet-only auto-build HEADER_DIR=/lib/modules/4.9.0-11-generic/build/include CC=/usr/bin/gcc IS_GCC_3=no&quot;</span></span><br><span class="line">W115: Failed to build vmnet.  Failed to execute the build <span class="built_in">command</span>.</span><br></pre></td></tr></table></figure>
<p>关键点就是<strong>4.9.0-11-generic</strong>刚升级的内核，太新了，vm无法识别。</p>
<span id="more"></span>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>首先从日志看到是内核版本的问题，导致了vmnet编译安装失败。接着按论坛上的解决方法来解决这个问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/lib/vmware/modules/<span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tar -xf vmnet.tar</span><br><span class="line">sudo tar -xf vmmon.tar</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> vmnet-only</span><br><span class="line">sudo gedit userif.c</span><br></pre></td></tr></table></figure>
<p>在<strong>113行</strong>左右找到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(4, 6, 0)</span></span><br><span class="line">    retval = get_user_pages(addr, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, &amp;page, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    retval = get_user_pages(current, current-&gt;mm, addr,</span><br><span class="line">                <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, &amp;page, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>把它替换为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(4, 9, 0)</span></span><br><span class="line">     retval = get_user_pages(addr, <span class="number">1</span>, <span class="number">0</span>, &amp;page, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(4, 6, 0)</span></span><br><span class="line">     retval = get_user_pages(addr, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, &amp;page, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">     retval = get_user_pages(current, current-&gt;mm, addr,</span><br><span class="line">                 <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, &amp;page, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>接着修改另外一个文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../vmmon-only/linux</span><br><span class="line">sudo gedit hostif.c</span><br></pre></td></tr></table></figure>
<p>在<strong>1165行</strong>左右，找到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(4, 6, 0)</span></span><br><span class="line">   retval = get_user_pages((<span class="keyword">unsigned</span> <span class="keyword">long</span>)uvAddr, numPages, <span class="number">0</span>, <span class="number">0</span>, ppages, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">   retval = get_user_pages(current, current-&gt;mm, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)uvAddr,</span><br><span class="line">                           numPages, <span class="number">0</span>, <span class="number">0</span>, ppages, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>把它替换为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(4, 9, 0)</span></span><br><span class="line">   retval = get_user_pages((<span class="keyword">unsigned</span> <span class="keyword">long</span>)uvAddr, numPages, <span class="number">0</span>, ppages, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(4, 6, 0)</span></span><br><span class="line">   retval = get_user_pages((<span class="keyword">unsigned</span> <span class="keyword">long</span>)uvAddr, numPages, <span class="number">0</span>, <span class="number">0</span>, ppages, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">   retval = get_user_pages(current, current-&gt;mm, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)uvAddr,</span><br><span class="line">                           numPages, <span class="number">0</span>, <span class="number">0</span>, ppages, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>完成2个文件的修改，基本就完成了工作。接着要将修改后的文件打包。切换目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/lib/vmware/modules/<span class="built_in">source</span></span><br></pre></td></tr></table></figure>
<p>备份原文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mv vmnet.tar vmnet.tar.back</span><br><span class="line">sudo mv vmmon.tar vmmon.tar.back</span><br></pre></td></tr></table></figure>
<p>将修改后的文件打包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tar -cf vmnet.tar vmnet-only</span><br><span class="line">sudo tar -cf vmmon.tar vmmon-only</span><br><span class="line">sudo rm -rf vmnet-only</span><br><span class="line">sudo rm -rf vmmon-only</span><br></pre></td></tr></table></figure>
<p>最后重新启动即可安装vmnet，injoy!</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper第十课</title>
    <url>/2016/05/27/zk-10/</url>
    <content><![CDATA[<h1 id="Zookeeper开源运维管理系统"><a href="#Zookeeper开源运维管理系统" class="headerlink" title="Zookeeper开源运维管理系统"></a>Zookeeper开源运维管理系统</h1><p>阿里开源zookeeper运维管理系统TaoKeeper。</p>
<h2 id="Zookeeper的健康指标"><a href="#Zookeeper的健康指标" class="headerlink" title="Zookeeper的健康指标"></a>Zookeeper的健康指标</h2><h3 id="物理资源"><a href="#物理资源" class="headerlink" title="物理资源"></a>物理资源</h3><p>CPU、内存、磁盘空间、磁盘IO。</p>
<h3 id="应用资源"><a href="#应用资源" class="headerlink" title="应用资源"></a>应用资源</h3><ul>
<li>连接数</li>
<li>注册的watcher数</li>
<li>ZNode是否可读，可写（ACL权限）</li>
<li>ZK事件通知的延时是否过大</li>
<li>zk的节点是否健康（是否离线）</li>
<li>数据状态</li>
<li>请求延时状态</li>
<li>节点的角色</li>
</ul>
<span id="more"></span>
<h2 id="Taokeeper"><a href="#Taokeeper" class="headerlink" title="Taokeeper"></a>Taokeeper</h2><p>Taokeeper是阿里的开源Zookeeper运维管理系统。</p>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ol>
<li>CPU、MEM、LOAD监控。</li>
<li>zk日志目录所在磁盘剩余空间监控。</li>
<li>单机连接数的峰值报警</li>
<li>单机watcher数峰值报警</li>
<li>节点将康状态检测</li>
<li>少量的统计报表</li>
</ol>
<h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><ol>
<li>缺少数据目录查看</li>
<li>缺少磁盘iops统计</li>
<li>缺少网络数据统计</li>
</ol>
<h3 id="安装与部署"><a href="#安装与部署" class="headerlink" title="安装与部署"></a>安装与部署</h3><p>下载<a href="“https://github.com/alibaba/taokeeper”" title="点击前往">Taokeeper源码</a>进行安装。</p>
<blockquote>
<p>注意事项<br>在配置文件中配置项指定目录下手动新建目录ZookeeperClientThroughputStat。修改类ZKServerStatusCollector中的方法storeTaoKeeperStatToDB，因为BUG，如果集群是新启动，没有统计数据，程序会报错。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a>访问地址</h4><p>ip:port/taokeeper-monitor</p>
<h4 id="主要功能简介"><a href="#主要功能简介" class="headerlink" title="主要功能简介"></a>主要功能简介</h4><blockquote>
<p>集群配置</p>
</blockquote>
<p>以逗号分开集群的机器列表。如果节点都部署在同一个机器上，可以借助域名的方式，否则不会显示所有的节点信息。</p>
<blockquote>
<p>集群监控</p>
</blockquote>
<p>zk本身不支持rwps监控。需要使用<a href="https://issues.apache.org/jira/browse/ZOOKEEPER-1804列出的patch。需要以下步骤修改：">https://issues.apache.org/jira/browse/ZOOKEEPER-1804列出的patch。需要以下步骤修改：</a></p>
<ol>
<li>修改文件：NIOServerCnxn NettyServerCnxn ServerCnxn ServerStats ZookeeperServer;具体内容问题列表中的patch附件。</li>
<li>在zkServer中增加启动属性-DServer_process_stats=true。</li>
<li>修改代码中的bug，将类ZKSserverStatusCollector中的line.contains(“getDate”)改为<strong>line.contains(“getData”)</strong>。</li>
<li>修改bug：如果每秒处理数小于1时，全部都会显示为0。修改ZKServerStatusCollector中所有计算的地方Math.round(Double.valueOf(StringUtil.trimToEmpty(line))×100)/ <strong>100</strong> 后面的 <strong>100</strong> 改为 <strong>100d</strong>。</li>
<li>节点自检是指集群中每个ip所在的zk节点上的path：/YINSHI.MONITOR.ALIVE.CHECK定期进行三次如下的流程：<strong>节点链接-数据发布-修改通知-获取数据-数据对比</strong>，三次流程均成功视为该节点处于正常状态。</li>
</ol>
<blockquote>
<p>监控报警</p>
</blockquote>
<p>默认提供了阿里旺旺和短信的报警机制，需要修改成自己的。扩展接口为：</p>
<figure class="highlight java"><figcaption><span>com.taobao.taokeeper.reporter.alarm.MessageSender</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>TaoKeeper坑比较多，并且已经不再维护。但还是实现zk监控的从无到有。</p>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zk</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper第二课</title>
    <url>/2016/04/04/zk-2/</url>
    <content><![CDATA[<h1 id="WIN下zookeeper单机集群"><a href="#WIN下zookeeper单机集群" class="headerlink" title="WIN下zookeeper单机集群"></a>WIN下zookeeper单机集群</h1><p>版本：Release 3.5.1-alpha 点击下载：<a href="http://mirror.reverse.net/pub/apache/zookeeper/zookeeper-3.5.1-alpha/zookeeper-3.5.1-alpha.tar.gz">http://mirror.reverse.net/pub/apache/zookeeper/zookeeper-3.5.1-alpha/zookeeper-3.5.1-alpha.tar.gz</a></p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>zookeeper单机集群和集群类似，只不过需要修改zk数据交换端口，选举端口和客户端链接端口</p>
<h2 id="一、配置zoo-cfg"><a href="#一、配置zoo-cfg" class="headerlink" title="一、配置zoo.cfg"></a>一、配置zoo.cfg</h2><p>将下载的文件解压，先如下配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">dataDir=d:\\tmp\\zookeeperA</span><br><span class="line">clientPort=2181</span><br></pre></td></tr></table></figure>
<p>到d盘创建相应目录，到zk的bin目录下执行zkServer.cmd，先确保单机没问题(如果报错，一般是JDK安装目录带了空格，重装JDK到没有空格的目录然后修改环境变量即可)，成功后关闭zk，并复制zk整个目录，复制2份。然后分别如下修改：</p>
<span id="more"></span>

<blockquote>
<p>1：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">dataDir=d:\\tmp\\zookeeperA</span><br><span class="line">dataLogDir=d:\\tmp\\zookeeperA\\<span class="built_in">log</span></span><br><span class="line">clientPort=2181</span><br><span class="line">server.1=localhost:2888:3888</span><br><span class="line">server.2=localhost:2889:3889</span><br><span class="line">server.3=localhost:2890:3890</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">dataDir=d:\\tmp\\zookeeperB</span><br><span class="line">dataLogDir=d:\\tmp\\zookeeperB\\<span class="built_in">log</span></span><br><span class="line">clientPort=2182</span><br><span class="line">server.1=localhost:2888:3888</span><br><span class="line">server.2=localhost:2889:3889</span><br><span class="line">server.3=localhost:2890:3890</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">dataDir=d:\\tmp\\zookeeperC</span><br><span class="line">dataLogDir=d:\\tmp\\zookeeperC\\<span class="built_in">log</span></span><br><span class="line">clientPort=2183</span><br><span class="line">server.1=localhost:2888:3888</span><br><span class="line">server.2=localhost:2889:3889</span><br><span class="line">server.3=localhost:2890:3890</span><br></pre></td></tr></table></figure>

<h2 id="二、创建myid文件"><a href="#二、创建myid文件" class="headerlink" title="二、创建myid文件"></a>二、创建myid文件</h2><p>按照配置中</p>
<blockquote>
<p>dataDir=d:\tmp\zookeeper[X]</p>
</blockquote>
<p>在相应目录中创建剩下2个zk的数据目录，然后到<strong>zookeeper[X]</strong>目录中创建不带后缀名的文件，分别</p>
<blockquote>
<p>A下的填入1，B下的填入2，C下的填入3</p>
</blockquote>
<p>然后保存。</p>
<h2 id="三、启动并验证"><a href="#三、启动并验证" class="headerlink" title="三、启动并验证"></a>三、启动并验证</h2><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>分别到3个zk的bin目录下依次(不一定按ABC的顺序)运行zkServer.cmd(如果报配置不可用，IP:端口不可到达，请注意删除配置文件中端口后的空格等不可见的特殊字符)。</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>启动其中一个zk的bin目录下的zkCli.cmd，此处为zkA的，执行：</p>
<blockquote>
<p>create /zkcluster “data”</p>
</blockquote>
<p>创建一个节点。之后可以使用命令行或者配置参数连接另外一个zk，此处为zkB的：</p>
<blockquote>
<p>get /zkcluster</p>
</blockquote>
<p>如看到</p>
<blockquote>
<p>“data”</p>
</blockquote>
<p>则说明集群成功。</p>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zk</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper第四课-watcher</title>
    <url>/2016/04/10/zk-4.1/</url>
    <content><![CDATA[<h1 id="Zookeeper的watcher"><a href="#Zookeeper的watcher" class="headerlink" title="Zookeeper的watcher"></a>Zookeeper的watcher</h1><p>在zookeeper中，有个很重要的概念就是watcher，可以看做是swing中的listener，只要你注册了watcher，那么当zk节点被操作时，你就可以通过watcher感知到。也可以理解为事件回调接口。<br>客户端通过</p>
<blockquote>
<p>public class ZooKeeper{…}</p>
</blockquote>
<p>进行远程连接和维护结构。</p>
<h2 id="zookeeper-watcher接口"><a href="#zookeeper-watcher接口" class="headerlink" title="zookeeper watcher接口"></a>zookeeper watcher接口</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[&quot;interface Watcher&quot;] --&gt;|innerClass|B[&quot;interface Event&quot;]</span><br><span class="line">B --&gt;|innerClass|D[&quot;enum KeeperState&quot;]</span><br><span class="line">B --&gt;|innerClass|C[&quot;enum EventType&quot;]</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="Watcher接口"><a href="#Watcher接口" class="headerlink" title="Watcher接口"></a>Watcher接口</h3><p>watcher只有一个方法</p>
<blockquote>
<p>abstract public void process(WatchedEvent event);</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchedEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> KeeperState keeperState;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> EventType eventType;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端watcher"><a href="#客户端watcher" class="headerlink" title="客户端watcher"></a>客户端watcher</h3><p>通过Zookeeper的构造函数注册watcher：</p>
<blockquote>
<ol>
<li>public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher)</li>
<li>ZooKeeper(String connectString, int sessionTimeout, Watcher watcher,boolean canBeReadOnly)</li>
<li>public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher,long sessionId, byte[] sessionPasswd)</li>
<li>public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher,long sessionId, byte[] sessionPasswd, boolean canBeReadOnly)</li>
</ol>
</blockquote>
<p>wather注册后，服务器端会维护watcher，一旦watcher监听的节点被操作，将会发通知给客户端，客户端接收到通知后，会调用watcher的<strong>process</strong>方法。</p>
<blockquote>
<p>zk的watcher只会起一次作用，一旦接收到通知调用后，这个watcher就失效了，如果还要监听此节点，需要重新注册watcher</p>
</blockquote>
<h3 id="服务端watcher维护"><a href="#服务端watcher维护" class="headerlink" title="服务端watcher维护"></a>服务端watcher维护</h3><p>客户端注册watcher后，服务端将会维护已经注册到自己这端的watcher。<br>服务端会根据watcher监听的节点是否是父节点，将watcher分成2类。如果此节点没有子节点，那么只会监听本节点的变更，如果有子节点，那么会同时监听子节点和本节点的变更。<br>在服务端，watcher的维护分2个维度，1个是path到watcher，一个是watcher到path。</p>
<blockquote>
<p>private final HashMap&lt;String, HashSet<Watcher>&gt; watchTable =<br>        new HashMap&lt;String, HashSet<Watcher>&gt;();</p>
</blockquote>
<blockquote>
<p>private final HashMap&lt;Watcher, HashSet<String>&gt; watch2Paths =<br>        new HashMap&lt;Watcher, HashSet<String>&gt;();</p>
</blockquote>
<h3 id="Watcher实现"><a href="#Watcher实现" class="headerlink" title="Watcher实现"></a>Watcher实现</h3><p>zk服务端节点被操作，对应不同的EventType。服务端和客户端通过不同的数值代码表示不同的事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> -<span class="number">1</span>: <span class="keyword">return</span> EventType.None;</span><br><span class="line"><span class="keyword">case</span>  <span class="number">1</span>: <span class="keyword">return</span> EventType.NodeCreated;</span><br><span class="line"><span class="keyword">case</span>  <span class="number">2</span>: <span class="keyword">return</span> EventType.NodeDeleted;</span><br><span class="line"><span class="keyword">case</span>  <span class="number">3</span>: <span class="keyword">return</span> EventType.NodeDataChanged;</span><br><span class="line"><span class="keyword">case</span>  <span class="number">4</span>: <span class="keyword">return</span> EventType.NodeChildrenChanged;</span><br></pre></td></tr></table></figure>
<p>另外zk同样通过不同的状态码表示此时客户端与服务端的状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span>   -<span class="number">1</span>: <span class="keyword">return</span> KeeperState.Unknown;</span><br><span class="line"><span class="keyword">case</span>    <span class="number">0</span>: <span class="keyword">return</span> KeeperState.Disconnected;</span><br><span class="line"><span class="keyword">case</span>    <span class="number">1</span>: <span class="keyword">return</span> KeeperState.NoSyncConnected;</span><br><span class="line"><span class="keyword">case</span>    <span class="number">3</span>: <span class="keyword">return</span> KeeperState.SyncConnected;</span><br><span class="line"><span class="keyword">case</span>    <span class="number">4</span>: <span class="keyword">return</span> KeeperState.AuthFailed;</span><br><span class="line"><span class="keyword">case</span>    <span class="number">5</span>: <span class="keyword">return</span> KeeperState.ConnectedReadOnly;</span><br><span class="line"><span class="keyword">case</span>    <span class="number">6</span>: <span class="keyword">return</span> KeeperState.SaslAuthenticated;</span><br><span class="line"><span class="keyword">case</span> -<span class="number">112</span>: <span class="keyword">return</span> KeeperState.Expired;</span><br></pre></td></tr></table></figure>
<p>当用户自定义实现watcher接口后，在监听的节点变更后，方法</p>
<blockquote>
<p>void process(WatchedEvent event)</p>
</blockquote>
<p>会被调用，用户在此方法中可以根据<strong>事件类型（EventType）</strong> 和 <strong>状态类型（KeeperState）</strong> 来判断需要进行什么样的业务逻辑。</p>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zk</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper第四课</title>
    <url>/2016/04/07/zk-4/</url>
    <content><![CDATA[<h1 id="权限控制-ACL-access-control-list"><a href="#权限控制-ACL-access-control-list" class="headerlink" title="权限控制 ACL(access control list)"></a>权限控制 ACL(access control list)</h1><p>zk的权限控制是用过固定的字符串模式来表示的。</p>
<h2 id="权限组成"><a href="#权限组成" class="headerlink" title="权限组成"></a>权限组成</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[scheme]:[id]:[permission]</span><br></pre></td></tr></table></figure>
<p>“[  ]”中是字符串变量。</p>
<blockquote>
<p>scheme：验证策略，shceme有：world，auth，digest，ip，super。<br>id：权限被赋予的对象，不同的scheme有不同的id。<br>permission：权限组合，为：c[创建]，r[读]，d[删除]，w[写]，a[权限控制]中的一个或多个组成。如：crd。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">acl权限没有继承关系，仅仅会针对当前节点。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="ACL组合"><a href="#ACL组合" class="headerlink" title="ACL组合"></a>ACL组合</h2><p>zk通过字符串组合确定访问客户端对zk节点的操作权限。</p>
<h3 id="world"><a href="#world" class="headerlink" title="world"></a>world</h3><p>与world组合的id只有一个，就是anyone，代表任何人，permission字符串随意组合。<br>eg:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#任何人拥有创建、读取和写入的权限</span><br><span class="line">world:anyone:crw</span><br></pre></td></tr></table></figure>

<h3 id="digest"><a href="#digest" class="headerlink" title="digest"></a>digest</h3><p>指定账号密码访问。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#服务器端指定acl，其中username和password为字符串</span></span><br><span class="line"><span class="comment">#注意设置的时候需要SHA1然后BASE64编码以后才能使用</span></span><br><span class="line"><span class="comment">#代表客户端为此账号和密码匹配的用户拥护所有权限</span></span><br><span class="line">digest:&#123;BASE64(SHA1(&lt;username:password&gt;))&#125;:crdwa</span><br><span class="line"><span class="comment">#客户端设置digest用户</span></span><br><span class="line">addauth digest &lt;username:password&gt;</span><br></pre></td></tr></table></figure>

<h3 id="auth"><a href="#auth" class="headerlink" title="auth"></a>auth</h3><p>auth的本质为digest，表示给认证通过的所有用户设置权限，通过<br><strong>addauth digest <username>:<password></strong>添加，通过此方式添加的用户，当节点权限被修改时，所有用户权限都被修改。新创建的用户和密码组需要重新调用setAcl才会添加。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#服务端，添加认证信息</span></span><br><span class="line">addauth digest &lt;username&gt;:&lt;password&gt;</span><br><span class="line"><span class="comment">#服务端，设置权限信息</span></span><br><span class="line">setAcl [nodePath] auth:&lt;username&gt;:&lt;password&gt;:crwd</span><br><span class="line"></span><br><span class="line"><span class="comment">#客户端，设置认证信息</span></span><br><span class="line">addauth digest &lt;username:password&gt;</span><br></pre></td></tr></table></figure>

<h3 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h3><p>指定的ip或ip地址段拥有权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#192.168.1.2拥有创建读取权限</span></span><br><span class="line">ip:192.168.1.2:cr</span><br><span class="line"><span class="comment">#192.168.1.2到192.168.1.16拥有读和写权限</span></span><br><span class="line">ip:192.168.2/16:rw</span><br></pre></td></tr></table></figure>

<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>有权限操作任何节点，用于zk管理和维护。<br>此scheme只能在服务端启动时添加虚拟机参数的形式使用。<br>在zkServer脚本中添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SUPER_ACL=“-Dzookeeper.DigestAuthenticationProvider.superDigest=super:gG7s8t3oDEtIqF6DM9LlI/R+9Ss=”</span><br></pre></td></tr></table></figure>
<p>客户端添加super用户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">addauth digest super:super</span><br></pre></td></tr></table></figure>
<p>可以看到，其实也是digest策略。</p>
<h2 id="设置或获取ACL信息"><a href="#设置或获取ACL信息" class="headerlink" title="设置或获取ACL信息"></a>设置或获取ACL信息</h2><p>设置使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setAcl [nodePath] [ACL组合]</span><br></pre></td></tr></table></figure>
<p>获取权限信息使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getAcl [nodePath]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zk</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper第三课</title>
    <url>/2016/04/07/zk-3/</url>
    <content><![CDATA[<h1 id="命令概览"><a href="#命令概览" class="headerlink" title="命令概览"></a>命令概览</h1><h2 id="ZooKeeper服务命令"><a href="#ZooKeeper服务命令" class="headerlink" title="ZooKeeper服务命令:"></a>ZooKeeper服务命令:</h2><ol>
<li>启动ZK服务:       sh bin/zkServer.sh start</li>
<li>查看ZK服务状态: sh bin/zkServer.sh status</li>
<li>停止ZK服务:       sh bin/zkServer.sh stop</li>
<li>重启ZK服务:       sh bin/zkServer.sh restart</li>
</ol>
<h2 id="zk客户端命令"><a href="#zk客户端命令" class="headerlink" title="zk客户端命令"></a>zk客户端命令</h2><p>使用zkcli.sh -server IP:PORT 连接</p>
<ol>
<li>显示根目录下、文件： ls / 使用 ls 命令来查看当前 ZooKeeper 中所包含的内容</li>
<li>显示根目录下、文件： ls2 / 查看当前节点数据并能看到更新次数等数据</li>
<li>创建文件，并设置初始内容： create /zk “test” 创建一个新的 znode节点“ zk ”以及与它关联的字符串，可选参数 【-e】创建临时节点，【-s】创建顺序节点，不以路径结尾时可以设置前缀</li>
<li>获取文件内容： get /zk 确认 znode 是否包含我们所创建的字符串</li>
<li>修改文件内容： set /zk “zkbak” 对 zk 所关联的字符串进行设置</li>
<li>删除文件： delete /zk 将刚才创建的 znode 删除</li>
<li>退出客户端： quit</li>
<li>帮助命令： help</li>
<li>获取节点权限信息：getAcl /zk<br>ZooKeeper 常用四字命令：<span id="more"></span>
<h2 id="管理命令"><a href="#管理命令" class="headerlink" title="管理命令"></a>管理命令</h2>ZooKeeper支持某些特定的四字命令字母与其的交互。它们大多是查询命令，用来获取 ZooKeeper 服务的当前状态及相关信息。用户在客户端可以通过 telnet 或 nc 向 ZooKeeper 提交相应的命令</li>
<li>可以通过命令：echo stat|nc 127.0.0.1 2181 来查看哪个节点被选择作为follower或者leader</li>
<li>使用echo ruok|nc 127.0.0.1 2181 测试是否启动了该Server，若回复imok表示已经启动。</li>
<li>echo dump| nc 127.0.0.1 2181 ,列出未经处理的会话和临时节点。</li>
<li>echo kill | nc 127.0.0.1 2181 ,关掉server</li>
<li>echo conf | nc 127.0.0.1 2181 ,输出相关服务配置的详细信息。</li>
<li>echo cons | nc 127.0.0.1 2181 ,列出所有连接到服务器的客户端的完全的连接<strong>/</strong>会话的详细信息。</li>
<li>echo envi |nc 127.0.0.1 2181 ,输出关于服务环境的详细信息（区别于 conf 命令）。</li>
<li>echo reqs | nc 127.0.0.1 2181 ,列出未经处理的请求。</li>
<li>echo wchs | nc 127.0.0.1 2181 ,列出服务器watch的详细信息。</li>
<li>echo wchc | nc 127.0.0.1 2181 ,通过session列出服务器watch的详细信息，它的输出是一个与watch相关的会话的列表。</li>
<li>echo wchp | nc 127.0.0.1 2181 ,通过路径列出服务器watch的详细信息。它输出一个与session相关的路径。</li>
</ol>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zk</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper第五课</title>
    <url>/2016/04/15/zk-5/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watcher由于通讯问题，如果是高并发，频繁写入或更新时候，并不是所有的变更通知都会通过watcher感知到，所以最好改用消息中间件来处理。</span><br></pre></td></tr></table></figure>

<h1 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h1><p>Zookeeper Atomic Broadcast即原子消息广播协议。</p>
<h2 id="ZAB协议用在哪些地方"><a href="#ZAB协议用在哪些地方" class="headerlink" title="ZAB协议用在哪些地方"></a>ZAB协议用在哪些地方</h2><p>选举过程，数据写入过程。<br><strong>zab的核心是定义了那些会改变zk服务器数据状态的事务请求的处理方式。</strong></p>
<blockquote>
<p>所有事物请求必须由一个全局唯一的服务器来协调处理，这个服务器被称为leader服务器，余下的服务器则称为follower。leader负责将一个客户端请求转换成一个事务Proposal（提议），并将该Proposal分发给集群中所有的follower。之后leader等待所有follower的反馈，一旦超过半数的follower进行了正确的反馈，那么leader就会再次向所有的follower分发commit消息，要求follower将前一个Proposal进行提交。</p>
</blockquote>
<span id="more"></span>
<h3 id="ZAB协议的三个阶段："><a href="#ZAB协议的三个阶段：" class="headerlink" title="ZAB协议的三个阶段："></a>ZAB协议的三个阶段：</h3><p>发现（discovery），即选举Leader过程。<br>同步（synchronization），即选举出Leader后，follower或者observer从leader同步最新数据。<br>广播，同步完成后，leader接收客户端的新事务请求并进行消息广播，实现数据在集群节点的副本存储</p>
<h3 id="zk的选举"><a href="#zk的选举" class="headerlink" title="zk的选举"></a>zk的选举</h3><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><blockquote>
<p>Leader</p>
</blockquote>
<p>1、事务求情的<strong>唯一</strong>调度和处理者，保证集群事务处理的顺序性。<br>2、集群内部各服务器的调度者。</p>
<blockquote>
<p>Follower(Learner)</p>
</blockquote>
<p>1、处理客户端非事务请求，<strong>转发事务请求</strong>给Leader。<br>2、参与事务请求的Proposal的投票。<br>3、参与Leader选举投票。</p>
<blockquote>
<p>Observer(Learner)</p>
</blockquote>
<p>1、处理客户端非事务请求，<strong>转发事务请求</strong>给Leader。<br>2、不参与<strong>任何形式</strong>的投票，包括选举和事务投票。<br>3、这个角色的存在是为了提高读性能。</p>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><blockquote>
<p>LOOKING</p>
</blockquote>
<p>寻找leader。处于此状态 时，表示当前没有Leader，需要进入选举流程。</p>
<blockquote>
<p>FOLLOWING</p>
</blockquote>
<p>跟随者状态，表示当前服务器角色是Follower。</p>
<blockquote>
<p>OBSERVING</p>
</blockquote>
<p>观察者状态，表示当前服务器角色是Observer。</p>
<blockquote>
<p>LEADING</p>
</blockquote>
<p>领导者状态，表示当前服务器角色是Leader。</p>
<blockquote>
<p>状态的维护是通过org.zookeeper.quorum.ServerState类进行维护的。</p>
</blockquote>
<h4 id="集群通讯"><a href="#集群通讯" class="headerlink" title="集群通讯"></a>集群通讯</h4><blockquote>
<p>通讯协议</p>
</blockquote>
<p>基于TCP协议，为了避免重复连接，采取的策略是按照集群中节点的myid数值大小来建立连接：myid大的节点向myid小的节点发起连接，如果当前节点发现发起连接的节点的myid比自己的小时，会关闭连接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3个节点，</span><br><span class="line">A[myid=1]、B[myid=2]、C[myid=3]，则C分别向A、B发起连接，B向A发起连接，总共有3个连接。</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 缺点，不能发现新节点的加入，新节点加入需要修改配置，重启整个集群节点，成本相对较高</p>
</blockquote>
<blockquote>
<p>通讯端口</p>
</blockquote>
<p>多端口通讯。在进行集群<strong>server</strong>配置时，第一个端口是通讯和数据同步端口，默认2888；第二个端口是投票端口，摩恩是3888。客户端端口使用cilentPort配置，默认是2181。</p>
<h4 id="选举算法"><a href="#选举算法" class="headerlink" title="选举算法"></a>选举算法</h4><p>各个版本支持协议不同，从3.4.0版本后只支持FastLeaderElection协议。</p>
<blockquote>
<ol>
<li>LeaderElection：支持UDP协议</li>
<li>FastLeaderElection：支持UDP，TCP协议</li>
<li>AuthFastLeaderElection：支持UDP协议</li>
</ol>
</blockquote>
<h4 id="产生选举的情景"><a href="#产生选举的情景" class="headerlink" title="产生选举的情景"></a>产生选举的情景</h4><blockquote>
<p>集群启动时</p>
</blockquote>
<p>各节点处于寻找Leader状态，表示当前没有Leader，进入选举流程。</p>
<blockquote>
<p>崩溃恢复【Leader下线】</p>
</blockquote>
<p>Leader宕机，或者因网络原因，导致<strong>过半</strong>节点与Leader心跳中断。</p>
<h4 id="影响称为Leader的因素"><a href="#影响称为Leader的因素" class="headerlink" title="影响称为Leader的因素"></a>影响称为Leader的因素</h4><blockquote>
<p>数据新旧程度</p>
</blockquote>
<p>只有拥有最新数据的节点才能有机会成为Leader。<br>通过事务id（zxid）的大小来表示数据的新旧，越大代表数据越新。</p>
<pre><code class="bash">zxid的构成：
总长度64位，高32位代表主进程周期，低32位代表事务递增计数器。
1.主进程周期
也叫epoch。代表选举的轮次，每进行一次选举，主进程周期加一。比较数据新旧的时候，先比较epoch的大小。
2.事务单调递增计数器 每次选举完成后，重置事务计数器为0。
···

&gt; myid

集群启动时，在data目录下配置文件中的myid代表节点在集群中的编号。zk节点数据一样新时，myid越大成为Leader的机会越大。当集群中已有Leader时，新加入的节点不会影响原来的集群。

&gt; 投票数量

只有得到集群中**多半**的投票，才能成为Leader。多半即指n/2+1，n为集群中节点的数量。

<span class="comment">#### 初次启动的选举</span>
情景：有3个新配置的zk节点，将用他们组成集群，对应myid分别为1,2,3。顺序启动。
选举流程：
&gt; 1. 启动myid为1的节点，此时zxid为0，只有一个节点，没法选举Leader。
&gt; 2. 启动myid为2的节点，此时zxid为0，集群已经有2个节点，zxid相同，此节点myid为最大，此节点成为Leader。
&gt; 3. 启动myid为3的节点，因为已经有主节点，3加入集群，但2仍然还是Leader。

<span class="comment">#### 运行过程中选举</span>
情景：3个节点server[1、2、3]，此时2为Leader，并且2宕机。
选举流程：
&gt; 1. 变更状态。与leader心跳断开后，其他节点状态变更为LOOKING。
&gt; 2. 每个节点发出一个投自己的投票：生成投票信息（myid，zxid）。假定：server1为(1,123)，server3为(2,122)；server1发给server3，server3发给server1。
&gt; 3. 接收投票。
&gt; 4. 投票处理：server3收到server1投票信息，因为server1的zxid比它自己的大，所以server3修改自己的投票信息为(1,123)，再次发起投票，发送给server1。server1收到server3的投票，因为123大于122，因此不再发起投票。
&gt; 5.统计投票：server3统计——自己收到的投票（包括自己投出去的）中，(1,123)2票。server1统计——自己收到的投票（包括自己投的）中，（1,123）是2票。
&gt; 6. 修改服务器状态：server3选出leader为server1，因此自己进入following状态，成为follower。server1选出的leader是server1，即自己，因此自己进入leading状态，成为新leader。


<span class="comment">#### 同步</span>
选主之后，由于各节点信息可能不一致，需要同步信息，使集群中各节点信息保持一致。
&gt; 1. 同步时机：当leader完成选举后，follower需要与新的leader同步数据。
&gt; 2. Leader同步准备：一、leader告诉其他follower当前最新数据时什么即zxid（leader构建一个newleader包，包中包含当前最大zxid，发送给所有的follower和observer）。二、leader给每个follower创建一个线程LearnerHandler来负责处理每个follower的数据同步请求，同事主线程开始阻塞，只有超过一半的follower同步完成，同步过程才完成，leader才能成为正真的leader，解除阻塞。
&gt; 3. Follower同步准备：一、选举完成后，尝试与leader建立同步连接，如果一段时间没有连接上就报错，重新回到选举状态。二、向Leader放FOLLOWERINFO封包，带上follower自己最大的zxid。
&gt; 4. Leader同步初始化：minCommittedLog——最小的事物日志id，即zxid（没有被快照存储的日志文件的第一条，每次快照存储完，会重新生成一个事务日志文件）。maxCommittedLog——事务日志中最大的事务，即zxid。
&gt; 5. leader根据follower的情况不同，采取不同的算法进行数据同步。

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">同步算法：</span><br><span class="line">1、直接差异化同步（DIFF同步）：</span><br><span class="line">2、仅回滚同步（TRUNC），即删除多余的事务日志，比如原来的主机宕机后又重新加入，可能存在它自己写入提交但是别的节点还没来得及提交的。</span><br><span class="line">3、先回滚再差异化同步（TRUNC+DIFF同步）</span><br><span class="line">4、全量同步（SNAP同步）</span><br><span class="line">算法举例：</span><br><span class="line">场景一：</span><br><span class="line">follower最后的事务zxid称作peerLastZxid</span><br><span class="line">如果minCommittedLog&lt;peerLastZxid&lt;maxCommittedLog</span><br><span class="line">同步方案：</span><br><span class="line">直接差异化同步。leader给follower发送DIFF指令，意思是：进入差异化数据同步阶段，leader会把proposal同步给follower。实际同步工程会先发数据修改proposal，然后再发送COMMIT指令数据包。</span><br></pre></td></tr></table></figure>
场景二：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">leader A完成一个实物，但还没通知其他节点，自己当机，集群选出新的leader C，</span><br><span class="line">A恢复后向C发起follower info消息，C发现A上有自己没有的事务，先让A TRUNC，然后再DIFF同步。</span><br></pre></td></tr></table></figure>
场景三：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">A为follower，当机很长时间，此时的如果leader的minCommittedLog比A的peerLastZxid还要大，则采用全量同步。</span><br></pre></td></tr></table></figure>
可以看到，同步方案有时单独使用，有时组合使用，看具体的情景。
<span class="comment">#### 广播</span>
集群数据同步完成（过半节点与leader同步完成）后，就可以对外提供服务，进入广播阶段。
&gt; 1. 当leader接收到客户端新的事务请求后，会生成对应的事务proposal，并根据zxid的顺序向所有的follower发起提案，即发起proposal。
&gt; 2. 当follower收到leader的事务proposal时，根据接收的先后顺序处理这些proposal。
&gt; 3. 当leader收到follower针对这个事务proposal过半的ack消息后，则发起事务提交proposal。
&gt; 4. follower收到leader发出的commit proposal后，记录事务提交，并把数据更新应用到内存数据库。

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">由于只是过半ack，集群即确认成功，所以可能存在某时刻某些节点上的数据不是最新的。如果业务上需要确定读取到的数据时最新的，那么需要在读取之前调用sync方法进行集群内节点的数据同步。</span><br></pre></td></tr></table></figure></code></pre>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zk</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper第六课</title>
    <url>/2016/04/18/zk-6/</url>
    <content><![CDATA[<h1 id="Zookeeper详解"><a href="#Zookeeper详解" class="headerlink" title="Zookeeper详解"></a>Zookeeper详解</h1><h2 id="客户端连接时如何选择连接节点。"><a href="#客户端连接时如何选择连接节点。" class="headerlink" title="客户端连接时如何选择连接节点。"></a>客户端连接时如何选择连接节点。</h2><blockquote>
<ol>
<li>客户端connectstring：localhost:2181,localhost:2182,localhost:2183</li>
<li>通过类client.StaticHostProvider类维护地址列表。</li>
<li>通过解析connectstring后，进行地址随机排序，形成最终的地址列表。</li>
<li>每次从形成的地址列表中选择第一个地址进行连接，如果连接不上再选择第二个地址，如果当前节点是列表最后一个节点，则重新选择第一个节点，相当于循环选择。</li>
<li>通过随机排序，每个zk客户端随机的链接zk服务器节点，分布相对均匀。</li>
</ol>
</blockquote>
<h2 id="zk会话"><a href="#zk会话" class="headerlink" title="zk会话"></a>zk会话</h2><h3 id="什么是zk会话"><a href="#什么是zk会话" class="headerlink" title="什么是zk会话"></a>什么是zk会话</h3><blockquote>
<ol>
<li>会话代表客户端与服务端的连接。</li>
<li>底层通讯通过TCP协议进行连接通讯。</li>
<li>网络出现抖动或者暂时断网时，并不意味着会话一定断开。</li>
<li>会话的对象实现是SessionImpl（此类是SessionTrackerImpl静态内部类），包括4个属性：sessionID，唯一标识一个会话，在zk服务端具备全局唯一性。Timeout：会话超时时间，创建客户端zk对象时传入，服务器会根据最小会话时间和最大会话时间来明确此值是什么（如果介于2者之间，直接使用此值，如果小于最小时间，使用最小时间，如果大于最大时间，使用最大时间89）。Ticktime：下次会话超时时间，与“分桶策略”有关。isClosing：标记一个会话是否已经被关闭，当服务器检测到有会话失效时，就会把此会话标识为已关闭（CLOSE），此状态一直存在直到会话被清除。</li>
<li>会话的状态：CONNECTING，CONNECTED，RECONNECTING，RECONNECTED，CLOSE。</li>
</ol>
</blockquote>
<span id="more"></span>
<h3 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h3><p>zk通过SessionTracker接口进行会话管理。</p>
<blockquote>
<ol>
<li>服务端通过sessionTracker进行会话创建、管理和清除。</li>
<li>此接口提供三个维度进行会话管理：通过sessionID查找session。通过sessionID查找session过期时间。通过一个时间点查询哪些会话会在此时间点过期。</li>
</ol>
</blockquote>
<blockquote>
<p>SessionTrackerImpl的维护属性</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//id获取session</span><br><span class="line">HashMap&lt;Long, SessionImpl&gt; sessionsById = new HashMap&lt;Long, SessionImpl&gt;();</span><br><span class="line">//在某个时间点要失效的会话</span><br><span class="line">HashMap&lt;Long, SessionSet&gt; sessionSets = new HashMap&lt;Long, SessionSet&gt;();</span><br><span class="line">//id查看session过期时间</span><br><span class="line">ConcurrentHashMap&lt;Long, Integer&gt; sessionsWithTimeout;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="如何检查会话是否失效"><a href="#如何检查会话是否失效" class="headerlink" title="如何检查会话是否失效"></a>如何检查会话是否失效</h4><p>zk将所有会话按照失效时间维度进行切分，放入不同的桶中，进行管理，同时冗余到另外的容器中，提供另外2个维度的查询。</p>
<blockquote>
<p>会话失效时间计算</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">约定：把所有的时间按照某个单位进行等份（默认为服务器配置的ticktime）切割，此单位称呼为ExpirationInterval</span><br><span class="line">公式：某次超时时间=（（currentTime+sessiontimeout）/ExpirationInterval+1）*ExpirationInterval</span><br><span class="line">eg:</span><br><span class="line">服务器配置ticktime为2000ms，则ExpirationInterval=2000ms，第一次创建会话时，currenttime=137090700，</span><br><span class="line">此时客户端传入的超时时间是15000ms，则计算公式为：（（137090700+15000）/2000+1）*2000=137107700</span><br></pre></td></tr></table></figure>

<blockquote>
<p>分桶</p>
</blockquote>
<p>将超时时间作为key，所有在此时间超时的会话放入一个set中，然后作为value，放入map中。当某个会话由于有操作导致超时时间变化，则将此会话从一个桶移动到另一个桶中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">会话的激活状态：</span><br><span class="line">当会话下一直有操作，则会话不会失效。</span><br><span class="line">影响会话超时的时间因素：</span><br><span class="line">1.心跳检测，ping命令（当客户端发现在sessionTimeout/3时间范围内没有任何操作命令产生，就会发送一个PING心跳请求）；</span><br><span class="line">2.正常业务操作，比如get或<span class="built_in">set</span>。</span><br><span class="line">每次业务操作或者心跳检测，都会重新计算超时时间，然后在桶间移动会话。</span><br></pre></td></tr></table></figure>

<h4 id="如何高效的检测和清除失效会话"><a href="#如何高效的检测和清除失效会话" class="headerlink" title="如何高效的检测和清除失效会话"></a>如何高效的检测和清除失效会话</h4><blockquote>
<p>检查会话失效</p>
</blockquote>
<p>由SessionTracker中一个线程周期性检查会话是否失效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">线程的检查周期也是ExpirationInterval的倍数。</span><br><span class="line">当某次检查时，如果在此次线程执行的时间点之前还有会话，就说明这些会话都过期了，因为如果会话有业务操作或者心跳，会不断的从key较小的桶中移动到key大的桶中。</span><br><span class="line">检查周期eg：</span><br><span class="line">系统启动时间为100001，ExpirationInterval为2000ms，则基数为100001/2000=50：</span><br><span class="line">第一次检查时间为（50+1）*2000=102000，第二次启动时为102000+2000即（50+2）*2000</span><br><span class="line">以后检查时间总为最小间隔的倍数（源码中为每次+ExpirationInterval）</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 会话清除</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">1.修改会话状态为close：由于清理过程需要时间，为了避免清除期间会话状态出现变更，先标记，再清除。</span><br><span class="line">2.向所有的集群节点发起会话关闭请求：只有主节点有权限进行会话检测，会话清除。</span><br><span class="line">3.收集跟被清除的会话相关的临时节点</span><br><span class="line">4.向集群节点发出删除临时节点的事务请求</span><br><span class="line">5.集群中的所有节点执行删除临时节点事务</span><br><span class="line">6.从sessionTracker的列表中移除会话</span><br><span class="line">7.关闭会话网络连接，会话连接工厂类为NIOServerCnxnFactory</span><br></pre></td></tr></table></figure>

<blockquote>
<p>会话重连</p>
</blockquote>
<p>当客户端与服务端网络连接断开后，客户端会不断的尝试重新连接，当连接上后会话的状态当前有2种情况：</p>
<blockquote>
<ol>
<li>CONNECTED-服务端会话依然存在</li>
<li>EXPIRED服务端的会话已经被清除</li>
</ol>
</blockquote>
<blockquote>
<p>网络断开并不代表会话超时</p>
</blockquote>
<p>三个会话的异常状态</p>
<blockquote>
<ol>
<li>CONNECTION_LOSS：网络闪断导致或者是客户端服务器出现问题导致。此状态下客户端会重新查找地址进行连接，直到连接上。当作某个操作的过程中出现了CONNECTION_LOSS现象，则客户端会接收到Non-Disconnected通知（设置了默认watcher情况下），同时客户端抛出ConnectionLossException异常。当重新连接上后，客户端会收到事件None-SyncConnected通知（设置了默认watcher的情况下）。</li>
<li>SESSION_EXPIRED：通常发生在CONNECTION_LOSS期间，因为没有网络连接，就不会有操作和心跳，会话就会超时。由于重新接连时间较长，导致服务器关闭了会话，并清除会话，此时会话关联的watcher等数据都会丢失。出现这种情况，客户端需要重新建立zk对象，并且恢复数据（比如注册watcher）。客户端重连时服务端会话处于此状态时会报SessionExpiredException异常。</li>
<li>SESSION_MOVE：出现CONNECTION_LOSS时，客户端尝试重新连接下一个节点，此时会话从已断开的服务器迁移到了重新连接上的服务器。</li>
</ol>
</blockquote>
<h2 id="服务器端数据与存储"><a href="#服务器端数据与存储" class="headerlink" title="服务器端数据与存储"></a>服务器端数据与存储</h2><p>zk服务端通过三个类对zk数据模型进行维护和管理。ZKDatabase负责会话，快照，日志，以及树的管理，DataTree负责维护节点树。DataNode则维护数据节点。</p>
<h3 id="ZKDatabase"><a href="#ZKDatabase" class="headerlink" title="ZKDatabase"></a>ZKDatabase</h3><p><img src="/zk/ZKDatabase.png" alt="ZKDatabase"></p>
<ul>
<li>负责管理zk的所有会话，datatree存储以及事务日志。</li>
<li>定时向磁盘写入内存数据快照。</li>
<li>当节点启动后，会通过磁盘上的事务日志和快照文件恢复完整的内存数据。</li>
</ul>
<h3 id="DataTree"><a href="#DataTree" class="headerlink" title="DataTree"></a>DataTree</h3><p><img src="/zk/DataTree.png" alt="DataTree"></p>
<ul>
<li>整个zk的数据靠DataTree维护，包括数据，目录，权限。</li>
<li>数据的领域模型，不包括对外连接的管理。</li>
</ul>
<h3 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h3><p><img src="/zk/DataNode.png" alt="DataNode"></p>
<ul>
<li>树形结构中的每个节点。</li>
<li>节点的领域模型。包括当前节点的父节点，当前节点的子节点列表。</li>
</ul>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><blockquote>
<p>日志文件</p>
</blockquote>
<p>日志文件存储于datalog或者datalogDir配置的目录下。<br>对应目录下的version-2代表的是日志的格式版本号（代表的是zk格式器的版本）。<br>日志文件的命名：每个日志文件的大小都是64M。后缀都是16进制格式数字，逐渐增大，其本质是日志文件的第一条zxid。<br>日志的格式：文件内容为2进制，zk提供工具类LogFormatter解析日志内容。在日志文本中，第一行是日志的格式信息。信息从左到右为事务操作时间、客户端会话id、cxid、zxid、操作类型、节点路径、节点数据内容、acl信息、是否临时节点（F持久T临时）、父节点的子节点版本号</p>
<blockquote>
<p>日志写入</p>
</blockquote>
<ul>
<li>zk通过FileTxnLog实现日志管理，使用append方法来添加事务日志。</li>
<li>写入过程：1.确定是否有日志文件可写，当第一次创建事务日志文件或者上一个事务日志文件写满后都会关闭这个文件流。2.确定事务日志是否需要扩容，当文件剩余空间不足4kb时，把文件新增64M（新增一个日志文件），用“0”将旧文件剩余空间填充满。3.将事务序列化。4.生成Checksum。5.写入事务日志文件流。6.事务日志刷入磁盘（调用系统fsync接口）。</li>
</ul>
<h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>快照的定义：zk在某一时刻的完整数据。</p>
<blockquote>
<p>快照文件</p>
</blockquote>
<p>存储于配置的dataDir目录下。<br>快照文件的后缀为服务器最新的zxid。<br>可以通过SnapshotFormatter查看快照文件内容。</p>
<blockquote>
<p>快照写入</p>
</blockquote>
<p>确定是否需要进行数据快照：</p>
<ul>
<li>snapCount默认为100000，表示达到这个数量的事务日志（10万条日志后）才开始进行快照。</li>
<li>为了避免集群节点同时进行快照，按照如下方式触发快照操作。</li>
</ul>
<blockquote>
<p> logCount&gt;(snapCount/2+randRoll) 【randRoll是一个1到snapCount/2之间的随机数】</p>
</blockquote>
<ul>
<li>切换事务日志文件：创建新的事务日志文件。</li>
<li>创建数据快照异步线程。</li>
<li>获取全量数据和会话信息。</li>
<li>生成快照数据文件。</li>
<li>把数据刷入快照文件。</li>
</ul>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zk</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper第七课</title>
    <url>/2016/04/28/zk-7/</url>
    <content><![CDATA[<h1 id="zk配置和管理"><a href="#zk配置和管理" class="headerlink" title="zk配置和管理"></a>zk配置和管理</h1><p>高并发分布式系统的特征：同一服务需要部署多个。整个大的业务系统由多个子业务系统构成，彼此之间需要相互调用。</p>
<h2 id="产生的问题"><a href="#产生的问题" class="headerlink" title="产生的问题"></a>产生的问题</h2><blockquote>
<ol>
<li>同一服务多台服务器，如何管理服务配置。</li>
<li>服务的消费者如何动态的发现服务提供者。</li>
<li>怎么知道部署了多少业务系统以及每个业务系统提供了多少个服务接口。</li>
</ol>
</blockquote>
<h2 id="dubbo"><a href="#dubbo" class="headerlink" title="dubbo"></a>dubbo</h2><blockquote>
<p>逻辑结构</p>
</blockquote>
<p><img src="/zk/logical.png" alt="逻辑图"></p>
<span id="more"></span>
<blockquote>
<p>节点角色说明</p>
</blockquote>
<ul>
<li>“Provider”: 暴露服务的服务提供方。</li>
<li>“Consumer”: 调用远程服务的服务消费方。</li>
<li>“Registry”: 服务注册与发现的注册中心。</li>
<li>“Monitor”: 统计服务的调用次调和调用时间的监控中心。</li>
<li>“Container”: 服务运行容器。</li>
</ul>
<blockquote>
<p>调用关系说明：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0. 服务容器负责启动，加载，运行服务提供者。</span><br><span class="line">1. 服务提供者在启动时，向注册中心注册自己提供的服务。</span><br><span class="line">2. 服务消费者在启动时，向注册中心订阅自己所需的服务。</span><br><span class="line">3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</span><br><span class="line">4. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</span><br><span class="line">5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</span><br></pre></td></tr></table></figure>
<ul>
<li>(1) 连通性：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小</span><br><span class="line">监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示</span><br><span class="line">服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销</span><br><span class="line">服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销</span><br><span class="line">注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外</span><br><span class="line">注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者</span><br><span class="line">注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表</span><br><span class="line">注册中心和监控中心都是可选的，服务消费者可以直连服务提供者</span><br></pre></td></tr></table></figure>

<ul>
<li>(2) 健状性：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">监控中心宕掉不影响使用，只是丢失部分采样数据</span><br><span class="line">数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</span><br><span class="line">注册中心对等集群，任意一台宕掉后，将自动切换到另一台</span><br><span class="line">注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</span><br><span class="line">服务提供者无状态，任意一台宕掉后，不影响使用</span><br><span class="line">服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</span><br></pre></td></tr></table></figure>

<ul>
<li><p>(3) 伸缩性：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心</span><br><span class="line">服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者</span><br></pre></td></tr></table></figure>
</li>
<li><p>(4) 升级性：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。</span><br></pre></td></tr></table></figure>
<p><img src="/zk/scale.png" alt="集群扩展示意图"></p>
</li>
</ul>
<blockquote>
<p>DUBBO核心分析：通过注册中心，实现服务动态注册、发现以及配置的管理。</p>
</blockquote>
<h2 id="基于zk设计的配置管理中心"><a href="#基于zk设计的配置管理中心" class="headerlink" title="基于zk设计的配置管理中心"></a>基于zk设计的配置管理中心</h2><p>基于zk，使用zk父节点作为服务名，临时子节点作为服务提供者信息。示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+userService[data:服务信息描述，json格式会或者其他格式，包含版本，方法列表，方法描述]</span><br><span class="line">----+192.168.1.2[data:&#123;port:8080&#125;]</span><br><span class="line">----+192.168.1.3[data:&#123;port:8080&#125;]</span><br><span class="line">----+192.168.1.4[data:&#123;port:8080&#125;]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最简单的可以不是rpc，可以使用restful，微服务概念的兴起，基于spring boot的restful兴起。可将请求的url作为服务名称写入父节点，eg:/user/reg，然后provider启动时，自动获取应用中的映射连接，向zk约定好的节点下去注册自身ip地址，端口等信息。consumer启动后，连接zk，读取约定好的节点下的所有url服务以及此时已有的提供者信息列表，并缓存、维护。</p>
</blockquote>
<p><strong>服务提供者和消费者必须达成服务列表的一致性，即有哪些服务必须明确，就如同RPC一样，调用者和被调用者必须明确接口以及接口方法和方法参数，Thrift，gRpc，ZeroC ice中使用IDL来做到</strong></p>
<h3 id="服务提供者【provider】"><a href="#服务提供者【provider】" class="headerlink" title="服务提供者【provider】"></a>服务提供者【provider】</h3><p>服务提供者连接到zk服务节点，当前结点没有则创建，然后创建临时子节点并写入自身节点信息。</p>
<h3 id="消费者【consumer】"><a href="#消费者【consumer】" class="headerlink" title="消费者【consumer】"></a>消费者【consumer】</h3><p>消费者连接到zk服务节点，读取服务列表（可以只读取自己所需要的）以及服务对应的提供者的信息，并缓存、维护服务提供者状态。可将服务提供者按服务指标进行管理，基于服务的执行，收集信息并对服务提供者进行优先级排序，优先使用可靠、高效、优先级靠前的服务提供者。</p>
<h3 id="基于spring-boot实现的简单配置管理"><a href="#基于spring-boot实现的简单配置管理" class="headerlink" title="基于spring-boot实现的简单配置管理"></a>基于spring-boot实现的简单配置管理</h3><blockquote>
<p><a href="https://github.com/DR-YangLong/micro-service">https://github.com/DR-YangLong/micro-service</a></p>
</blockquote>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zk</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper第八课</title>
    <url>/2016/05/02/zk-8/</url>
    <content><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>JVM和数据库都提供锁，但是JVM的锁只在同一虚拟机中起作用，数据库锁也只能在本数据库起作用或者通过XA与关联数据库一同协作。<br>在集群和分布式环境中，JVM的锁就无法起作用了，关于分布式数据库锁，目前还是以应用程序控制最多，另外单数据环境下，在比如秒杀这样的情景下，如果使用数据库锁，代价还是比较大。</p>
<blockquote>
<p>使用Redis的方案</p>
</blockquote>
<p>将数据库库存拷贝到Redis，秒杀时2步走，第一步用户点击按钮时查询Redis库存是否还有，如果有就进入第二步同时Redis库存减去，第二步用户填写验证信息或者确认订单，点击下单或者提交验证信息时查询真实库存，如果还有，可以下单，如果没有，提示抢光。<br>原理：视觉欺骗，用户是不知道真实的库存数量的，系统所做的只是将符合库存量的用户队列允许进入下单流程中，其他的挡在系统外。<br>基于这个原理，有很多的实现，比如nginx也可以做到，并且很高效。</p>
<blockquote>
<p>蘑菇街秒杀方案</p>
</blockquote>
<p>因为商品数量不多，库存数量不用一个字段记录，而是有多少库存量就创建多少行商品记录，这个记录中记录本记录是否被消费，然后用户抢购时是竞争数据库行锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tips：</span><br><span class="line">这个只是**七公**说的大概，竞争行锁这个还是要依赖数据库机制，所以具体要看mysql数据库引擎类型。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="基于zk的分布式锁"><a href="#基于zk的分布式锁" class="headerlink" title="基于zk的分布式锁"></a>基于zk的分布式锁</h2><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><blockquote>
<p>S锁：共享锁，如果资源被加S锁，那么它只能再加S锁，不能加其他锁。所有加锁的事务都可以读取资源，不可对资源修改。</p>
</blockquote>
<blockquote>
<p>X锁：排它锁，如果资源被加S锁，那么它<strong>不能被加其他任何锁</strong>，只有锁持有者能够对资源进行读取，修改。</p>
</blockquote>
<h3 id="基于zk的锁设计"><a href="#基于zk的锁设计" class="headerlink" title="基于zk的锁设计"></a>基于zk的锁设计</h3><blockquote>
<p>资源类型的排它锁</p>
</blockquote>
<p>秒杀，利用zk只能创建一个节点特性，所有线程创建同一个节点，创建成功者视为抢到锁，可以对资源进行操作，没有抢到锁的线程等待或者结束，抢到锁的线程操作完后，删除创建的节点，后来的线程开始抢锁，持续这一过程。</p>
<blockquote>
<p>共享锁设计</p>
</blockquote>
<p>利用zk创建顺序节点的功能，加锁的线程到同一个父节点下创建顺序节点，<strong>节点顺序号最小</strong>的节点视为当前锁持有者，可以进行后续操作，操作完成后删除自己创建的节点。<br>因为有2类锁，根据锁的特性，所以有以下情况：</p>
<ul>
<li>我创建了节点，并且我要加S/X锁，我创建的节点序号是最小的，那么我可以进行我后面的业务逻辑处理了。</li>
<li>我创建了节点，我要加S锁，我创建的节点序号不是当前最小的，并且在我前面的节点全是S锁节点，此时我也可以进行后续业务逻辑处理。</li>
<li>我创建了节点，我要加S锁，我创建的节点序号不是当前最小的，并且在我前面的节点有X锁节点，此时我不能进行后续业务逻辑处理，只能等待我前面距我最近的X锁节点删除，才能进行后续业务逻辑处理。</li>
<li>我创建了节点，我要加X锁，我创建的节点序号不是当前最小的，此时无论前面有何种锁，我都不能进行后续业务逻辑处理，只能等待我前面所有的锁节点删除，才能进行后续业务逻辑处理。</li>
</ul>
<p>具体的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">规定锁对应的节点格式：</span><br><span class="line">S锁：S[线程名称&#x2F;服务器名称]-zk自动生成序号</span><br><span class="line">X锁：X[线程名称&#x2F;服务器名称]-zk自动生成序号</span><br><span class="line"></span><br><span class="line">线程创建节点，利用watcher，监听父节点，在节点变化时获取通知，在通知中获取所有的子节点，判断自己所属的节点序号是不是最小，如果是，进行业务处理，如果不是，根据自身锁类型和小于自己序号的节点的锁类型，判断是继续等待还是执行业务处理。</span><br></pre></td></tr></table></figure>

<h3 id="基本实现例子"><a href="#基本实现例子" class="headerlink" title="基本实现例子"></a>基本实现例子</h3><blockquote>
<p><a href="https://github.com/DR-YangLong/zookeeper">https://github.com/DR-YangLong/zookeeper</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">1.在创建后先判断自己的节点是否为第一个节点。然后再加watcher。</span><br><span class="line">2.加watcher的优化，不必在父节点上加watcher，只需要在需要等待释放锁的节点上加，S锁只需要加载距离自己最近的X锁节点上加，X锁只需要在自己前一个节点上加。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zk</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper第九课</title>
    <url>/2016/05/10/zk-9/</url>
    <content><![CDATA[<h1 id="Zookeeper运维管理"><a href="#Zookeeper运维管理" class="headerlink" title="Zookeeper运维管理"></a>Zookeeper运维管理</h1><h2 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h2><p>zk的日志使用log4j日志组件。<br>默认日志输出目录：</p>
<blockquote>
<ol>
<li>winwos为安装目录下，zookeeper.log</li>
<li>linux为安装目录下bin/zookeeper.out</li>
</ol>
</blockquote>
<p>zk默认不开启日志文件输出。<br>日志相关属性配置在<strong>conf/log4j.properties</strong>中配置。日志文件输出位置必须在环境设置脚本<strong>zkEnv</strong>中进行设置：set ZOO_LOG_DIR=/usr/log。或者通过JVM启动参数指定：-Dzookeeper.log.dir=/usr/log</p>
<h2 id="zk其他属性配置"><a href="#zk其他属性配置" class="headerlink" title="zk其他属性配置"></a>zk其他属性配置</h2><p>配置方式：</p>
<ol>
<li>通过java的JVM系统参数指定（在zkServer脚本中配置，3.4.8版本在140行：nohup “$JAVA” <strong>“-Dzookeeper.log.dir=${ZOO_LOG_DIR}”</strong> JVM参数可以加在这个地方）：-Djava.library.path</li>
<li>通过zk的配置文件zoo,conf配置。</li>
</ol>
<span id="more"></span>
<blockquote>
<p>配置说明：</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数名</th>
<th align="center">作用</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td>dataLogDir</td>
<td align="center">配置事务日志文件存储目录</td>
<td align="right">1. 不支持JVM系统属性配置。2. 默认值为dataDir的值。3. 高并发下，将会产生大量的事务日志和快照，如果log的目录和data的目录是同一磁盘，将会有IO瓶颈，因此最好配置到不同磁盘上，提高IO性能。</td>
</tr>
<tr>
<td>snapCount</td>
<td align="center">两次快照间隔的事务日志条数</td>
<td align="right">1.  事务日志条数达到这个数目时，就要触发数据快照。2.  默认值为100000。3.  仅支持系统属性配置方式。</td>
</tr>
<tr>
<td>preAllocSize</td>
<td align="center">事务日志文件预分配的磁盘空间大小</td>
<td align="right">1. 仅支持系统属性配置，zookeeper.preAllocSize。2. 默认值65535,即64M。3.  此参数与snapCount有关，snapCount越大，就需要分配越大的值。</td>
</tr>
<tr>
<td>minSessionTimout、maxSessionTimeout</td>
<td align="center">服务器端会话失效的时间边界控制</td>
<td align="right">1. 不支持系统属性配置。2. 默认为ticktime的2到20倍。3. 当客户端传递过来的超时间不在这2个参数之间时，最小取min最大取max。</td>
</tr>
<tr>
<td>maxClientCnxns</td>
<td align="center">从socket层限制客户端与单台服务器的并发连接数</td>
<td align="right">1. 不支持系统属性配置，默认值60,0表示不限制。2. 以IP地址为粒度控制。3. 只能控制单台机器，不能控制总连接。</td>
</tr>
<tr>
<td>Jute.maxbuffer</td>
<td align="center">配置单个节点最大的数据大小</td>
<td align="right">1. 仅支持系统属性方式配置，默认10M，单位字节。2. zk上存储的数据不宜过多，主要是考虑到多节点写入性能。3. 需要在服务器端和客户端都配置才生效。</td>
</tr>
<tr>
<td>Autopurge.snapRetainCount</td>
<td align="center">自动清理快照和事务日志时需要保留的文件数</td>
<td align="right">1. 不支持系统属性配置，默认值为3,可以不用配置。2. 最小值。 3. 避免磁盘损坏后不能回复数据。</td>
</tr>
<tr>
<td>Autopurge.purgeInterval</td>
<td align="center">自动清理快照和事务的周期</td>
<td align="right">1.不支持系统属性配置，默认值0,表示不开启自动清理。2.与Autopurge.snapRetainCount属性一起配合使用。3.配置为负数也表示不清理。</td>
</tr>
<tr>
<td>fysnc.waringthresholdms</td>
<td align="center">事务日志刷性到磁盘的报警阀值</td>
<td align="right">1.支持系统属性，默认值为1000ms。2.如果fsync的操作超过此时间就会在日志中打印报警日志。</td>
</tr>
<tr>
<td>forceSync</td>
<td align="center">日志提交时是否强制刷磁盘</td>
<td align="right">1.默认为true。仅支持系统属性配置：zookeeper.forceSync.3.如果设置为no,可以提升写入性能，但是会有数据丢失风险。</td>
</tr>
<tr>
<td>cnxTimeout</td>
<td align="center">选举过程中，服务器之间创建tcp连接的超时时间</td>
<td align="right">1.默认值为5000ms，仅支持系统属性配置：zookeeper.cnxTimeout。</td>
</tr>
</tbody></table>
<h2 id="四字命令"><a href="#四字命令" class="headerlink" title="四字命令"></a>四字命令</h2><blockquote>
<p>定义</p>
</blockquote>
<p>长度为4个英文字母的管理命令。</p>
<blockquote>
<p>使用方式</p>
</blockquote>
<ol>
<li>telnet:telnet ip port 然后执行[需要执行的命令]</li>
<li>nc:echo [需要执行命令]|nc ip port</li>
</ol>
<p>linux下大多使用nc来进行维护和监控。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc是一个简单、可靠的网络工具，可通过TCP或UDP协议传输读写数据。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>conf</p>
</blockquote>
<p>此命令用于输出基本的配置信息，也可以查看一些运行时参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> conf |nc localhost 2181;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>cons</p>
</blockquote>
<p>此命令用于输出当前客户端所有连接的详细信息，包括客户端ip，会话id等。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> cons |nc localhost 2181</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>crst</p>
</blockquote>
<p>此命令用于重置客户端的连接统计信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> crst |nc localhost 2181</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>dump</p>
</blockquote>
<ul>
<li>此命令用于输出当前集群的所有的会话信息，包括会话id以及临时节点等信息。</li>
<li>如果当前节点是leader节点，则还会输出会话的超时时间。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> dump |nc localhost 2181</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<blockquote>
<p>envi</p>
</blockquote>
<p>此命令用于输出运行时环境信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> envi |nc localhost 2181</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>ruok</p>
</blockquote>
<p>此命令用于输出当前zk服务器运行是否正常，注意仅仅代表2181端口和此命令的执行是否正常，并不能完全代表zk运行正常，如需要确定，使用stat命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> ruok |nc localhost 2181</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>stat</p>
</blockquote>
<p>此命令用于获取服务端的运行状态：zk的版本、打包信息、运行时角色、集群的数据节点等。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="built_in">stat</span> |nc localhost 2181</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>srvr</p>
</blockquote>
<p>此命令与stat功能类似，但不输出连接信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> srvr |nc localhost 2181</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>srst</p>
</blockquote>
<p>此命令用于重置服务器统计信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> srst |nc localhost 2181</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>wchs</p>
</blockquote>
<p>此命令用于输出当前服务器上管理的watcher的概要信息，通过zk构造器创建的默认watcher不在此统计范围。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> wchs |nc localhost 2181</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>wchc</p>
</blockquote>
<p>此命令用于输出当前服务器上管理的watcher的详细信息，以会话为组，通过zk构造创建的默认watcher不在此统计范围。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> wchc |nc localhost 2181</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>wchp</p>
</blockquote>
<p>此命令与wchc类似，但是以节点路径分组，默认的watcher不在统计范围内。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> wchp |nc localhost 2181</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>mntr</p>
</blockquote>
<p>此命令与stat类似，但是比stat更详细，包括请求的延时情况，服务器内存数据库大小，集群同步情况等信息都会显示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> mntr |nc localhost 2181</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul>
<li>zk基于java开发实现，数据全量储存在内存中，因此，调整JVM内存是优化点之一，具体需要根据业务情况来定。也就是JVM调优。</li>
<li>IO优化：将事务日志与快照存储的路径设在不同的磁盘上，提供IOPS，最后将事务日志设在单独挂载磁盘上，可以考虑SSD。</li>
<li>加大linux系统的文件句柄数和用户线程数，通过ulimit可以查看当前配置。</li>
<li>业务并发高时，可以创建多于1个的客户端会话；可以不同的业务模块采用不同的客户端实例。</li>
<li>利用zk进行业务并发时，尽量通过良好的设计减少资源消耗，比如控制好watcher的数量。</li>
<li>节点数量，在写少，读多的应用场景中，采用多一点的节点会提升整体的读并发性能。</li>
<li>节点数据量最好比默认的10M还小。</li>
<li>带宽尽量高，可以通过网络监控查看带宽是否是瓶颈。</li>
</ul>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><blockquote>
<p>停机</p>
</blockquote>
<p>增加相应的节点即可。</p>
<blockquote>
<p>不停机</p>
</blockquote>
<ul>
<li>增加新的节点，id一定要比原来集群的大。</li>
<li>新增节点启动后会加入集群并同步数据。</li>
<li>当用mntr命令查看新的节点数据已经同步成功后做下面的操作。</li>
<li>按照之前的id的顺序依次关闭zk实例，然后修改配置，启动实例。</li>
</ul>
<h2 id="容灾"><a href="#容灾" class="headerlink" title="容灾"></a>容灾</h2><blockquote>
<p>单机房容灾</p>
</blockquote>
<p>单机房的容灾zk本身的集群机制就能很好的支持。</p>
<blockquote>
<p>多机房容灾</p>
</blockquote>
<p>由于过半投票机制，zk不支持双机房的容灾，比如是5节点，分为2和3,当3这个机房出现故障，2就不能选举成功。因此，多机房容灾主要是考虑三机房情况。跨机房的网络延迟较大，做这个容灾要避免大量写的应用场景。</p>
<blockquote>
<p>客户端设置</p>
</blockquote>
<p>为了避免服务器地址变化影响客户端，客户端尽量采用域名的方式。</p>
<h2 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a>监控指标</h2><blockquote>
<p>zookeeper事务日志</p>
</blockquote>
<ul>
<li>磁盘IO。</li>
<li>可以开启事务日志自动清理：autopurge.snapRetainCount，autopurge.purgeInterval=24</li>
</ul>
<blockquote>
<p>连接数<br>注册的watcher数量<br>zk事件通知的延时大小</p>
</blockquote>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zk</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2017/06/05/algorithm/bin-search/</url>
    <content><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>在看Map源码的时候看到了红黑树，去了解了之后发现水太深了，去捡起大学时候的数据结构与算法恶补，顺便做下笔记。学无止境啊。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>二分查找依赖于一个有序列表，当查找一个元素A时，先用此元素和有序列表中点的元素B比较大小：<br>如果A&lt;B则说明需要查找的元素A位于B元素的左侧子序列中。<br>如果A&gt;B则说明需要查找的元素A位于B元素的右侧子序列中。<br>然后根据情况，分别再用A和上面确定的子序列的中点元素比较，再次得到A的位于的子序列，重复直至找到A。<br>可以看到，因为每次查找都会剔除剩余序列的一半元素，因而性能为log(n)。</p>
<span id="more"></span>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>参照了维基百科的代码，搬运过来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binary_search_recursion</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> khey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//递归基</span></span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>; <span class="comment">//直接平均可能会溢出，所以用此算法，与线段中点坐标公式【（start+end）/2】结果相同</span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; khey)</span><br><span class="line">            <span class="keyword">return</span> binary_search_recursion(arr, start, mid - <span class="number">1</span>, khey);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; khey)</span><br><span class="line">            <span class="keyword">return</span> binary_search_recursion(arr, mid + <span class="number">1</span>, end, khey);</span><br><span class="line">        <span class="keyword">return</span> mid; <span class="comment">//不大不小，=</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环实现</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binary_search_loop</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> khey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            mid = start + (end - start)/<span class="number">2</span>; <span class="comment">//直接平均可能溢出，所以用此算法</span></span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &lt; khey)</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; khey)</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> mid=binary_search_recursion(a,<span class="number">0</span>,a.length-<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> mid1=binary_search_loop(a,<span class="number">0</span>,a.length-<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(mid);</span><br><span class="line">        System.out.println(mid1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2017/04/17/algorithm/binary-tree/</url>
    <content><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树是一种层次结构。</p>
<h2 id="树的特性："><a href="#树的特性：" class="headerlink" title="树的特性："></a>树的特性：</h2><ol>
<li>树结构中，每个节点的深度都是一个非负整数。</li>
<li>深度为1的节点有且仅有一个，称作树的根（Root）。</li>
<li>对于深度为K(k&gt;1)的节点，都有且仅有一个深度为K-1的节点与之对应，称为此节点的父节点。</li>
<li>若节点B的父节点是A，则B称为A节点的孩子。具有共同父亲的节点之间称为兄弟节点。</li>
<li>树总是从父亲节点指向孩子节点，形成一条树边。</li>
<li>树中节点数目总=树边总数+1。</li>
<li>所有节点中具有最大深度的节点的深度称为树的深度或高度。树的深度，从根节点（深度为1）向下累加，某节点的深度就是根节点累加到此节点（包含）的数值；树的高度，从叶子节点向上累加，父节点的高度就是其深度最深的叶子节点（高度为1）向上累加到它的数值。</li>
<li>任一节点的孩子总数，称为此节点的度（Degree）。</li>
<li>树的节点总数=树的节点度数之和*2+1。</li>
<li>拥有孩子的节点称为内部节点（internal node），没有孩子的节点称为外部节点（external node）或叶子节点（leaf）。</li>
<li>由树中 k+1 节点通过树边首尾衔接而构成的序列{ (v 0 , v 1 ), (v 1 , v 2 ), …, (v k-1 , v k ) | k ≥ 0}，称作树中长度为 k 的一条路径（Path）。</li>
<li>树中任何2个节点间都存在唯一的一条路径。</li>
<li>从树根通往任一节点的路径长度，恰好等于该节点的深度-1，即深度=路径长度+1。</li>
<li>树T中每一节点V的所有后代也构成一棵树，称作T的以V为根的子树（Subtree）。</li>
<li>在树T中，若在每个节点的所有孩子之间都可以定义某一线性次序，则称T为一棵有序树（Ordered tree）。</li>
<li>每个内部节点均为m度的有序树，称作m叉树。</li>
</ol>
<span id="more"></span>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ol>
<li>每个节点都不超过2度的有序树，称作二叉树（binary tree）。</li>
<li>不含1度节点的二叉树，称作真二叉树（proper binary tree），否则称为非真二叉树（improper binary tree）。</li>
<li>二叉树中。深度为K的节点不超过2的k-1次方个。</li>
<li>高度为k的二叉树做多包含2的k次方-1个节点。</li>
<li>由n个节点构成的二叉树，高度至少为log2n（2为底数n的对数）。</li>
<li>二叉树中，叶子节点总是比2度节点多一个。</li>
</ol>
<h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>若二叉树T中所有叶子节点的深度完全相同，称为满二叉树（full binary tree）。<br>包含root节点，高度和深度相同都等于层数，设k为层数：</p>
<ol>
<li>第k层的叶子（孩子）数是2的k次方：2^k</li>
<li>第k层的节点数是2的k-1次方：2^(k-1)</li>
<li>总结点数是2的k次方减1：2^k - 1</li>
</ol>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>一棵满二叉树中，从最右侧起将相邻的若干叶子节点摘除，得到的二叉树称为完全二叉树（complete binary tree）。</p>
<ol>
<li><p>拥有n个节点的完全二叉树，其叶子节点数是n除以2并向上取整（有小数直接进1），或n+1除以2并向下取整（忽略小数）。</p>
</li>
<li><p>n个节点构成的完全二叉树，高度h=log[2]n(2为底数的对数)。</p>
</li>
<li><p>由n个节点构成的二叉树中，完全二叉树的高度最低。</p>
</li>
</ol>
<h4 id="完全二叉树的数组存储结构"><a href="#完全二叉树的数组存储结构" class="headerlink" title="完全二叉树的数组存储结构"></a>完全二叉树的数组存储结构</h4><p>将节点v的位置记为i(v)，则根节点编号i(root) = 0，i(lchild(root)) = 1，i(rchild(root)) = 2，i(lchild(lchild(root)) = 3 ，…。<br>则：</p>
<ol>
<li>若节点v有左孩子，则i(lchild(v))=2*i(v)+1;</li>
<li>若节点v有右孩子，则i(rchild(v))=2*i(v)+2;</li>
<li>若节点v有父亲，则i(parent(v))=⎣(i(v) - 1)/2⎦ = ⎡(i(v)/2⎤ - 1(取下限和取上限)。</li>
</ol>
<h3 id="二分查找树"><a href="#二分查找树" class="headerlink" title="二分查找树"></a>二分查找树</h3><p>二叉查找树(Binary Search Tree)，又被称为二叉搜索树。设x为二叉查找树中的一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] &lt;= key[x]；如果y是x的右子树的一个结点，则key[y] &gt;= key[x]。</p>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p>在二分查找树T中，若所有节点的平衡因子的绝对值均不超过1，则称T为一棵AVL树。完全二叉树必然是AVL树。由n个节点构成的AVL树的高度为log<a href="n">2</a>。<br>高度为h的AVL树，至少包含Fib(h+2)-1个节点。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>求斐波那契数列第N个数</title>
    <url>/2018/03/11/algorithm/fibonacci/</url>
    <content><![CDATA[<h1 id="求斐波那契数列第N个数"><a href="#求斐波那契数列第N个数" class="headerlink" title="求斐波那契数列第N个数"></a>求斐波那契数列第N个数</h1><p>斐波那契数列的数学公式：</p>
<ul>
<li>F(0)=0</li>
<li>F(1)=1</li>
<li>F(n)=F(n-1)+F(n-2)  {n&gt;=2}</li>
</ul>
<p>后一个数等于它前两个数的和。</p>
<p>前13个为:</p>
<blockquote>
<p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * functional describe:1,1,2,3,5,8...f(n) = f(n-1)+ f(n-2)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DR.YangLong [410357434@163.com]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0    2017/6/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 递归实现方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 第n位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 第n位的数值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递推实现方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 第n位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 第n位的数值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibonacciLoop</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">1</span>, n2 = <span class="number">1</span>, sn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            sn = n1 + n2;</span><br><span class="line">            n1 = n2;</span><br><span class="line">            n2 = sn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、1、2、3、5、8、13、21、34、55、89、144、233</span></span><br><span class="line">        System.out.println(fibonacci(<span class="number">5</span>));</span><br><span class="line">        System.out.println(fibonacciLoop(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>基于链表的map结构实现</title>
    <url>/2018/03/11/algorithm/listbasedmap/</url>
    <content><![CDATA[<h1 id="基于链表的map结构实现"><a href="#基于链表的map结构实现" class="headerlink" title="基于链表的map结构实现"></a>基于链表的map结构实现</h1><h2 id="定义map接口以及key比较器接口"><a href="#定义map接口以及key比较器接口" class="headerlink" title="定义map接口以及key比较器接口"></a>定义map接口以及key比较器接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取map中元素数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map是否为null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取key映射的元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向map中放入映射</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">put</span><span class="params">(K key, V val)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">remove</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取映射集合,使用集合迭代map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Collection&lt;Entry&lt;K,V&gt;&gt; entries();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取关键码</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取entry值</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 更新entry值</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">V <span class="title">setValue</span><span class="params">(V val)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">KeyComparator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(K key1,K key2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  Objects.equals(key1,key2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="key比较器及map实现类"><a href="#key比较器及map实现类" class="headerlink" title="key比较器及map实现类"></a>key比较器及map实现类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用接口的默认实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalKeyComparator</span>&lt;<span class="title">K</span>&gt; <span class="keyword">implements</span> <span class="title">KeyComparator</span>&lt;<span class="title">K</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListBaseMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Entry&lt;K, V&gt;&gt; table;</span><br><span class="line">    <span class="keyword">private</span> KeyComparator&lt;K&gt; keyComparator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListBaseMap</span><span class="params">(LinkedList&lt;Entry&lt;K, V&gt;&gt; table, KeyComparator&lt;K&gt; keyComparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.table = table;</span><br><span class="line">        <span class="keyword">this</span>.keyComparator = keyComparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListBaseMap</span><span class="params">(KeyComparator&lt;K&gt; keyComparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.table = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.keyComparator = keyComparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListBaseMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.table = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.keyComparator = <span class="keyword">new</span> NormalKeyComparator&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> K key;</span><br><span class="line">        <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V val)</span> </span>&#123;</span><br><span class="line">            V old = <span class="keyword">this</span>.value;</span><br><span class="line">            <span class="keyword">this</span>.value = val;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">this</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Entry) &#123;</span><br><span class="line">                Entry&lt;?, ?&gt; e = (Entry&lt;?, ?&gt;) obj;</span><br><span class="line">                <span class="keyword">return</span> Objects.equals(e.getKey(), <span class="keyword">this</span>.getKey())</span><br><span class="line">                        &amp;&amp; Objects.equals(e.getValue(), <span class="keyword">this</span>.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ke=[&quot;</span>+key+<span class="string">&quot;],value=[&quot;</span>+value+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> table.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> table.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;K, V&gt; entry : table) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, entry.getKey())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> entry.getValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V val)</span> </span>&#123;</span><br><span class="line">        Node&lt;K, V&gt; node = <span class="keyword">new</span> Node&lt;&gt;(key, val);</span><br><span class="line">        <span class="keyword">if</span> (size() == <span class="number">0</span>) &#123;</span><br><span class="line">            table.add(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;K, V&gt; entry : table) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, entry.getKey())) &#123;</span><br><span class="line">                    V old = entry.getValue();</span><br><span class="line">                    entry.setValue(val);</span><br><span class="line">                    <span class="keyword">return</span> old;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            table.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;K, V&gt; entry : table) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, entry.getKey())) &#123;</span><br><span class="line">                    V oldVal = entry.getValue();</span><br><span class="line">                    table.remove(count);</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;Entry&lt;K, V&gt;&gt; entries() &#123;</span><br><span class="line">        <span class="keyword">return</span> table;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>合并排序</title>
    <url>/2018/03/11/algorithm/mergesort/</url>
    <content><![CDATA[<h1 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h1><p>将数列不停的拆分，直到只剩下一个元素，此时必然有序，然后将拆分的部分两两合并，最后成为一个有序数列。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * functional describe:基于队列结构的归并排序算法（队列可换成数组，一般示例为数组）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DR.YangLong [410357434@163.com]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0    2017/8/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Comparator&lt;T&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拆分，将s不断的拆分，直至拆分成一个元素的queue，则此时是有序的，然后合并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(LinkedList&lt;T&gt; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = s.size();</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> &gt;= size) <span class="keyword">return</span>;<span class="comment">//递归基</span></span><br><span class="line">        LinkedList&lt;T&gt; s1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;T&gt; s2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty()) &#123;<span class="comment">//将s拆分到s1和s2</span></span><br><span class="line">            s1.addLast(s.removeFirst());</span><br><span class="line">            <span class="keyword">if</span> (!s.isEmpty()) s2.addLast(s.removeFirst());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归拆分</span></span><br><span class="line">        sort(s1);</span><br><span class="line">        sort(s2);</span><br><span class="line">        <span class="comment">//合并单个元素的queue</span></span><br><span class="line">        merge(s, s1, s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并，将2个有序queue合并成一个有序queue，使用2个待合并的queue长度为条件进行循环。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(LinkedList&lt;T&gt; container, LinkedList&lt;T&gt; s1, LinkedList&lt;T&gt; s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!s1.isEmpty() || !s2.isEmpty()) &#123;<span class="comment">//只要其中一个不为空</span></span><br><span class="line">            T e;<span class="comment">//s1和s2中取出的较小元素</span></span><br><span class="line">            <span class="keyword">if</span> (s1.isEmpty()) &#123;<span class="comment">//s1已经取光，从s2中取</span></span><br><span class="line">                e = s2.removeFirst();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s2.isEmpty()) &#123;<span class="comment">//s2已经取光，从s1中取</span></span><br><span class="line">                e = s1.removeFirst();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(s1.getFirst(), s2.getFirst()) &gt; <span class="number">0</span>) &#123;<span class="comment">//如果s1中第一个大于s2中第一个，则e取s2中第一个</span></span><br><span class="line">                e = s2.removeFirst();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//s1中第一个小于s2中第一个，e取s1第一个</span></span><br><span class="line">                e = s1.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将e放入目标容器队尾</span></span><br><span class="line">            container.addLast(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MergeSort</span><span class="params">(Comparator&lt;T&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MergeSort&lt;Integer&gt; sort = <span class="keyword">new</span> MergeSort&lt;&gt;((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (o1 &lt; o2) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (o1 &gt; o2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        LinkedList&lt;Integer&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">0</span>);</span><br><span class="line">        list.add(<span class="number">8</span>);</span><br><span class="line">        list.add(<span class="number">6</span>);</span><br><span class="line">        list.add(<span class="number">9</span>);</span><br><span class="line">        list.add(<span class="number">7</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        sort.sort(list);</span><br><span class="line">        list.forEach(out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2018/03/11/algorithm/quicksort/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * functional describe:快速排序算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DR.YangLong [410357434@163.com]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0    2017/5/16 14:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找中轴线</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">midIndex</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = i, r = j;<span class="comment">//获取排序的区间</span></span><br><span class="line">        <span class="keyword">int</span> x = a[i];<span class="comment">//第一个数作为基数</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; a[r] &gt;= x) r--;<span class="comment">//从后向前找到第一个比基准数小的数</span></span><br><span class="line">            <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">                a[l] = a[r];<span class="comment">//将小的数填到基准数左边</span></span><br><span class="line">                l++;<span class="comment">//向后移动一个位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; a[l] &lt;= x) l++;<span class="comment">//从前向后找到比基准数大的数</span></span><br><span class="line">            <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">                a[r] = a[l];</span><br><span class="line">                r--;<span class="comment">//向前移动一个位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[l] = x;<span class="comment">//循环退出时i=j位中间位置</span></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> midIndex = midIndex(a, l, r);</span><br><span class="line">            sort(a, l, midIndex - <span class="number">1</span>);</span><br><span class="line">            sort(a, midIndex + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并版本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 待排序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 排序数组起始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 排序数组结束位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">final</span> <span class="keyword">int</span> left, <span class="keyword">final</span> <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != a &amp;&amp; a.length &gt; <span class="number">0</span> &amp;&amp; left &gt;= <span class="number">0</span> &amp;&amp; right &gt; left &amp;&amp; right &lt; a.length) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = left, j = right;</span><br><span class="line">            <span class="keyword">int</span> x = a[left];<span class="comment">//中间数，空出i的位置</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt;= x) j--;<span class="comment">//从后向前找，直到找到第一个比基数小的数，停止</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                    a[i++] = a[j];<span class="comment">//填到i的位置，并且下轮填到i的下一个位置，此时j的位置空出</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= x) i++;<span class="comment">//从前向后找，直到找到第一个比基数大的数，停止</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                    a[j--] = a[i];<span class="comment">//将大的数放到j的位置，并且下轮填到j的前一个位置，此时i的位置空出</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[i] = x;<span class="comment">//循环结束，找到中间位置i，将中间数填入</span></span><br><span class="line">            quickSort(a, left, i-<span class="number">1</span>);<span class="comment">//对左边部分排序</span></span><br><span class="line">            quickSort(a, i+<span class="number">1</span>, right);<span class="comment">//对右边部分排序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        Arrays.stream(a).forEach(out::print);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n==================&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> []b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        quickSort(b,<span class="number">0</span>,b.length-<span class="number">1</span>);</span><br><span class="line">        Arrays.stream(b).forEach(out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>基于数组的stack结构实现</title>
    <url>/2018/03/11/algorithm/stack/</url>
    <content><![CDATA[<h1 id="基于数组的stack结构实现"><a href="#基于数组的stack结构实现" class="headerlink" title="基于数组的stack结构实现"></a>基于数组的stack结构实现</h1><h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//栈大小</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="function">Object <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//查看栈顶端元素，不删除</span></span><br><span class="line">    <span class="function">Object <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="异常定义"><a href="#异常定义" class="headerlink" title="异常定义"></a>异常定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackEmptyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackEmptyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOverFlowException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackOverFlowException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> <span class="keyword">implements</span> <span class="title">Stack</span></span>&#123;</span><br><span class="line">    <span class="comment">//默认数组长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY=<span class="number">1024</span>;</span><br><span class="line">    <span class="comment">//栈顶位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top_position=-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//栈数组</span></span><br><span class="line">    <span class="keyword">private</span> Object[] stack;</span><br><span class="line">    <span class="comment">//实际数组长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        stack=<span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top_position+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(getSize()&lt;capacity)&#123;</span><br><span class="line">            stack[++top_position]=o;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StackOverFlowException(<span class="string">&quot;栈溢出&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isEmpty())&#123;</span><br><span class="line">            Object element=stack[top_position];</span><br><span class="line">            stack[top_position--]=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> element;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> StackEmptyException(<span class="string">&quot;空栈&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top_position&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> stack[top_position];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> StackEmptyException(<span class="string">&quot;空栈&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Android学习第一课</title>
    <url>/2016/04/03/android/android-1/</url>
    <content><![CDATA[<h1 id="第一课笔记"><a href="#第一课笔记" class="headerlink" title="第一课笔记"></a>第一课笔记</h1><h2 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h2><h3 id="一、XML（可扩展性标记语言）"><a href="#一、XML（可扩展性标记语言）" class="headerlink" title="一、XML（可扩展性标记语言）"></a>一、XML（可扩展性标记语言）</h3><h4 id="element（元素）"><a href="#element（元素）" class="headerlink" title="element（元素）"></a>element（元素）</h4><blockquote>
<p>xml的元素指开始标签知道结束标签的部分</p>
</blockquote>
<p>如</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span>this is a book<span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面<strong><book></strong>到<strong></book></strong>就是一个元素，称为book。</p>
<blockquote>
<p>元素之间的部分就是元素的值，比如上面的”this is a book”，有时候元素还拥有子元素，大部分的时候，xml由大量的元素，子元素组成一个树形结构</p>
</blockquote>
<h4 id="attribute（属性）"><a href="#attribute（属性）" class="headerlink" title="attribute（属性）"></a>attribute（属性）</h4><blockquote>
<p>xml的属性指每个元素可以携带的额外信息</p>
</blockquote>
<p>如</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">bokName</span>=<span class="string">&quot;精通JAVA&quot;</span>  <span class="attr">bookPrice</span>=<span class="string">&quot;25.00&quot;</span>&gt;</span></span><br><span class="line">    this is a book</span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面book元素开始标签内的<strong>bokName</strong>和<strong>bookPrice</strong>就是属性，表示book的一些附加信息，当然这些信息也可以在<strong>子元素</strong>中描述。</p>
<span id="more"></span>

<h4 id="value（值）"><a href="#value（值）" class="headerlink" title="value（值）"></a>value（值）</h4><p>值由2部分组成，一部分为element的值，也就是element开始和结束直接的部分，另一部分为每个属性<strong>=</strong>后面的部分。</p>
<h4 id="xml的树形结构"><a href="#xml的树形结构" class="headerlink" title="xml的树形结构"></a>xml的树形结构</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookcase</span> <span class="attr">bookNum</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bookName</span> <span class="attr">type</span>=<span class="string">&quot;战争&quot;</span>&gt;</span>三国演义<span class="tag">&lt;/<span class="name">bookName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bookPrice</span> &gt;</span>12.0<span class="tag">&lt;/<span class="name">bookPrice</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bookName</span> <span class="attr">type</span>=<span class="string">&quot;奇幻&quot;</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">bookName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bookPrice</span>&gt;</span>25.0<span class="tag">&lt;/<span class="name">bookPrice</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookcase</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面描述了一个书柜，书柜里有2本书，一本是<strong>战争类型的</strong>叫<strong>三国演义</strong>，价格是<strong>12.0</strong>，另外一本是<strong>奇幻</strong>类型的，叫<strong>西游记</strong>，书价是<strong>25.0</strong></p>
<blockquote>
<p>xml的作用其实就是用来进行跨环境的信息传递</p>
</blockquote>
<h4 id="schema（命名空间）与dtd（文档类型定义【Document-Type-Definition】）"><a href="#schema（命名空间）与dtd（文档类型定义【Document-Type-Definition】）" class="headerlink" title="schema（命名空间）与dtd（文档类型定义【Document Type Definition】）"></a>schema（命名空间）与dtd（文档类型定义【Document Type Definition】）</h4><p>xml中的元素名称，属性都是开发者自己定义的，如果对于不同事物的信息2个开发者都使用了相同的元素名称，这时候就没法准确的确定xml到底描述的是哪一个事物，这时候就需要使用命名空间。<br>表格</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>表格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>桌子</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>桌子<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的2个xml，由于根元素都是<strong>table</strong>，在一起使用时就会造成混淆，接收者不知道这是桌子还是表格（由于接收人处理信息的前提是必须知道这个信息描述的是上面东西）。所以需要使用schema来告诉接收者他接收到的信息描述的是什么。</p>
<blockquote>
<p>当然使用前缀也是可以区别的，如<br>&lt;t:table&gt;<br>&lt;t:tr&gt;<br>&lt;t:td&gt;表格</t:td><br></t:tr><br></t:table><br>但是无论如何，总不可避免的会有重复出现的时候。</p>
</blockquote>
<p>引入namespace：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">t:table</span> <span class="attr">xmlns:t</span>=<span class="string">&quot;http://www.simple.com/biaoge&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">t:tr</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">t:td</span>&gt;</span>表格<span class="tag">&lt;/<span class="name">t:td</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">t:tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">t:table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">f:table</span> <span class="attr">xmlns:f</span>=<span class="string">&quot;http://www.simple.com/zhuozi&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">f:name</span>&gt;</span>桌子<span class="tag">&lt;/<span class="name">f:name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">f:table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，namespace被放在元素开始标签中，并遵循以下格式</p>
<blockquote>
<p> xmlns:namespace-prefix=”namespaceURI”</p>
</blockquote>
<p>这样，使得一个xml从根本上与另外一个xml区别开来。上面2个例子使用的是<strong>显式</strong>命名的方式，即将前缀指向一个<em>统一资源标示符（URI）</em>也就是一个网址，然后在每个标签中添加前缀。另外一种方式是使用默认命名方式（基本使用这种方式）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.simple.com/biaoge&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>表格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.simple.com/zhuozi&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>桌子<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于xml只是描述性的语言，对于有的值，是必须有约束性的，比如价格，只能是数字，所以就有了DTD文档</p>
</blockquote>
<p>DTD文档会定义xml中有哪些元素，这些元素名字是什么【这就是为什么一定要你将元素名写正确的原因】，有哪些属性，属性名称是什么，属性值是什么类型，元素的值是否是必须的等等。总而言之，DTD就是给xml定义一个规范，一个约束，用来检查xml是否合法。<br>xml使用DTD有2中方式，内部定义和外部引入，一般使用外部引入。</p>
<blockquote>
<p>内部定义：在xml中编写</p>
</blockquote>
<blockquote>
<p>外部引入： <!DOCTYPE 根元素 SYSTEM "文件名"></p>
</blockquote>
<h2 id="XML参考"><a href="#XML参考" class="headerlink" title="XML参考"></a>XML参考</h2><p><a href=""http://www.w3school.com.cn/x.asp"" title="点击前往">XML知识</a><br><a href=""http://www.w3school.com.cn/dtd/"" title="点击前往">DTD知识</a></p>
<h2 id="Android界面布局"><a href="#Android界面布局" class="headerlink" title="Android界面布局"></a>Android界面布局</h2><p>主要用来定义视图界面，包括布局方式，控件大小，颜色等。</p>
<h3 id="界面（UI）的组成：布局容器与视图组件。"><a href="#界面（UI）的组成：布局容器与视图组件。" class="headerlink" title="界面（UI）的组成：布局容器与视图组件。"></a>界面（UI）的组成：布局容器与视图组件。</h3><h4 id="五种布局："><a href="#五种布局：" class="headerlink" title="五种布局："></a>五种布局：</h4><p>共有五种布局方式，分别是：FrameLayout（框架布局），LinearLayout （线性布局），AbsoluteLayout（绝对布局），RelativeLayout（相对布局），TableLayout（表格布局）。</p>
<blockquote>
<p>像素相关概念：</p>
</blockquote>
<blockquote>
<ol>
<li>Px（Pixel像素）：不同设备显示效果相同。这里的“相同”是指像素数不会变，比如指定UI长度是100px，那不管分辨率是多少UI长度都是100px。也正是因为如此才造成了UI在小分辨率设备上被放大而失真，在大分辨率上被缩小。 </li>
<li>Dip（Device-independent pixel，设备独立像素）：同dp，可作长度单位，不同设备有不同的显示效果,这个和设备硬件有关，一般我们为了支持WVGA、HVGA和QVGA 推荐使用这个，不依赖像素。dip和具体像素值的对应公式是dip值 =设备密度/160* pixel值，可以看出在dpi（像素密度）为160dpi的设备上1px=1dip。</li>
<li>Resolution（分辨率）：指手机屏幕垂直和水平方向上的像素个数。比如分辨率是480*320，则指设备垂直方向有480个像素点，水平方向有320个像素点。</li>
<li>Dpi（像素密度）：指每英寸中的像素数。如160dpi指手机水平或垂直方向上每英寸距离有160个像素点。假定设备分辨率为320*240，屏幕长2英寸宽1.5英寸，dpi=320/2=240/1.5=160。</li>
<li>Density（密度）：指每平方英寸中的像素数。Density=Resolution/Screen size|</li>
<li>Sp（放大像素）：主要用于字体显示（best for textsize）。根据 google 的建议，TextView 的字号最好使用 sp 做单位，而且TextView默认使用 sp 作为字号单位。SP是基于系统字体设置的。</li>
</ol>
</blockquote>
<p>由于不同设备的尺寸和分辨率都不相同，所以最好不要使用像素来布局，以免造成在像素密度比较高的设备上造成视图组件过小。使用DP能够获得较为统一的体验。</p>
<p>转换关系：</p>
<blockquote>
<p>dp与px转换的方法：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dip2px</span><span class="params">(Context context, <span class="keyword">float</span> dipValue)</span></span>&#123; 　　</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> scale = context.getResources().getDisplayMetrics().density; </span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)(dipValue * scale +<span class="number">0.5f</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">px2dip</span><span class="params">(Context context, <span class="keyword">float</span> pxValue)</span></span>&#123; 　　</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> scale = context.getResource().getDisplayMetrics().density; 　　</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)(pxValue / scale +<span class="number">0.5f</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第一课view组件："><a href="#第一课view组件：" class="headerlink" title="第一课view组件："></a>第一课view组件：</h4><p>TextView:文本框</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:text=&quot;Hello World!&quot; /&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>属性： wrap_content ——自适应内容DP；textSize ——字号，不同设备相同值得字号显示体验一致；textAppearance ——Large，small同样定义字体大小sp无关。textColor ——设置字体颜色。background ——设置view的背景色。</p>
</blockquote>
<p>ImageView:图片</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;ImageView</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot; /&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>属性：src ——资源文件引入，使用@drawable会查找位于资源目录下drawable目录中文件，不必使用后缀；scaleType ——图片缩放类型center：居中，centerCrop:剪切居中。</p>
</blockquote>
<p>Button:按钮</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:text=&quot;Button&quot;/&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议：按钮最少48dp。</p>
</blockquote>
<h2 id="组件和组件属性可以查询API获得"><a href="#组件和组件属性可以查询API获得" class="headerlink" title="组件和组件属性可以查询API获得"></a>组件和组件属性可以查询API获得</h2><p><a href=""http://developer.android.com/intl/zh-cn/guide/index.html"" title="翻墙查看">Android UserGuide</a></p>
<h1 id="第一课总结"><a href="#第一课总结" class="headerlink" title="第一课总结"></a>第一课总结</h1><p>和学习JAVA WEB开发时一样的学习方式：API优先。结合实例。任何代码跑一把总能看到效果。写下代码，运行看到效果，总是令人激动的。希望和大家一起进步吧。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>StudyJams</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android布局初识</title>
    <url>/2016/04/07/android/android-2/</url>
    <content><![CDATA[<h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><h2 id="View的关系"><a href="#View的关系" class="headerlink" title="View的关系"></a>View的关系</h2><p>一个界面只能有一个根view，ViewGroup是也是一种view，通常用来作为多个view的容器， 进行界面布局，它是矩形的 。view和view间的关系，父子，兄弟关系，就像XML的结构一样。同样的可以多级的嵌套。</p>
<blockquote>
<p>ViewGroup继承于View，实现了ViewParent和ViewManager接口，可作为容器view的view继承了ViewGroup，而普通的view则直接继承View并且没有实现那2个接口，因此所有view【类没有定义为final】都可以通过继承后实现ViewParent和ViewManager接口变为容器view，很多自定的view其实都是用过继承，实现多个接口来做出想要的功能的。     </p>
</blockquote>
<h2 id="布局方式【待补充】"><a href="#布局方式【待补充】" class="headerlink" title="布局方式【待补充】"></a>布局方式【待补充】</h2><p>主要的布局方式有：<br>LinearLayout,RelativeLayout,Grid View,List View,Recycler View。</p>
<h3 id="子view的大小设置方式："><a href="#子view的大小设置方式：" class="headerlink" title="子view的大小设置方式："></a>子view的大小设置方式：</h3><blockquote>
<ol>
<li>固定宽高：设置一个固定值，超出部分会被截去。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>设置为wrap-content，会自适应view的内容大小。</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>设置为match-parent，会和父view一样的尺寸。</li>
</ol>
</blockquote>
<pre><code>**宽高可以分别设置**</code></pre><h3 id="权重layout-weight"><a href="#权重layout-weight" class="headerlink" title="权重layout-weight"></a>权重layout-weight</h3><p>view有布局权重，权重越大，所能分配到的父view的剩余空间越大，权重相等，会平分剩余的空间。可以用来作为布局中视图的均匀分布【垂直或水平】。</p>
<span id="more"></span>

<h3 id="LinearLayout"><a href="#LinearLayout" class="headerlink" title="LinearLayout"></a>LinearLayout</h3><p>子view在父view中线性排列：垂直或水平。使用属性orientation指定。horizontal——水平。vertical——垂直。</p>
<h3 id="RelativeLayout"><a href="#RelativeLayout" class="headerlink" title="RelativeLayout"></a>RelativeLayout</h3><p>让子view相对于父view的位置进行排列，或是子view相对于其他子view的位置进行排列。</p>
<h4 id="子view相对父view属性："><a href="#子view相对父view属性：" class="headerlink" title="子view相对父view属性："></a>子view相对父view属性：</h4><blockquote>
<ol>
<li>layout_alignParentTop 是否与父view上对齐</li>
<li>layout_alignParentBottom 是否与父view下对齐</li>
<li>layout_alignParentLeft 是否与父view左对齐</li>
<li>layout_alignParentRight 是否与父view右对齐</li>
</ol>
</blockquote>
<pre><code>**默认值为false**</code></pre><p>可以混合使用以上各个属性，如果不指定属性，默认添加到父View左上角。</p>
<h4 id="子view相对于子view位置："><a href="#子view相对于子view位置：" class="headerlink" title="子view相对于子view位置："></a>子view相对于子view位置：</h4><p>使用相对位置需要用到view的id，使用id=”@+id/{idName}”指定view的id。<br>使用以下属性定义</p>
<blockquote>
<ol>
<li>android:layout_above=”@id/textView”  ——在上面</li>
<li>android:layout_alignLeft=”@id/textView”  ——在左边</li>
<li>android:layout_alignBottom=”@id/textView” ——在下边</li>
<li>android:layout_alignRight=”@id/textView” ——在右边</li>
<li>android:layout_alignEnd=”@id/textView” ——右【结束的地方】边缘一致 start是左边缘【开始的地方】一致</li>
</ol>
</blockquote>
<h3 id="内边距和外边距【同CSS】"><a href="#内边距和外边距【同CSS】" class="headerlink" title="内边距和外边距【同CSS】"></a>内边距和外边距【同CSS】</h3><h4 id="padding内边距"><a href="#padding内边距" class="headerlink" title="padding内边距"></a>padding内边距</h4><p>内边距指view中内容到view边缘的距离。</p>
<h4 id="margin外边距"><a href="#margin外边距" class="headerlink" title="margin外边距"></a>margin外边距</h4><p>指view边缘到view边缘之间的距离。注意不论是父view还是子view都适用。</p>
<h3 id="List-View"><a href="#List-View" class="headerlink" title="List View"></a>List View</h3><p>List View显示一列可以滚动项目的视图组，即常见的列表。</p>
<h3 id="Grid-View"><a href="#Grid-View" class="headerlink" title="Grid View"></a>Grid View</h3><p>网格视图，类似table，可以滚动显示。</p>
<h3 id="TabLayout"><a href="#TabLayout" class="headerlink" title="TabLayout"></a>TabLayout</h3><p>选项卡布局</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>StudyJams</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Activity组件</title>
    <url>/2016/04/07/android/android-3/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 常用View</title>
    <url>/2016/04/07/android/android-4/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 事件</title>
    <url>/2016/04/07/android/android-5/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android基于事件处理的组件间通讯</title>
    <url>/2016/04/07/android/android-6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android像素计算</title>
    <url>/2016/04/07/android/android-design/</url>
    <content><![CDATA[<p>dp与px换算，sp同：<br>px=dp<em>(dpi/160)<br>dp=px/(dpi/160)=px</em>160/dpi<br>dpi=(对角线长度像素值)/手机显示屏尺寸<br>对角线长度像素值=(分辨率宽的平方+分辨率高的平方)开平方</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Eureka简介</title>
    <url>/2017/09/20/eureka/1-Eureka_at_a_glance/</url>
    <content><![CDATA[<h1 id="Eureka简介"><a href="#Eureka简介" class="headerlink" title="Eureka简介"></a>Eureka简介</h1><h2 id="Eureka是什么？"><a href="#Eureka是什么？" class="headerlink" title="Eureka是什么？"></a>Eureka是什么？</h2><p>Eureka是一个基于REST（Representational State Transfer：表述性状态转移）的服务，主要用于对部署在AWS云环境中的服务进行定位、负载均衡和故障转移的中间层服务。我们称这个服务为Eureke Server。Eureka同时提供JAVA客户端组件，Eureka Client，使与eureka服务交互变得更容易。客户端同样内置了基于循环策略（round-robin）的负载均衡。在Netflix，一个更为复杂的负载均衡器封装了Eureka，以提供基于流量，资源使用，错误条件等因子为加权的负载均衡，以提供优越的弹性。</p>
<h2 id="为什么需要Eureka？"><a href="#为什么需要Eureka？" class="headerlink" title="为什么需要Eureka？"></a>为什么需要Eureka？</h2><p>在AWS中，由于固有的性质，服务器间交互的负载均衡并不像传统的物理服务器之间那样通过已知的IP地址和主机名，在AWS中，负载均衡需要更为复杂的服务注册和服务发现。由于AWS并没有提供中间层负载均衡，Eureka填补可这一巨大空白。</p>
<h2 id="Eureka和AWS-ELB之间有什么区别？"><a href="#Eureka和AWS-ELB之间有什么区别？" class="headerlink" title="Eureka和AWS ELB之间有什么区别？"></a>Eureka和AWS ELB之间有什么区别？</h2><p>AWS ELB是为终端用户网络流量提供的边缘服务负载均衡解决方案（ELB像通常使用nginx一样，在用户和server之间进行负载均衡）。Eureka填补了中间层负载平衡的需要。理论上，您可以将您的中间层服务放在AWS ELB后面，但在EC2 classic中，您将它们暴露给外部世界，并失去AWS安全组的所有安全控制。        </p>
<p>AWS ELB也是一种传统的基于代理的负载均衡解决方案，与之不同的是，Eureka是对实例/服务器/主机级别间进行负载均衡。客户端实例能够感知需要与哪些服务器进行交互的所有信息。这样的好坏取决于你看待它的方式。如果你正在寻找一个基于粘性用户会话的负载均衡，AWS已经提供了，Eureka并没有提供一个解决方案。在Netflix，我们偏向于使用无状态服务。这样有利于可扩展模型并且更加契合Eureka。        </p>
<p>另一个eureka和传统的基于代理的负载均衡的区别是，应用在负载均衡服务中断后继续对外提供服务，这是因为可用服务器的相关信息已经缓存在了客户端上。这些缓存只需要占用客户端很小的内存，却能带来非常好的弹性（可用性）。     </p>
<span id="more"></span>
<h2 id="Eureka和Route-53有什么区别？"><a href="#Eureka和Route-53有什么区别？" class="headerlink" title="Eureka和Route 53有什么区别？"></a>Eureka和Route 53有什么区别？</h2><p>Route 53是一个命名服务，Eureka也能够为中间服务提供相同的服务，两者的相同点仅限于此。Route 53是一个DNS服务：即使在非AWS中也能够提供DNS记录解析服务。Route 53还可以通过AWS分区进行基于延迟的路由。Eureka类似于一个内部DNS服务器，但与其他外界的DNS服务器没有任何关系。Eureka在某种意义上也是被隔离的，因为它并不知道其他AWS分区的Eureka。它保持信息的主要目的是在本分区内进行负载均衡。       </p>
<p>虽然你可以将你的中间层服务注册到Route 53并依赖AWS的安全组来保护你的应用不受公网访问，但你的中间层服务实际上还是暴漏在了公网上。并且这样做会带来传统的基于DNS负载均衡解决方案的缺点，在这些方案中，即时某些服务已经不健康，甚至已经不存在的情况下（AWS中，服务器可以随时消失），流量仍然会路由到这些服务上去。     </p>
<h2 id="Netflix怎样使用Eureka？"><a href="#Netflix怎样使用Eureka？" class="headerlink" title="Netflix怎样使用Eureka？"></a>Netflix怎样使用Eureka？</h2><p>在Netflix，Eureka除了作为中间层服务负载均衡外，还用于以下目的：      </p>
<ul>
<li>和Netflix Asgard（一个使在云环境中部署变得更容易的开源服务组件）一起用于红/黑部署。Eureka与Asgard协作，在出现问题的情况下可以快速、无缝的切换部署的新/旧版本的服务-特别是考虑到发布100个实例来部署一个版本可能需要很长时间。</li>
<li>对于已部署的cassandra来说，将实例从流量中取出来进行维护。</li>
<li>对于memcached服务来说，标识集群节点列表。</li>
<li>用于携带特定服务的其他额外元数据。</li>
</ul>
<h2 id="何时使用Eureka？"><a href="#何时使用Eureka？" class="headerlink" title="何时使用Eureka？"></a>何时使用Eureka？</h2><p>你有许多中间层服务运行在AWS，并且你不希望将他们注册到AWS ELB或将他们暴露在公网。你可能正在寻找一个简单的循环负载均衡解决方案，或者你愿意根据你的需求对Eureka进行封装。你不需要使用外部缓存（如memcached）对用户会话信息进行保存和加载以保持状态。更重要的是，如果你的架构适合于基于客户端的负载均衡模型，那么Eureka是契合的。      </p>
<h2 id="服务的服务端和客户端是如何通讯的？"><a href="#服务的服务端和客户端是如何通讯的？" class="headerlink" title="服务的服务端和客户端是如何通讯的？"></a>服务的服务端和客户端是如何通讯的？</h2><p>通讯技术可以是你喜欢的任何东西。Eureka帮助你找到你想要进行通讯的服务端信息，但不会对客户端和服务端之间的通讯协议或通讯方式进行任何限制。例如，你可以使用Eureka获取目标服务器地址，并使用诸如thrift，http（s）或任何其他RPC机制协议。</p>
<h2 id="高层架构"><a href="#高层架构" class="headerlink" title="高层架构"></a>高层架构</h2><p><img src="./eureka_architecture.png" alt="高层架构图"></p>
<p>上面的架构描述了Eureka是如何部署在Netflix上的，这也是你通常运行它的方式。每个区域只有一个eureka集群，它只知道该区域的实例。每个区域至少有一个eureka服务器来处理区域故障。<br>服务注册到Eureka，然后每30秒发送心跳更新他们的租约。如果客户不能更新租约几次，它将在90秒内从服务器注册中心剔除。注册信息和更新被复制到集群中的所有eureka节点。来自任何区域的客户端可以查找注册中心信息(每30秒发生一次)来定位它们所需的服务(可能在任何区域)并进行远程调用。</p>
<h2 id="非JAVA的服务端和客户端"><a href="#非JAVA的服务端和客户端" class="headerlink" title="非JAVA的服务端和客户端"></a>非JAVA的服务端和客户端</h2><p>对于非Java的服务，您可以选择自行实现eureka的客户端部分，或者您可以运行“side car”，它本质上是一个Java应用程序，其内置的eureka客户端可以处理注册和心跳。REST端点也暴露了所有Eureka Client进行的操作（本质是基于非JAVA语言通过HTTP实现心跳和注册处理等）。非java客户端可以使用REST来查询其他服务的信息。      </p>
<h2 id="可配置性"><a href="#可配置性" class="headerlink" title="可配置性"></a>可配置性</h2><p>使用Eureka，你能够在集群运行时将某个几点从集群中移除。你能够调整内部配置，从超时到线程池。Eureka使用archaius并且如果你拥有配置源实现，很多配置都可以动态调整。</p>
<h2 id="弹性"><a href="#弹性" class="headerlink" title="弹性"></a>弹性</h2><p>在AWS云里，我们很难不去思考我们构建的所有东西的弹性。Eureka得益于我们获得的经验，客户端和服务器都有弹性。</p>
<p>Eureka客户端能够处理一个或多个Eureka服务器的故障。由于Eureka客户端有注册表缓存信息，因此即使所有的Eureka服务器都被关闭，它们也可以运行得相当好。</p>
<p>Eureka服务器对其他Eureka服务器宕机具有有弹性。即使在客户端和服务器之间的网络分区中，服务器也具有内置的弹性，以防止大规模停机。</p>
<h2 id="多分区"><a href="#多分区" class="headerlink" title="多分区"></a>多分区</h2><p>在多个AWS区域部署Eureka是一项相当简单的任务。区域之间的Eureka集群之间并不会相互通信。</p>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>Eureka使用servo跟踪客户端和服务端上的大量信息，用于性能、监控和警报。这些数据通常注册到JMX，并可以导出到Amazon Cloud Watch。</p>
]]></content>
      <categories>
        <category>eureka</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Eureka配置</title>
    <url>/2017/09/22/eureka/2-Configuring_Eureka/</url>
    <content><![CDATA[<h1 id="配置Eureka"><a href="#配置Eureka" class="headerlink" title="配置Eureka"></a>配置Eureka</h1><p>阅读简介以更好的理解设置的概念。        </p>
<p>Eureka共有2个组件-Eureka Client和Eureka Server。在使用Eureka时，你的架构中通常有2个应用：</p>
<ul>
<li><strong>Application Client</strong>通过Eureka Client请求应用服务端。</li>
<li><strong>Application Server</strong>接受客户端的请求并发送响应。</li>
</ul>
<p>设置涉及以下内容：</p>
<ul>
<li>Eureka Server</li>
<li>Application Client中的Eureka Client</li>
<li>Application Server中的Eureka Client</li>
</ul>
<p><em>Eureka在AWS环境中和非AWS环境中都能运行。</em></p>
<blockquote>
<p>如果在云环境中运行，则需要传入java commandline属性-Deureka.datacenter=cloud，以便Eureka客户端/服务器知道如何初始化AWS云的特定信息。</p>
</blockquote>
<span id="more"></span>
<h2 id="配置Eureka-Client"><a href="#配置Eureka-Client" class="headerlink" title="配置Eureka Client"></a>配置Eureka Client</h2><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><ul>
<li><p>JDK 1.8或更高<br>你能够通过以下方式获得Eureka Client程序。请优先选择最高的release版本，因为它有更多的修复。</p>
</li>
<li><p>你能够通过<a href="http://search.maven.org/#search%7Cga%7C1%7Ceureka-client">http://search.maven.org/#search%7Cga%7C1%7Ceureka-client</a>下载。</p>
</li>
<li><p>可以通过在依赖文件中添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.eureka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以参照<a href="https://github.com/Netflix/eureka/wiki/Building-Eureka-Client-and-Server">https://github.com/Netflix/eureka/wiki/Building-Eureka-Client-and-Server</a>进行手动构建。</p>
</li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置Eureka Client最简单的方式是使用配置文件。默认情况下，Eureka Client会在<em>classpath</em> 路径下搜索 * eureka-client.properties* 配置文件。进一步的，它会搜索特定环境下的特定配置文件，并覆盖相关配置。环境通常为 <em>test</em> 或者 <em>prod</em> ，这是通过java commandline <em>-Deureka.environment*传给eureka client的（值并没有 *.properties</em> 后缀）。因此，客户端还会搜索 <em>eureka-client-{test,prod}.properties</em> 文件。     </p>
<p>你可以在<a href="https://github.com/Netflix/eureka/blob/master/eureka-examples/conf/sample-eureka-client.properties">https://github.com/Netflix/eureka/blob/master/eureka-examples/conf/sample-eureka-client.properties</a>查看默认配置。如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">###Eureka Client configuration for Sample Eureka Client</span><br><span class="line"></span><br><span class="line"># see the README in eureka-examples to see an overview of the example set up</span><br><span class="line"></span><br><span class="line"># note that for a purely client usage (e.g. only used to get information about other services,</span><br><span class="line"># there is no need for registration. This property applies to the singleton DiscoveryClient so</span><br><span class="line"># if you run a server that is both a service provider and also a service consumer,</span><br><span class="line"># then don&#x27;t set this property to false.</span><br><span class="line">eureka.registration.enabled=false</span><br><span class="line"></span><br><span class="line">## configuration related to reaching the eureka servers</span><br><span class="line">eureka.preferSameZone=true</span><br><span class="line">eureka.shouldUseDns=false</span><br><span class="line">eureka.serviceUrl.default=http://localhost:8080/eureka/v2/</span><br><span class="line"></span><br><span class="line">eureka.decoderName=JacksonJson</span><br></pre></td></tr></table></figure>

<p>你可以复制并按你自己的需要编辑这些配置，然后将它们放到你项目的class path。如果你因为某些原因改变了自定义配置文件的名称，你可以通过在java commondline中指定 <em>-Deureka.client.props={配置文件名}</em>（文件名不带后缀） 来搜索并启用你修改名称后的配置文件。      </p>
<p>配置文件中解释了各个配置项的作用。最小的必须配置项为：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Application Name (eureka.name)</span><br><span class="line">Application Port (eureka.port)</span><br><span class="line">Virtual HostName (eureka.vipAddress)</span><br><span class="line">Eureka Service Urls (eureka.serviceUrls)</span><br></pre></td></tr></table></figure>

<p>更多的配置项，通过查看&lt;<a href="https://github.com/Netflix/eureka/blob/master/eureka-client/src/main/java/com/netflix/appinfo/EurekaInstanceConfig.java">https://github.com/Netflix/eureka/blob/master/eureka-client/src/main/java/com/netflix/appinfo/EurekaInstanceConfig.java</a> <a href="https://github.com/Netflix/eureka/blob/master/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java&gt;可以获得。">https://github.com/Netflix/eureka/blob/master/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java&gt;可以获得。</a></p>
<h2 id="配置Eureka-Server"><a href="#配置Eureka-Server" class="headerlink" title="配置Eureka Server"></a>配置Eureka Server</h2><h3 id="先决条件-1"><a href="#先决条件-1" class="headerlink" title="先决条件"></a>先决条件</h3><ul>
<li>JDK 1.8或更高</li>
<li>Tomcat 6.0.10或更高</li>
</ul>
<p>你可以选择以下方式获取Eureka Server程序：</p>
<ul>
<li>参照<a href="https://github.com/Netflix/eureka/wiki/Building-Eureka-Client-and-Server">https://github.com/Netflix/eureka/wiki/Building-Eureka-Client-and-Server</a>手动编译WAR包。</li>
<li>使用<a href="http://search.maven.org/#search%7Cga%7C1%7Ceureka-server">http://search.maven.org/#search%7Cga%7C1%7Ceureka-server</a>从MAVEN中央仓库直接下载WAR包。</li>
</ul>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>Eureka Server有2个配置：</p>
<ul>
<li>Eureka Client配置，就如同之前的。</li>
<li>Eureka Server配置。</li>
</ul>
<p>最简单的配置方式就是像之前的Eureka Client一样使用配置文件。首先，按照说明配置和Eureka Server一起运行的Eureka Client。Eureka Server本身会启动一个Eureka Client用以发现其他Eureka Server。因此，你需要首先为Eureka Server配置Eureka Client，就像与其他连接到Eureka Server的客户端一样。Eureka Server将使用它的Eureka Client配置来识别具有相同名称(意即)eureka.name的对等Eureka Server。   </p>
<p>在配置好Eureka Client之后，如果你正在AWS中运行，那么你需要配置Eureka Server。Eureka Server默认会在 <em>classpath</em> 目录下寻找 <em>eureka-server.properties</em> 配置文集。同样的，可以使用java commandline <em>-Deureka.environment</em> 来指定环境，用于读取不同环境下的配置文件。</p>
<h4 id="本地开发配置"><a href="#本地开发配置" class="headerlink" title="本地开发配置"></a>本地开发配置</h4><p>当在本地开发运行Eureka时，通常需要等待大约3分钟来完成启动。这是服务器默认的行为，目的是在发现没有其它可用服务节点时，用来搜索其它节点以同步和重试。等待时间可以通过属性设置来减少：</p>
<blockquote>
<p>eureka.numberRegistrySyncRetries=0</p>
</blockquote>
<h4 id="AWS配置"><a href="#AWS配置" class="headerlink" title="AWS配置"></a>AWS配置</h4><p>如果你运行在AWS中，按照<a href="https://github.com/Netflix/eureka/wiki/Deploying-Eureka-Servers-in-EC2">https://github.com/Netflix/eureka/wiki/Deploying-Eureka-Servers-in-EC2</a>处的说明，需要一些额外的配置。其他高级配置，可以参照此处<a href="https://github.com/Netflix/eureka/blob/master/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java">https://github.com/Netflix/eureka/blob/master/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java</a>。    </p>
<p>如果你是手动构建WAR包，你可以编辑 <em>eureka-server/conf</em> 目录下的配置文件，这样构建之前文件将会存放到 WEB-INF/classes 目录下。</p>
<p>如果你下载了WAR包，你可以自行修改包中的 WEB-INF/classes 目录下的配置文件。</p>
<p>运行一个demo应用可以帮助你很好的理解配置属性。</p>
<h2 id="版本兼容性"><a href="#版本兼容性" class="headerlink" title="版本兼容性"></a>版本兼容性</h2><p>我们在eureka中使用版本语义，并在小版本升级中维护兼容性（即1.X版下服务器和客户端是兼容的）。通常，服务器使用比客户端新的版本是安全的。</p>
]]></content>
      <categories>
        <category>eureka</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>创建Eureka客户端和服务端</title>
    <url>/2018/01/29/eureka/3-Building_Eureka_Client_and_Server/</url>
    <content><![CDATA[<h1 id="构建Eureka服务端和客户端"><a href="#构建Eureka服务端和客户端" class="headerlink" title="构建Eureka服务端和客户端"></a>构建Eureka服务端和客户端</h1><h2 id="前置需求"><a href="#前置需求" class="headerlink" title="前置需求"></a>前置需求</h2><blockquote>
<p>Git 1.7.11.3或更高版本</p>
</blockquote>
<h2 id="构建步骤"><a href="#构建步骤" class="headerlink" title="构建步骤"></a>构建步骤</h2><ol>
<li><p>安装最新版<a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">Git</a>。</p>
</li>
<li><p>从Github获取Eureka最新源码。</p>
<blockquote>
<p>git clone <a href="https://github.com/Netflix/eureka.git">https://github.com/Netflix/eureka.git</a></p>
</blockquote>
</li>
<li><p>在你获取的源码目录中执行构建命令。</p>
<blockquote>
<p>./gradlew clean build</p>
</blockquote>
</li>
<li><p>正确构建之后，你将获得以下文件：</p>
<blockquote>
<p>Eureka服务端程序：./eureka-server/build/libs/eureka-server-XXX.war</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>Eureka客户端程序:./eureka-client/build/libs/eureka-client-XXX.jar</p>
</blockquote>
<blockquote>
<p>第三方依赖包：./eureka-server/testlibs/*.jar</p>
</blockquote>
]]></content>
      <categories>
        <category>eureka</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Eureka客户端和服务端的通讯</title>
    <url>/2018/01/31/eureka/4-Client_Server_Communication/</url>
    <content><![CDATA[<h1 id="Eureka客户端和服务端的通讯"><a href="#Eureka客户端和服务端的通讯" class="headerlink" title="Eureka客户端和服务端的通讯"></a>Eureka客户端和服务端的通讯</h1><p>使用Eureka的第一步是进行Eureka client的初始化。如果你是在AWS中使用，可以使用以下方式进行初始化：<br>使用1.1.153版本时，客户端可以和governator/guice一其使用，详细请看<a href=""https://github.com/Netflix/eureka/blob/master/eureka-examples/src/main/java/com/netflix/eureka/ExampleEurekaGovernatedService.java"">示例</a>。<br>在1.1.153版本之前，你可以使用以下方式进行客户端初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DiscoveryManager.getInstance().initComponent(</span><br><span class="line">                <span class="keyword">new</span> CloudInstanceConfig(),</span><br><span class="line">                <span class="keyword">new</span> DefaultEurekaClientConfig());</span><br></pre></td></tr></table></figure>
<p>如果你是在其他数据中心使用，则使用以下方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DiscoveryManager.getInstance().initComponent(</span><br><span class="line">                <span class="keyword">new</span> MyDataCenterInstanceConfig(),</span><br><span class="line">                <span class="keyword">new</span> DefaultEurekaClientConfig());</span><br></pre></td></tr></table></figure>
<p>Eureka Client查找并使用<em>eureka-client.properties</em>，相关信息看第二章客户端配置。</p>
<span id="more"></span>
<h2 id="实例的状态（About-Instance-Statuses）"><a href="#实例的状态（About-Instance-Statuses）" class="headerlink" title="实例的状态（About Instance Statuses）"></a>实例的状态（About Instance Statuses）</h2><p>默认的，Eureka client开始时处于<strong>STARTING</strong>状态，在此期间，实例能够处理一些程序特定的初始化操作，这处于实例能够对外提供服务之前。<br>程序在之后将实例状态转为<strong>UP</strong>，表明实例可以对外提供服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationInfoManager.getInstance().setInstanceStatus(InstanceStatus.UP)</span><br></pre></td></tr></table></figure>
<p>程序也能注册健康检查的回调接口，通过此接口可以随时改变实例状态到<strong>DOWN</strong>。<br>在NETFLIX，还是用一个<strong>OUT_OF_SERVICE</strong>的状态，用于将实例从流量中摘除。在新版本出现问题时，使用它对版本进行回退非常有用。所有的应用为新版本创建一个新ASG并将流量转发到这些新的ASG。当出现问题时，回退版本仅仅是设置所有的有问题版本所在实例的状态为<strong>OUT_OF_SERVICE</strong>。</p>
<h2 id="客户端操作（Eureka-Client-Operations）"><a href="#客户端操作（Eureka-Client-Operations）" class="headerlink" title="客户端操作（Eureka Client Operations）"></a>客户端操作（Eureka Client Operations）</h2><p>AWS云环境下，Eureka client首先尝试连接在相同zone的Eureka Server进行所有操作，如果连接不上，则连接其他zone中的server。<br>应用能够通过使用Eureka client返回的信息来进行负载均衡。以下是一个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InstanceInfo nextServerInfo = DiscoveryManager.getInstance()</span><br><span class="line">                .getDiscoveryClient()</span><br><span class="line">                .getNextServerFromEureka(vipAddress, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        Socket s = <span class="keyword">new</span> Socket();</span><br><span class="line">        <span class="keyword">int</span> serverPort = nextServerInfo.getPort();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s.connect(<span class="keyword">new</span> InetSocketAddress(nextServerInfo.getHostName(),</span><br><span class="line">                    serverPort));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Could not connect to the server :&quot;</span></span><br><span class="line">                    + nextServerInfo.getHostName() + <span class="string">&quot; at port &quot;</span> + serverPort);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>如果基本的轮询（round-robin）负载均衡算法不能满足你的要求，你可以通过API接口自行实现。在AWS中，确保失败后进行重试并且超时时间尽量低，因为在Eureka server会因返回时中断导致实例不存在的情况。<br>还有非常重要的一点，Eureka client会清空空闲时间超过30秒的与server建立的HTTP链接。这是AWS的防火墙策略导致的。</p>
<h2 id="Eureka-客户端和服务端进行以下操作"><a href="#Eureka-客户端和服务端进行以下操作" class="headerlink" title="Eureka 客户端和服务端进行以下操作"></a>Eureka 客户端和服务端进行以下操作</h2><h3 id="注册（register）"><a href="#注册（register）" class="headerlink" title="注册（register）"></a>注册（register）</h3><p>Eureka client注册正在运行的实例相关信息到Eureka server。在AWS中，实例的信息通过URL <a href="http://169.254.169.254/latest/metadata进行注册。注册发生在第一次心跳时（30秒后）。">http://169.254.169.254/latest/metadata进行注册。注册发生在第一次心跳时（30秒后）。</a></p>
<h3 id="续租（Renew）"><a href="#续租（Renew）" class="headerlink" title="续租（Renew）"></a>续租（Renew）</h3><p>Eureka client需要每隔30秒通过心跳进行续租。续租向Eureka server表明本实例仍然存活。如果server在90秒内没有收到续租信息，它将未收到续租的实例从注册表中移除。建议不要更改更新间隔，因为server使用该信息来确定client与server通信是否存在广泛的传播问题。</p>
<h3 id="注册信息获取（Fetch-Registry）"><a href="#注册信息获取（Fetch-Registry）" class="headerlink" title="注册信息获取（Fetch Registry）"></a>注册信息获取（Fetch Registry）</h3><p>Eureka client从server获取注册信息并缓存在本地。之后，client使用注册信息发现其他的服务。注册信息会周期性的更新（每隔30秒），并且是进行增量更新。增量信息在server保存的时间更长（大约3分钟），因此在更新时可能会返回相同的信息。eureka client会自动处理重复的信息。<br>获取增量信息后，eureka client将通过比较server返回的实例数量进行一致性校验，如果发现不一致，整个注册信息将重新获取。Eureka server缓存经过压缩的增量信息，所有注册的实例和每个应用通过相同的方式解压这些信息。信息支持JSON/XML格式。Eureka client使用jersey apache客户端获取进过压缩的JSON格式数据。</p>
<h3 id="注销（Cancel）"><a href="#注销（Cancel）" class="headerlink" title="注销（Cancel）"></a>注销（Cancel）</h3><p>Eureka client在关闭时向server发出一个注销请求。这把实例从server的注册表中移除，实际上就是将实例从流量中摘除。<br>这个动作发生在Eureka client关闭并且应用需要确保在关闭时调用了以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DiscoveryManager.getInstance().shutdownComponent()</span><br></pre></td></tr></table></figure>

<h3 id="延迟（Time-Lag）"><a href="#延迟（Time-Lag）" class="headerlink" title="延迟（Time Lag）"></a>延迟（Time Lag）</h3><p>Eureka client的所有操作都会花费一些时间才能被server使用，随后才会被其他client获取。这是因为eureka server缓存的注册信息有一定的更新间隔，同样的client获取信息也有间隔。因此，最高有2分钟的延迟，所有的client才能收到变更。</p>
<h3 id="通讯机制（Communication-mechanism）"><a href="#通讯机制（Communication-mechanism）" class="headerlink" title="通讯机制（Communication mechanism）"></a>通讯机制（Communication mechanism）</h3><p>默认的，eureka client通过Jersey和XStream一起，使用JSON格式数据同server进行通讯。如果有需要，你可以通过覆盖默认实现，使用自己的通讯机制。</p>
]]></content>
      <categories>
        <category>eureka</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Eureka客户端配置</title>
    <url>/2017/09/25/eureka/eureka-client-config/</url>
    <content><![CDATA[<h1 id="Eureka客户端配置说明"><a href="#Eureka客户端配置说明" class="headerlink" title="Eureka客户端配置说明"></a>Eureka客户端配置说明</h1><blockquote>
<p>EurekaInstanceConfig </p>
</blockquote>
<ul>
<li>instanceId:client唯一标识，将此实例从相同appName的集群中区分开来。</li>
<li>appName:注册到eureka server的服务名，相同appName的实例组成集群。</li>
<li>appGroupName:实例所在群组名，用于划分服务。</li>
<li>instanceEnabledOnit:实例启动后是否立即注册到eureka server，因为有的实例启动后需要处理一些额外的事情才能对外提供服务。</li>
<li>nonSecurePort:非安全端口。</li>
<li>securePort:安全端口。</li>
<li>nonSecurePortEnabled:是否启用非安全端口。</li>
<li>securePortEnabled:是否启用安全端口。<span id="more"></span></li>
<li>leaseRenewalIntervalInSeconds:向eureka server发送心跳的时间间隔，秒，如果在leaseExpirationDurationInSeconds规定的时间窗口内，server没有收到过心跳，将会把此实例从列表中移除，此示例将无法获得流量，注意如果此示例实现了HealthCheckCallback，那么既使心跳正常，是否对外提供服务还是由回调接口返回值决定。</li>
<li>leaseExpirationDurationInSeconds:心跳时间窗口，秒，在距离上次收到心跳的时间间隔超过窗口期还未收到新的心跳，则server认为实例已下线。此值设置最小必须超过leaseRenewalIntervalInSeconds的值。</li>
<li>virtualHostName:虚拟主机名。用于客户端发现此实例。</li>
<li>secureVirtualHostName:安全虚拟主机名。用于客户端通过安全虚拟主机名发现此实例。</li>
<li>ASGName:AWS autoscaling group name。</li>
<li>hostName:关联此实例的主机名，真实的用于其他实例对此实例发起调用的名称。</li>
<li>metadataMap:元数据表，存储此实例相关联的自定义key-value值并发送到eureka server，此元表能够被其他实例获取到。</li>
<li>dataCenterInfo: 实例在AWS的哪个数据中心。</li>
<li>ipAddress:此实例的ip地址。</li>
<li>statusPageUrlPath:状态页自定义访问链接。</li>
<li>StatusPageUrl:状态也访问链接。</li>
<li>homePageUrlPath:自定义首页访问链接。</li>
<li>homePageUrl:首页访问链接。</li>
<li>healthCheckUrlPath:自定义健康状态访问链接。</li>
<li>healthCheckUrl:健康状态访问链接。</li>
<li>secureHealthCheckUrl:安全健康状态访问链接。</li>
<li>nameSpace:命名空间，使用此命名空间查找响应的属性。</li>
<li>defaultAddressResolutionOrder:AWS中实例的地址信息数组，包括publicHostname， publicIp，privateHostname， privateIp。</li>
</ul>
<blockquote>
<p>EurekaClientConfig </p>
</blockquote>
<ul>
<li>registryFetchIntervalSeconds: 从eureka server获取注册信息的间隔，单位秒。</li>
<li>instanceInfoReplicationIntervalSeconds: 上报当前节点的信息到eureka server的间隔，单位秒</li>
<li>initialInstanceInfoReplicationIntervalSeconds: 初始化后多少秒将当前节点的信息上报到eureka server</li>
<li>eurekaServiceUrlPollIntervalSeconds: 获取eureka server url地址改变的时间间隔，单位秒。server端会修改此值。</li>
<li>proxyHost: 代理主机，可选。</li>
<li>proxyPort: 代理端口，可选。</li>
<li>proxyUserName: 代理用户名。</li>
<li>proxyPassword: 代理用户密码。</li>
<li>shouldGZipContent: 传输内容是否压缩过。</li>
<li>eurekaServerReadTimeoutSeconds： 当读取某个eureka server时的超时时间。</li>
<li>EurekaServerConnectTimeoutSeconds： 连接某个eureka server时的超时时间。</li>
<li>backupRegistryImpl: BackupRegistry的实现类，备份注册信息。</li>
<li>eurekaServerTotalConnections: 允许当前实例向所有eureka server发起的连接总数。</li>
<li>eurekaServerTotalConnectionsPerHost: 允许当前实例向单个eureka server发起的连接总数。</li>
<li>eurekaServerURLContext: 当eureka server列表为DNS查询获得时，使用此值构造URL连接eureka server。当shouldUseDnsForFetchingServiceUrls设置为true时，eureka client通过DNS获取eureka server的改变。</li>
<li>eurekaServerPort: 使用DNS获取server时，需要指定eureka server的端口用来连接。</li>
<li>eurekaServerDNSName: DNS的名称，用来查询eureka server列表。</li>
<li>shouldUseDnsForFetchingServiceUrls: 是否使用DNS的方式来查询eureka server列表。</li>
<li>shouldRegisterWithEureka: 当前实例是否注册到eureka server，以使其他实例可以发现它。</li>
<li>shouldUnregisterOnShutdown: 当前实例关闭时是否在eureka server上注销。</li>
<li>shouldPreferSameZoneEureka: 是否使用相同zone的eureka server。</li>
<li>allowRedirects: 是否允许eureka server将当前实例的请求进行重定向转发。</li>
<li>shouldLogDeltaDiff: 当解析服务器返回信息失败时，输出对比日志。</li>
<li>shouldDisableDelta： 是否开启对比。</li>
<li>fetchRegistryForRemoteRegions: 逗号分隔的region列表，当前实例将从region列表中获取可用的zone。</li>
<li>region: AWS中，当前实例所在的region。</li>
<li>availabilityZones: 可用的zone列表，数组。</li>
<li>eurekaServerServiceUrls： eureka server URL列表。</li>
<li>shouldFilterOnlyUpInstances: 是否过滤掉挂起状态的实例。</li>
<li>eurekaConnectionIdleTimeoutSeconds: 当前实例在连接eureka server时http关闭前能够保持的空闲时间。超过空闲时间http连接将会关闭。</li>
<li>shouldFetchRegistry： 当前实例是否同步eureka server的注册信息。</li>
<li>registryRefreshSingleVipAddress: 从单个VIP获取注册信息，格式 name:port，如果为null则不获取。</li>
<li>heartbeatExecutorThreadPoolSize: 心跳线程池大小。</li>
<li>heartbeatExecutorExponentialBackOffBound: 心跳重试延期最大因子。</li>
<li>cacheRefreshExecutorThreadPoolSize: 缓存信息刷新的线程池大小。</li>
<li>cacheRefreshExecutorExponentialBackOffBound: 缓存刷新重试延期最大因子。</li>
<li>dollarReplacement: $符号的替代字符。</li>
<li>EscapeCharReplacementL: _的替代字符。</li>
<li>shouldOnDemandUpdateStatusChange： 是否将当前实例的状态上报给eureka server。</li>
<li>encoderName:编码类名称，为空使用默认。</li>
<li>dncoderName:解码类名称，为空使用默认。</li>
<li>experimental: 试验特性配置名称，此配置为了避免开发新特性时造成API污染。</li>
</ul>
<h1 id="配置文件属性对照"><a href="#配置文件属性对照" class="headerlink" title="配置文件属性对照"></a>配置文件属性对照</h1><p>{eureka}代表eureka为变量，是启动时通过java命令行参数传入的，eureka是默认值。{region}和{zone}为配置时自定义的变参region和zone。</p>
<ul>
<li>{eureka}.client.refresh.interval: 单位秒，registryFetchIntervalSeconds 默认值30秒</li>
<li>{eureka}.appinfo.replicate.interval: 单位秒，instanceInfoReplicationIntervalSeconds 默认值40秒</li>
<li>{eureka}.serviceUrlPollIntervalMs: 单位毫秒 EurekaServiceUrlPollIntervalSeconds 默认值300秒</li>
<li>{eureka}.eurekaServer.proxyHost: proxyHost</li>
<li>{eureka}.eurekaServer.proxyPort: proxyPort</li>
<li>{eureka}.eurekaServer.proxyUserName: proxyUserName</li>
<li>{eureka}.eurekaServer.proxyPassword: proxyPassword</li>
<li>{eureka}.eurekaServer.gzipContent: shouldGZipContent 默认true</li>
<li>{eureka}.eurekaServer.readTimeout: 单位秒，eurekaServerReadTimeoutSeconds 默认值8秒</li>
<li>{eureka}.eurekaServer.connectTimeout: 单位秒，eurekaServerConnectTimeoutSeconds 默认值5秒</li>
<li>{eureka}.backupregistry: 类名，backupRegistryImpl 默认为null</li>
<li>{eureka}.eurekaServer.maxTotalConnections: 整数，eurekaServerTotalConnections，默认200</li>
<li>{eureka}.eurekaServer.maxConnectionsPerHost: 整数，eurekaServerTotalConnectionsPerHost 默认50</li>
<li>{eureka}.eurekaServer.context: eurekaServerURLContext,如果为null，则取{eureka}.context，如果还是null，则为null。</li>
<li>{eureka}.eurekaServer.port: eurekaServerPort,如果为null，则取{eureka}.port，如果还是null，则取null。</li>
<li>{eureka}.eurekaServer.domainName: EurekaServerDNSName，如果为null，则取eureka.domainName，如果还是null,则为null。</li>
<li>{eureka}.shouldUseDns: shouldUseDnsForFetchingServiceUrls 默认值为false</li>
<li>{eureka}.registration.enabled: shouldRegisterWithEureka 默认值为true</li>
<li>{eureka}.shouldUnregisterOnShutdown: shouldUnregisterOnShutdown 默认值为true</li>
<li>{eureka}.preferSameZone: shouldPreferSameZoneEureka 默认值为false</li>
<li>{eureka}.allowRedirects: allowRedirects 默认值为false</li>
<li>{eureka}.printDeltaFullDiff: shouldLogDeltaDiff 默认值为false</li>
<li>{eureka}.disableDelta: shouldDisableDelta 默认值为false</li>
<li>{eureka}.fetchRemoteRegionsRegistry: fetchRegistryForRemoteRegions 默认null</li>
<li>{eureka}.region: region(如果namespace是自定义的，先读取自定义namespace.region，读取为null才读取eureka.region) 默认值us-east-1</li>
<li>{eureka}.{region}.availabilityZones: availabilityZones 使用“,”分割，默认值defaultZone。</li>
<li>{eureka}.serviceUrl.{zone}:  eurekaServerServiceUrls 如果为空，使用{eureka}.serviceUrl.default的值，使用“,”分割，2个都为null则为null。</li>
<li>{eureka}.shouldFilterOnlyUpInstances: shouldFilterOnlyUpInstances 默认值true</li>
<li>{eureka}.eurekaserver.connectionIdleTimeoutInSeconds:  单位秒，eurekaConnectionIdleTimeoutSeconds 默认值30秒</li>
<li>{eureka}.shouldFetchRegistry: shouldFetchRegistry 默认值true</li>
<li>{eureka}.registryRefreshSingleVipAddress: RegistryRefreshSingleVipAddress 默认值null</li>
<li>{eureka}.client.heartbeat.threadPoolSize: 整数 heartbeatExecutorThreadPoolSize 默认值5</li>
<li>{eureka}.client.heartbeat.exponentialBackOffBound: 整数 heartbeatExecutorExponentialBackOffBound 默认值10</li>
<li>{eureka}.client.cacheRefresh.threadPoolSize: 整数 cacheRefreshExecutorThreadPoolSize 默认值5</li>
<li>{eureka}.client.cacheRefresh.exponentialBackOffBound: 整数 cacheRefreshExecutorExponentialBackOffBound 默认值10</li>
<li>{eureka}.dollarReplacement: 字符串 dollarReplacement 默认值“_-”</li>
<li>{eureka}.escapeCharReplacement: 字符串 escapeCharReplacement 默认值“__”</li>
<li>{eureka}.shouldOnDemandUpdateStatusChange: shouldOnDemandUpdateStatusChange 默认值true</li>
<li>{eureka}.encoderName: encoderName 默认值null</li>
<li>{eureka}.decoderName: decoderName 默认值null</li>
<li>{eureka}.clientDataAccept：clientDataAccept 默认full</li>
<li>{eureka}.experimental.{name}: experimental 默认null</li>
</ul>
]]></content>
      <categories>
        <category>eureka</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Eureka Server配置</title>
    <url>/2017/09/26/eureka/eureka-server-config/</url>
    <content><![CDATA[<h1 id="Eureka-Server配置说明"><a href="#Eureka-Server配置说明" class="headerlink" title="Eureka Server配置说明"></a>Eureka Server配置说明</h1><ul>
<li>{eureka}.awsAccessId: AWSAccessId AWS Access Id，用来绑定到EIP，默认值null</li>
<li>{eureka}.awsSecretKey: AWSSecretKey 密钥 默认值null</li>
<li>{eureka}.eipBindRebindRetries: EIPBindRebindRetries 绑定到EIP的重试次数 默认值3</li>
<li>{eureka}.eipBindRebindRetryIntervalMsWhenUnbound: 单位毫秒 EIPBindingRetryIntervalMsWhenUnbound 检查绑定状态的时间间隔 默认值60 * 1000</li>
<li>{eureka}.eipBindRebindRetryIntervalMs: 单位毫秒 EIPBindingRetryIntervalMs 绑定稳定状态检查时间间隔 默认值300秒</li>
<li>{eureka}.enableSelfPreservation: shouldEnableSelfPreservation 是否开启自我保护（当接收到客户端的心跳小于阈值时server会进入自我保护模式）默认值true</li>
<li>{eureka}.renewalPercentThreshold: renewalPercentThreshold 期待从客户端获取的心跳阈值百分比 默认值0.85</li>
<li>{eureka}.renewalThresholdUpdateIntervalMs 单位毫秒 renewalThresholdUpdateIntervalMs 更新心跳阈值的时间间隔 默认值15分钟</li>
<li>{eureka}.peerEurekaNodesUpdateIntervalMs: 单位毫秒 peerEurekaNodesUpdateIntervalMs  集群里eureka节点的变化信息更新的时间间隔，单位为毫秒，默认为10 * 60 * 1000</li>
<li>{eureka}.enableReplicatedRequestCompression: shouldEnableReplicatedRequestCompression 复制的数据在发送时是否压缩 默认值false</li>
<li>{eureka}.numberOfReplicationRetries: NumberOfReplicationRetries 集群里服务器尝试复制数据的次数 默认值5</li>
<li>{eureka}.peerEurekaStatusRefreshTimeIntervalMs: PeerEurekaStatusRefreshTimeIntervalMs 服务器节点状态信息更新的时间间隔 默认值30*1000</li>
<li>{eureka}.waitTimeInMsWhenSyncEmpty: WaitTimeInMsWhenSyncEmpty 服务器获取不到集群里对等服务器实例时，需要等待的时间 默认值1000 * 60 * 5<span id="more"></span></li>
<li>{eureka}.peerNodeConnectTimeoutMs: PeerNodeConnectTimeoutMs 链接对等服务器节点的超时时间 默认值200</li>
<li>{eureka}.peerNodeReadTimeoutMs: PeerNodeReadTimeoutMs 读取对等服务器节点复制数据的超时时间 默认值200</li>
<li>{eureka}.peerNodeTotalConnections: PeerNodeTotalConnections 允许对等服务器节点连接的总数量 默认值1000</li>
<li>{eureka}.peerNodeTotalConnectionsPerHost PeerNodeTotalConnectionsPerHost 允许单个对等服务器节点连接的数量 默认值500</li>
<li>{eureka}.peerNodeConnectionIdleTimeoutSeconds: PeerNodeConnectionIdleTimeoutSeconds http连接允许空闲时间 默认值30</li>
<li>{eureka}.retentionTimeInMSInDeltaQueue: RetentionTimeInMSInDeltaQueue 客户端保持增量信息的缓存时间 默认值3 * 60 * 1000</li>
<li>{eureka}.evictionIntervalTimerInMs: EvictionIntervalTimerInMs 过期实例允许重启时间间隔  默认值60 * 1000</li>
<li>{eureka}.asgQueryTimeoutMs:  ASGQueryTimeoutMs 查询AWS上ASG信息超时时间 默认值300</li>
<li>{eureka}.asgUpdateIntervalMs: ASGUpdateIntervalMs 从AWS更新ASG信息的时间间隔 默认值5 * 60 * 1000</li>
<li>{eureka}.asgCacheExpiryTimeoutMs: ASGCacheExpiryTimeoutMs 缓存ASG信息的时间 默认值10 * 60 * 1000</li>
<li>{eureka}.responseCacheAutoExpirationInSeconds: ResponseCacheAutoExpirationInSeconds 注册信息被更改时，旧信息在缓存中保存的时间 默认值180</li>
<li>{eureka}.responseCacheUpdateIntervalMs: ResponseCacheUpdateIntervalMs 客户端注册信息列表缓存更新的时间间隔 默认值30 * 1000</li>
<li>{eureka}.shouldUseReadOnlyResponseCache: shouldUseReadOnlyResponseCache 目前采用的是二级缓存策略，一个是读写高速缓存过期策略，另一个没有过期只有只读缓存，默认为true，表示只读缓存 默认值true</li>
<li>{eureka}.disableDelta: shouldDisableDelta 增量信息是否提供给客户端 默认值false</li>
<li>{eureka}.maxIdleThreadAgeInMinutesForStatusReplication: MaxIdleThreadInMinutesAgeForStatusReplication 状态复制线程可以保持存活的空闲时间 默认值10</li>
<li>{eureka}.minThreadsForStatusReplication: MinThreadsForStatusReplication 被用于状态复制的最小线程数 默认值1</li>
<li>{eureka}.maxThreadsForStatusReplication: MaxThreadsForStatusReplication 被用于状态复制的最大线程数 默认值1</li>
<li>{eureka}.maxElementsInStatusReplicationPool: MaxElementsInStatusReplicationPool 可以允许备份的状态复制事件最大数量 默认值10000</li>
<li>{eureka}.syncWhenTimestampDiffers: shouldSyncWhenTimestampDiffers 当时间变化时是否重新同步  默认值true</li>
<li>{eureka}.numberRegistrySyncRetries: RegistrySyncRetries 当服务器启动时尝试去获取集群里其他服务器上的注册信息的次数 默认值5</li>
<li>{eureka}.registrySyncRetryWaitMs: RegistrySyncRetryWaitMs 当服务器启动时获取集群中其他服务器注册信息失败时，重试的时间间隔 默认值 30*1000</li>
<li>{eureka}.maxElementsInPeerReplicationPool: MaxElementsInPeerReplicationPool 备份复制事件的最大数量 默认值10000</li>
<li>{eureka}.maxIdleThreadAgeInMinutesForPeerReplication: 单位分钟 MaxIdleThreadAgeInMinutesForPeerReplication 复制线程可以保持存活的空闲时间 默认值15</li>
<li>{eureka}.minThreadsForPeerReplication: MinThreadsForPeerReplication 被用于复制的最小线程数目 默认值5</li>
<li>{eureka}.maxThreadsForPeerReplication: MaxThreadsForPeerReplication 被用于复制的最大线程数目 默认值20</li>
<li>{eureka}.maxTimeForReplication: MaxTimeForReplication 允许复制线程执行的时间 默认值30000</li>
<li>{eureka}.primeAwsReplicaConnections: shouldPrimeAwsReplicaConnections 检查新节点的复制连接是否启用 默认值true</li>
<li>{eureka}.disableDeltaForRemoteRegions: shouldDisableDeltaForRemoteRegions 增量信息是否提供给客户端或其他region 默认值false</li>
<li>{eureka}.remoteRegionConnectTimeoutMs: RemoteRegionConnectTimeoutMs 连接到其他region服务器节点的超时时间 默认值1000</li>
<li>{eureka}.remoteRegionReadTimeoutMs: RemoteRegionReadTimeoutMs 从其他region服务器节点读取信息的超时时间 默认值1000</li>
<li>{eureka}.remoteRegionTotalConnections: RemoteRegionTotalConnections 允许连接到其他region服务器节点的总http数量 默认值1000</li>
<li>{eureka}.remoteRegionTotalConnectionsPerHost: RemoteRegionTotalConnectionsPerHost 允许连接到其他region单个服务器节点的http数量 默认值500</li>
<li>{eureka}.remoteRegionConnectionIdleTimeoutSeconds: RemoteRegionConnectionIdleTimeoutSeconds 允许连接到其他region服务器节点的http空闲时间 默认值30</li>
<li>{eureka}.remoteRegion.gzipContent: shouldGZipContentFromRemoteRegion 获取的信息是否在其他region的服务器节点被压缩过 默认值true</li>
<li>{eureka}.remoteRegionUrlsWithName: RemoteRegionUrlsWithName 其他region的名称地址MAP  默认值null；使用 <strong>,</strong> 分割 <strong>region;url</strong> 组成的数组，</li>
<li>{eureka}.remoteRegionUrls: RemoteRegionUrls 其他region的url地址列表 默认null，使用 <strong>,</strong> 分割的url地址。</li>
<li>{eureka}.remoteRegion.{regionName}.appWhiteList: RemoteRegionAppWhitelist 允许其他region连接到此实例的应用白名单 使用 <strong>,</strong> 分割的数组，默认值null，regionName默认值为global。</li>
<li>{eureka}.remoteRegion.registryFetchIntervalInSeconds: RemoteRegionRegistryFetchInterval 从其他region同步注册信息的时间间隔 默认值30</li>
<li>{eureka}.remoteRegion.fetchThreadPoolSize: RemoteRegionFetchThreadPoolSize 用于执行和其他region同步注册信息的线程池大小 默认值20</li>
<li>{eureka}.remoteRegion.trustStoreFileName: RemoteRegionTrustStore 信任文件存储位置 默认值””</li>
<li>{eureka}.remoteRegion.trustStorePassword: RemoteRegionTrustStorePassword 信任文件存储密码 默认值changeit</li>
<li>{eureka}.remoteRegion.disable.transparent.fallback: disableTransparentFallbackToOtherRegion 在本region中没有provider运行时，是否回退到其他region 默认值false</li>
<li>{eureka}.shouldBatchReplication: shouldBatchReplication 是否为复制进行批量处理 默认值false</li>
<li>{eureka}.auth.shouldLogIdentityHeaders: shouldLogIdentityHeaders 服务器是否应该登录clientAuthHeaders 默认值true</li>
<li>{eureka}.jsonCodecName: JsonCodecName json编码器类名 默认值null</li>
<li>{eureka}.xmlCodecName: XmlCodecName  xml编码器类名 默认值null</li>
<li>{eureka}.route53BindRebindRetries: Route53BindRebindRetries 尝试绑定到Route53的次数 默认值3</li>
<li>{eureka}.route53BindRebindRetryIntervalMs: Route53BindingRetryIntervalMs 检查绑定状态的时间间隔 默认值5 * 60 * 1000</li>
<li>{eureka}.route53DomainTTL: Route53DomainTTL Route53的TTL值 默认值301</li>
<li>{eureka}.awsBindingStrategy: BindingStrategy 绑定策略 默认值EIP</li>
<li>{eureka}.experimental.{name}: Experimental 试验特性配置 默认值null</li>
<li>{eureka}.minAvailableInstancesForPeerReplication: HealthStatusMinNumberOfAvailablePeers 当多少个实例运行时判定集群健康状态 默认值-1</li>
</ul>
]]></content>
      <categories>
        <category>eureka</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载机制</title>
    <url>/2017/10/09/jvm-load-class/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>类加载机制：虚拟机把描述类的数据从Class文件(来源可以是文件，或者文件流等)加载在内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型。<br>java中，类的加载、连接和初始化过程都是在程序运行期间完场的，与其他在编译期就完成连接的语言不通，这样以牺牲前期一些性能的方式提供了动态扩展。</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类的生命周期：加载，验证，准备，解析，初始化，使用，卸载。其中加载、验证、准备、初始化和卸载5个阶段的顺序是确定的，类的加载过程严格按照这种顺序进行。验证、准备、解析3个阶段统称为连接。解析阶段某些情况下则会在初始化后才开始。<br>什么时候开始类加载虚拟机规范没有规定，依赖虚拟机自身实现。<br>虚拟机规范规定以下5类情况必须立即对类进行“初始化”，在此之前类的加载，验证，准备已经完成：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1. 遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。对应的java代码场景是：使用new关键字实例化对象，读取或设置一个类的静态字段（被final修饰，已在编译期把结果放入常量池的静态字段除外），调用一个类的静态方法。</span><br><span class="line">2. 使用reflect包的方法对类进行反射调用时，如果类没有进行过初始化则需要先触发其初始化。</span><br><span class="line">3. 当初始化一个类时，发现其父类还没有初始化，则需要先触发其父类进行初始化。</span><br><span class="line">4. 当虚拟机启动时，用户指定了一个要执行的主类（包含要执行的main()方法，程序入口），虚拟机会先初始化这个类。</span><br><span class="line">5. 使用JDK1.7及以上版本时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄，且方法句柄对应的类没有初始化过，则需要先触发其初始化。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>“加载”是“类加载”过程的一个阶段。分3个阶段:</p>
<blockquote>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区（元数据区）的运行时数据结构。</li>
<li>在内存中生成代表这个类的java.lang.Class对象，作为方法区（元数据区）这个类的各种数据的访问入口。</li>
</ol>
</blockquote>
<p>类的二进制流可以从ZIP（压缩）包、网络流中读取，可以是运行时动态生成、由其他文件生成（例如JSP，XML），可以从数据库读取…总而言之，只要符合规定的格式，都可以为JVM所用。<br>数组类与普通类不同，数组类由java虚拟机直接创建，但数组类中的元素的类型对应的类仍然由类加载器创建。<br>加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的连接动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持固定的先后顺序。</p>
<h3 id="验证-文件格式验证，内容验证"><a href="#验证-文件格式验证，内容验证" class="headerlink" title="验证-文件格式验证，内容验证"></a>验证-文件格式验证，内容验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前JVM的要求，并且不会危害JVM自身的安全。<br>验证阶段大致会完成以下4个阶段：</p>
<blockquote>
<ol>
<li>文件格式验证。是否以魔数0xCAFEBABE开头；主次版本号是否在当前JVM处理范围内；常量池中是否有不被支持的常量；指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量；CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据；Class文件中各个部分及文件本身是否有被删除的、附加的其他信息。</li>
<li>元数据验证。这个类是否有父类（除了Object，所有类都应当有父类）；这个类的父类是否继承了不允许被继承的类；如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法；类中的字段、方法是否与父类产生矛盾（覆盖final属性或方法，不符合规则的方法重载）。</li>
<li>字节码验证。保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，保证操作数栈中数据类型与载入到本地变量表时数据类型保持一致；保证跳转指令不会跳转到方法体以外的字节码指令上；保证方法体中的类型转换是有效的，保证类型转换是安全、合法的。</li>
<li>符号引用验证，这个阶段在解析阶段完成。符号引用中通过字符串描述的全限定名是否能找到对应的类；在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段；符号引用中的类、字段、方法的访问性是否可被当前类访问。</li>
</ol>
</blockquote>
<h3 id="准备-类变量赋零值，final常量赋初值"><a href="#准备-类变量赋零值，final常量赋初值" class="headerlink" title="准备-类变量赋零值，final常量赋初值"></a>准备-类变量赋零值，final常量赋初值</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区（元数据区）中进行分配，这些变量仅包含类的变量（被static修饰的变量），初始值通常为零值，数值和byte为0，引用为null，boolean为false，程序员代码声明的值在初始化阶段才会赋给变量。但如果类属性被标识为final，则会被立即赋值为声明的值（被作为常量处理）。</p>
<h3 id="解析-引用替换"><a href="#解析-引用替换" class="headerlink" title="解析-引用替换"></a>解析-引用替换</h3><p>解析阶段是jvm将常量池内的符号引用替换为直接引用的过程。</p>
<blockquote>
<p>符号引用：符号引用以一组符号来描述引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用与JVM实现的内存布局无关，引用的目标不一定已经加载到内存中。各种JVM实现的内存布局可以不同，但它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确的定义在JAVA虚拟机规范的Class文件格式中。</p>
</blockquote>
<blockquote>
<p>直接引用：直接引用可以是和JVM内存布局相关的，同一个符号引用在不同的JVM实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必须已经在内存中存在。</p>
</blockquote>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>
<ol>
<li><p>类或接口的解析（CONSTANT_Class_info）<br>当前所处代码类为D，要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，需要以下3个步骤：</p>
<blockquote>
<ol>
<li>如果C不是一个数组类型，JVM会把代表N的全限定名传递给D的类加载器去加载这个类C，在加载过程中，由于元数据验证、字节码验证的需要，又有可能触发其他相关类的加载动作，一旦这个加载过程出现任何异常，解析过程宣告失败。</li>
<li>如果C是一个数组类型，并且数组的元数据类型为引用类型，按照1的规则加载数组元数据类型，接着由虚拟机生成一个代表此数组维度和元素的数组对象。</li>
<li>如果上面的步骤没有任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。如果不具备，将抛出异常。</li>
</ol>
</blockquote>
</li>
<li><p>字段解析（CONSTANT_Fieldref_info）<br>要解析一个字段，首先要解析字段所属的类或接口符号引用。所属类或接口的符号引用解析成功后，JVM规范要求按照如下步骤对C进行后续字段搜索：</p>
<blockquote>
<ol>
<li>如果C本身包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段的描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段的描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，查找失败，抛出java.lang.NoSuchFieldEror异常。</li>
</ol>
</blockquote>
</li>
<li><p>类方法解析（CONSTANT_Mehodref_info）<br>类方法解析首先也需要将所属的类的符号引用解析成功。JVM将按照以下步骤对类C的方法进行搜索：</p>
<blockquote>
<ol>
<li>类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li>
<li>如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有，说明C类时一个抽象类，查找结束，抛出java.lang.AbstractMethodError异常。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。<br>查找成功返回直接引用，并对这个方法进行权限验证。</li>
</ol>
</blockquote>
</li>
<li><p>接口方法解析（CONSTANT_InterfaceMethodref_info）<br>接口方法也需要先解析成功所属类或接口的符号引用。接口C的方法解析按照以下方法：</p>
<blockquote>
<ol>
<li>与类方法解析不同，如果在接口方法表中发现class_index中的索引C是个类而不是接口，直接抛出java.lang.IncompatibleClassChangeError异常。</li>
<li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在接口C的父接口中递归查找，直到java.lang.Object类为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li>
</ol>
</blockquote>
</li>
</ol>
<h3 id="初始化-类变量赋初值"><a href="#初始化-类变量赋初值" class="headerlink" title="初始化-类变量赋初值"></a>初始化-类变量赋初值</h3><p>初始化时类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。<br>在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源：初始化阶段执行类构造器<clinit>()方法的过程。</p>
<blockquote>
<ol>
<li><clinit>()方法由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，收集顺序由语句在源文件中出现的顺序决定，静态语句块中只能访问到定义在静态语句块之前的变量，定义在之后的变量，静态语句块可以赋值，但是不能访问。</li>
<li><clinit>()方法与类的构造函数（<init>()方法）不同，它不需要显示调用父类的构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。</li>
<li><clinit>()方法执行的顺序决定了父类中定义的静态语句块要优先于子类的变量赋值操作。</li>
<li><clinit>()方法对于类或接口来说并不是必须的，如果一个类或接口中并没有静态语句块，也没有对变量的赋值操作，编译器可以不为这个类生成<clinit>()方法。</li>
<li>接口中不能使用静态语句块，但仍然有变量初始化赋值（默认为public static fianl修饰符），接口会生成<clinit>()方法，但是接口与类不同，接口执行本身的<clinit>()方法时，并不会执行父接口的的<clinit>()方法，只有当父接口中定义的变量使用时，父接口才会初始化。接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。</li>
<li>JVM会保证一个类的<clinit>()方法在多线程环境中被正确的加锁、同步，如果多个线程同时初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待直到<clinit>()执行完毕，其他线程唤醒后不会再执行<clinit>()方法，同一个类加载器下，一个类型只会初始化一次。静态内部类和饿汉式的单例模式依靠这个机制。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//静态赋值语句，会编入&lt;clinit&gt;()，保证线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton1 single = <span class="keyword">new</span> Singleton1();</span><br><span class="line">    <span class="comment">//静态工厂方法 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态内部类方式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//静态赋值语句，会编入&lt;clinit&gt;()，保证线程安全</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> LazyHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>实现“通过一个类的全限定名来获取描述此类的二进制字节流”功能的代码模块称为“类加载器”。一个类在JVM中的唯一性，由加载它的类加载器和这个类本身一同确定：即如果比较2个类是否相等（两个类的equals、isAssignableFrom、isInstance方法返回结果相同），不仅需要判断两个类是否来自同一个Class文件，而且需要判断这两个类是否是由同一个类加载器加载。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>从JVM角度来说只存在2种类加载器：启动类加载器（Bootstrap ClassLoader）和其他类加载器。启动类加载器或其中底层方法大多由C++或C语言实现，是虚拟机的一部分；其他类加载器都由java实现，独立存在于虚拟机外部，且全部继承自抽象类java.lang.ClassLoader。<br>从开发者角度看，JVM提供了3种类加载器：</p>
<blockquote>
<ol>
<li>启动类加载器（Bootstrap ClassLoader），这个类加载器负责将存放在<JAVA_HOME>\lib目录中，或者被-Xbootclasspath参数所指定的路径中，并且是JVM标识的（仅按照文件名标识，如rt.jar）类库加载到虚拟机内存中，启动器类无法被JAVA程序直接引用。</li>
<li>扩展类加载器（Extension ClassLoader），这个类加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载<JAVA_HOME>\lib\ext目录中的，或被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载（Application ClassLoader），这个类加载器由sun.misc.Launcher$AppClassLoader实现，这个类加载器是ClassLoader中的getSystemClassLoader()方法被调用时直接返回的类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个类加载器就是程序中默认的类加载器。</li>
</ol>
</blockquote>
<p>类加载器之间的层级关系：<br>自定义类加载器-&gt;应用程序类加载器-&gt;扩展类加载器-&gt;启动类加载器。从宏观上来看是一种父子关系，但并不是通过类的继承来体现，而是以组合的关系来体现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="comment">// Note: VM hardcoded the offset of this field, thus all new fields</span></span><br><span class="line">    <span class="comment">// must be added *after* it.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双亲委派模型工作的过程：<br>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需要的类）时，子加载器才会尝试自己去加载。        </p>
<p>自己实现类加载器时，将自己的类加载逻辑写到findClass()方法中。以保证符合双清委派规则。        </p>
<p>为了完成一个类加载器委托子类加载器加载一个类（其目的是加载不在自己搜索范围内的类，例如JDBC,JNDI等情况，使用线程默认的上下文加载器加载核心类库中的接口，然后加载实现类，使得接口和实现类为同一个加载器加载，2者可见），引入了上下文类加载器（Thread Context ClassLoader）：这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，默认就是应用程序类加载器。<br>在OSGI中，类加载器不再是双亲委派模型，而是更为复杂的网状结构。其类加载顺序为：       </p>
<ol>
<li>将java.*开头的类委派给父类加载器加载。</li>
<li>否则，将委派列表名单内的类委派给父类加载器加载。</li>
<li>否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。</li>
<li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</li>
<li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven入门</title>
    <url>/2016/05/03/maven-guide/</url>
    <content><![CDATA[<h1 id="maven入门"><a href="#maven入门" class="headerlink" title="maven入门"></a>maven入门</h1><h2 id="为什么要使用maven"><a href="#为什么要使用maven" class="headerlink" title="为什么要使用maven"></a>为什么要使用maven</h2><h3 id="Maven是什么"><a href="#Maven是什么" class="headerlink" title="Maven是什么"></a>Maven是什么</h3><blockquote>
<p>Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project’s build, reporting and documentation from a central piece of information. </p>
</blockquote>
<p>maven是一个跨平台的项目管理和构建工具。maven的核心理念是约定大于配置，maven本身已经提供了一套默认设置，这意味着很多东西，使用Maven时都已经默认配置好了，使用者除非必要，不需要去修改那些约定好的内容，比如项目结构，插件等等。</p>
<h3 id="为什么要使用Maven"><a href="#为什么要使用Maven" class="headerlink" title="为什么要使用Maven"></a>为什么要使用Maven</h3><p>maven使用一个xml配置文件管理项目的相关依赖信息以及构建信息，项目的所有相关设置都在这个入口进行，降低了项目管理的复杂度：进行项目中依赖jar版本统一管理，使项目与开发环境（本地配置，开发工具）解耦。与传统项目构建方式相比，maven将对lib的强依赖转换为引用依赖，一定程度上的减少了不同项目对依赖jar的重复添加。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">project1需要使用jstl.jar，project2也需要使用jstl.jar，以往的方式是在2个项目的lib中都放入jstl.jar文件。</span><br><span class="line">也就是说在计算机里会同时有2个一样的jar包（另外可以使用引入的方式避免重复，但一般都不会这样做，因为协作的时候不应该依赖本地环境）。</span><br><span class="line">如果有N个项目，那简直爆炸了，相同jar包被在本机存在了N个。如果使用maven，那么我们只需在配置文件中配置一下就解决了问题，所有的项目都将使用同一个jar，至于删除，那没关系，maven会自动去仓库下载此jar。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>Maven提供了依赖传递的定义，如果你使用一个jar，那么它依赖的其他jar将会自动导入，并且导入的版本是它所需要的正确版本，避免了以往手动添加jar包方式可能造成的不兼容。同时Maven的目录设计将主代码和测试代码分离，打包项目时默认测试不打包，便于项目的开发管理，代码维护。Maven定义了软件开发的生命周期，开发-测试-打包，一个项目发版，都将默认执行测试以确保无误，之后才会打包项目，提高了软件的质量。</p>
<h3 id="前置的概念"><a href="#前置的概念" class="headerlink" title="前置的概念"></a>前置的概念</h3><blockquote>
<ol>
<li>远程仓库：Maven在管理项目时，使用配置文件的方式管理依赖jar，用户在配置文件中定义相关的jar依赖后，Maven将会自动去下载这些jar，下载的服务器即称之为远程仓库</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>本地仓库：Maven从服务器下载下来的jar将会存在本地计算机的一个目录下，这个目录称之为本地仓库，本机所有项目如果pom中有相同的jar依赖，都将会使用本地仓库中的同一个jar。</li>
</ol>
</blockquote>
<h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><blockquote>
<p>主流的IDE都已经集成Maven环境。</p>
</blockquote>
<p>以Windows为例，手动部署Maven：</p>
<blockquote>
<ol>
<li>部署java环境，略。</li>
<li>下载<a href="http://maven.apache.org/download.cgi" title="点击下载">Maven</a></li>
<li>解压，将apache-maven-3.3.9[版本号可能不一样]移动到D盘根目录，重名为maven，全路径如此：”D:\maven”</li>
<li>配置环境变量：新建环境变量M2_HOME=D:\maven，添加环境变量<br>Path=%M2_HOME%\bin,CMD下执行mvn -version 如果有版本等信息输出，说明成功</li>
<li>配置本地仓库：打开D:\maven\conf\settings.xml,找到localRepository节点，将此节点注释去掉，并将值设为我们想要的路径，例如：<localRepository>D:\mavenRepo</localRepository></li>
</ol>
</blockquote>
<blockquote>
<p>settings.xml还有很多其他设置，仅提供参考地址<a href="http://maven.apache.org/settings.html" title="Maven全局配置">Maven全局配置</a></p>
</blockquote>
<h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><p>pom.xml作为项目的管理入口，定义了项目依赖的jar，适用的插件，以及很多其他的常用配置。</p>
<h3 id="pom示例"><a href="#pom示例" class="headerlink" title="pom示例"></a>pom示例</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 基本配置，配置此项目的坐标、版本号、属性、依赖项目定义、使用的插件，父项目以及子项目 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 父项目定义 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;parent&gt;</span></span><br><span class="line"><span class="comment">    &lt;groupId&gt;simple.maven&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">        &lt;artifactId&gt;root&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span></span><br><span class="line"><span class="comment">    &lt;/parent&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目groupId --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>simple.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目artifactId --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目打包方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 子项目 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;modules&gt;</span></span><br><span class="line"><span class="comment">        &lt;module&gt;sub-one&lt;/module&gt;</span></span><br><span class="line"><span class="comment">        &lt;module&gt;sub-two&lt;/module&gt;</span></span><br><span class="line"><span class="comment">    &lt;/modules&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 属性定义，可作为变量引用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义项目打包编码，此编码会被compiler插件定义覆盖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义项目其他属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 依赖项目定义 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 依赖管理，配置在此节点的依赖不会立即下载，只作为版本和项目依赖范围的界定，多数情况下是为了提供给子项目使用，是可选节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 基本配置结束 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 构建设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最终打包出来时的jar名称--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义项目使用的插件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- compiler插件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">showWarnings</span>&gt;</span>true<span class="tag">&lt;/<span class="name">showWarnings</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>$&#123;project.build.sourceEncoding&#125;<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 可选项目信息设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目描述 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>maven入门示例<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目url --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://dr-yanglong.github.io/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目开始时间 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inceptionYear</span>&gt;</span>2016<span class="tag">&lt;/<span class="name">inceptionYear</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目licenses--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;licenses&gt;</span></span><br><span class="line"><span class="comment">    &lt;/licenses&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 组织描述--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">organization</span>&gt;</span><span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发人员描述 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developers</span>&gt;</span><span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 其他项目参与者描述 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contributors</span>&gt;</span><span class="tag">&lt;/<span class="name">contributors</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 环境设置，项目中环境设置会与全局设置做并集，如果有重合，项目设置会覆盖全局设置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目远程依赖和插件仓库设置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;repositories&gt;</span></span><br><span class="line"><span class="comment">      &lt;repository&gt;</span></span><br><span class="line"><span class="comment">        &lt;id&gt;nexus&lt;/id&gt;</span></span><br><span class="line"><span class="comment">        &lt;name&gt;nexus&lt;/name&gt;</span></span><br><span class="line"><span class="comment">        &lt;url&gt;http://IP或域名/nexus/content/groups/public&lt;/url&gt;</span></span><br><span class="line"><span class="comment">        &lt;releases&gt;</span></span><br><span class="line"><span class="comment">          &lt;enabled&gt;true&lt;/enabled&gt;</span></span><br><span class="line"><span class="comment">        &lt;/releases&gt;</span></span><br><span class="line"><span class="comment">        &lt;snapshots&gt;</span></span><br><span class="line"><span class="comment">          &lt;enabled&gt;true&lt;/enabled&gt;</span></span><br><span class="line"><span class="comment">          &lt;updatePolicy&gt;daily&lt;/updatePolicy&gt;</span></span><br><span class="line"><span class="comment">        &lt;/snapshots&gt;</span></span><br><span class="line"><span class="comment">      &lt;/repository&gt;</span></span><br><span class="line"><span class="comment">      &lt;repository&gt;</span></span><br><span class="line"><span class="comment">        &lt;id&gt;Central&lt;/id&gt;</span></span><br><span class="line"><span class="comment">        &lt;name&gt;Maven中央库&lt;/name&gt;</span></span><br><span class="line"><span class="comment">        &lt;url&gt;http://central.maven.org/maven2/&lt;/url&gt;</span></span><br><span class="line"><span class="comment">      &lt;/repository&gt;</span></span><br><span class="line"><span class="comment">    &lt;/repositories&gt;</span></span><br><span class="line"><span class="comment">    &lt;pluginRepositories&gt;</span></span><br><span class="line"><span class="comment">      &lt;pluginRepository&gt;</span></span><br><span class="line"><span class="comment">        &lt;id&gt;nexus&lt;/id&gt;</span></span><br><span class="line"><span class="comment">        &lt;name&gt;nexus&lt;/name&gt;</span></span><br><span class="line"><span class="comment">        &lt;url&gt;http://IP或域名/nexus/content/groups/public&lt;/url&gt;</span></span><br><span class="line"><span class="comment">        &lt;releases&gt;</span></span><br><span class="line"><span class="comment">          &lt;enabled&gt;true&lt;/enabled&gt;</span></span><br><span class="line"><span class="comment">        &lt;/releases&gt;</span></span><br><span class="line"><span class="comment">        &lt;snapshots&gt;</span></span><br><span class="line"><span class="comment">          &lt;enabled&gt;true&lt;/enabled&gt;</span></span><br><span class="line"><span class="comment">          &lt;updatePolicy&gt;daily&lt;/updatePolicy&gt;</span></span><br><span class="line"><span class="comment">        &lt;/snapshots&gt;</span></span><br><span class="line"><span class="comment">      &lt;/pluginRepository&gt;</span></span><br><span class="line"><span class="comment">      &lt;pluginRepository&gt;</span></span><br><span class="line"><span class="comment">        &lt;id&gt;Central&lt;/id&gt;</span></span><br><span class="line"><span class="comment">        &lt;name&gt;Maven中央库&lt;/name&gt;</span></span><br><span class="line"><span class="comment">        &lt;url&gt;http://central.maven.org/maven2/&lt;/url&gt;</span></span><br><span class="line"><span class="comment">      &lt;/pluginRepository&gt;</span></span><br><span class="line"><span class="comment">    &lt;/pluginRepositories&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 部署仓库设置，需要配合settings.xml中的servers设置才能使用 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;distributionManagement&gt;</span></span><br><span class="line"><span class="comment">      &lt;repository&gt;</span></span><br><span class="line"><span class="comment">        &lt;id&gt;my-releases&lt;/id&gt;</span></span><br><span class="line"><span class="comment">        &lt;name&gt;Local Nexus Repository&lt;/name&gt;</span></span><br><span class="line"><span class="comment">        &lt;url&gt;http://IP或域名/nexus/content/repositories/releases/&lt;/url&gt;</span></span><br><span class="line"><span class="comment">      &lt;/repository&gt;</span></span><br><span class="line"><span class="comment">      &lt;snapshotRepository&gt;</span></span><br><span class="line"><span class="comment">        &lt;id&gt;my-snapshots&lt;/id&gt;</span></span><br><span class="line"><span class="comment">        &lt;name&gt;Local Nexus Repository&lt;/name&gt;</span></span><br><span class="line"><span class="comment">        &lt;url&gt;http://IP或域名/nexus/content/repositories/snapshots/&lt;/url&gt;</span></span><br><span class="line"><span class="comment">      &lt;/snapshotRepository&gt;</span></span><br><span class="line"><span class="comment">    &lt;/distributionManagement&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- profile设置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;profiles&gt;&lt;/profiles&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="http://maven.apache.org/pom.html" title="点击前往">pom详细文档</a></p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>依赖在以前的项目中表现为lib中的jar包，在Maven中，称为dependency(依赖)，并在pom.xml文件中配置</p>
<h4 id="依赖的确定"><a href="#依赖的确定" class="headerlink" title="依赖的确定"></a>依赖的确定</h4><blockquote>
<p>依赖坐标</p>
</blockquote>
<p>Maven通常情况下使用3个维度对依赖进行确定：groupId（组织坐标，通常为网址倒写），artifactId（项目坐标，通常为项目名称），version（版本坐标，为项目版本）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.thoughtworks.xstream<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xstream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此配置的意思是，项目依赖于com.thoughtworks.xstream下的1.4.8的xstream项目，最终效果是maven会到本地仓库检查是否有xstrem-1.4.8.jar，如果没有，将会到远程仓库下载到本地仓库。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">maven约定的版本格式：&lt;majorversion&gt;.&lt;minor version&gt;.&lt;incremental version&gt;-&lt;qualifier&gt;</span><br><span class="line"></span><br><span class="line">majorversion：主版本号，阿拉伯数字</span><br><span class="line">minor version：次版本号，阿拉伯数字</span><br><span class="line">incremental version：增量版本号，阿拉伯数字</span><br><span class="line">qualifier：阶段标识，默认为SNAPSHOT，LATEST，RELEASE，可以自行约定。</span><br><span class="line"></span><br><span class="line">！以上版本格式仅仅是约定，并不是规则，可以使用，也可以不使用。</span><br></pre></td></tr></table></figure>

<h4 id="依赖检查"><a href="#依赖检查" class="headerlink" title="依赖检查"></a>依赖检查</h4><p>Maven在添加每一个依赖时，都会检查此依赖的正确性以及此依赖有没有依赖其他依赖。</p>
<blockquote>
<p>依赖的传递</p>
</blockquote>
<p>一个依赖如果还依赖其他依赖，称之为传递依赖：A-&gt;B，B-&gt;C，B-&gt;D，则A-&gt;(B,C,D)。<br>上面的xstream依赖其他的项目，那么就产生了传递依赖，如下，为xstream项目的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xmlpull<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xmlpull<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xpp3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xpp3_min<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么，我们不必再添加以上依赖到项目pom中，Maven会自动将它们下载到本地仓库并作为本项目依赖使用。</p>
<blockquote>
<p>依赖的排除</p>
</blockquote>
<p>当有的传递依赖我们想要自己指定，那么为了不导入不同版本的2个依赖（更多的时候是为了解决冲突和兼容），我们需要使用依赖排除将传递产生的依赖排除掉</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="依赖版本的控制"><a href="#依赖版本的控制" class="headerlink" title="依赖版本的控制"></a>依赖版本的控制</h4><p>有自己项目pom中配置的依赖，有传递依赖，并且仅版本不同，那么如何确定依赖哪一个？</p>
<blockquote>
<p>Maven由最短路径原则确定具体依赖哪一个。<br>如果本地显式依赖了某个jar包，则用本地的。<br>如果本地没有显式依赖，而是通过依赖传递依赖的某个jar包：<br>首先根据最短依赖原则确定；<br>如果路径长度都相同，则根据依赖书写顺序确定。</p>
</blockquote>
<blockquote>
<p>如果有版本不兼容和冲突，还是需要使用依赖排除</p>
</blockquote>
<p>父项目的依赖控制：<br>如果项目有父项目，当项目引入依赖，且此依赖在父项目pomn中的dependencyManagement下的dependencies中定义过，或者在父pom中dependencies中定义过，那么项目可以继承父项目中定义的依赖信息，子项目中除非需要使用此依赖的其他版本，否则不用再明确指定版本，对此依赖的其他配置（如排除，范围等），子项目也会继承。此行为插件也是同理。</p>
<h4 id="依赖的范围scope"><a href="#依赖的范围scope" class="headerlink" title="依赖的范围scope"></a>依赖的范围scope</h4><ul>
<li>compile，缺省值，适用于所有阶段，依赖会打包到项目中，会随着项目一起发布。 </li>
<li>provided，类似compile，期望JDK、容器或使用者会提供这个依赖，依赖不会被打包到项目中。如servlet.jar。 </li>
<li>runtime，只在运行时使用，依赖会打包到项目中，如JDBC驱动，适用运行和测试阶段。 </li>
<li>test，只在测试时使用，用于编译和运行测试代码，依赖不会打包到项目中，不会随项目发布。 </li>
<li>system，类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它，依赖会打包到项目中，某些时候需要特殊配置打包过程。</li>
</ul>
<p>system使用示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.sql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jdbc-stdext<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;java.home&#125;/lib/rt.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>区别仅是多了systemPath节点，此节点的值是jar包的绝对路径。</p>
<h4 id="依赖的分类"><a href="#依赖的分类" class="headerlink" title="依赖的分类"></a>依赖的分类</h4><p>分类是依赖确定的第四个维度。依赖可以区分不同的类型，有的依赖是pom，有的依赖是JNI依赖，而有的依赖针对不同的JDK版本发布了不同的依赖包，因此maven在依赖引入时，提供了<strong>classifier</strong>来区分不同类型的依赖包。如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- linux系统中使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sample<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.60<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>linux<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- windows系统中使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sample<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.60<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>windows<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mac系统中使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sample<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.60<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>mac<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- JDK7使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sample<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.60<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>jdk7<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- JDK8使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sample<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.60<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>jdk8<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- JDK11使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sample<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.60<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>jdk11<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果依赖有系统平台和jdk版本的区分，一般使用version附加jdk版本的方式区分不同的jdk版本。</p>
</blockquote>
<h4 id="Maven反应堆"><a href="#Maven反应堆" class="headerlink" title="Maven反应堆"></a>Maven反应堆</h4><blockquote>
<p>单独拆分出的项目不存在复杂的反应堆，只有父项目通过module引入子项目，子项目通过相对路径或绝对路径或就在父项目目录下才存在复杂的反应堆。</p>
</blockquote>
<p>Maven反应堆是指一个Maven项目所有模块组成的一个构建结构。反应堆包含了各模块之间继承与依赖的关系，从而能够自动计算出合理的模块构建顺序。在复杂的项目中，项目一般分为多个子项目或子模块，并且顶层模块对项目的下层模块有依赖。这种模块间的依赖关系会在Maven反应堆中构成一个有向非循环图(Directed Acyclic Graph, DAG)，各个模块是该图的节点，依赖关系构成了有向边。这个图不允许出现循环，因此，当出现模块A依赖于B，而B又依赖于A 的情况时，Maven就会报错，这个图的作用是让Maven知晓项目的构建顺序。<br>Maven反应堆的实际表现是：如果你对父项目进行构建，那么所有子项目将进行构建。如果子项目间依赖关系是A-&gt;B,B-&gt;C,C-&gt;D,B-&gt;E，如果对A进行构建，项目B,C,D,E也将被构建。你可以手动使用命令选择要构建哪些模块，但不推荐这样做。</p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>Maven提供默认的插件，这些插件分别负责项目不同阶段所需要做的事情。另外可自行配置项目中需要使用的其它插件，比如servlet容器tomcat插件，jetty插件。插件是绑定到Maven生命周期的。</p>
<h4 id="Maven的生命周期"><a href="#Maven的生命周期" class="headerlink" title="Maven的生命周期"></a>Maven的生命周期</h4><p>Maven的生命周期定义了Maven运行时的每一个步骤，让我们无需自行定义，由于是Maven定制，所以不同的项目中生命周期都是一致的，使得我们不必去具体了解各个项目是如何构建的。</p>
<ul>
<li>Clean Lifecycle 在进行真正的构建之前进行一些清理工作。</li>
<li>Default Lifecycle 构建的核心部分，一般称为构建生命周期，验证，编译，测试，打包，部署等等。</li>
<li>Site Lifecycle 生成项目报告，站点，发布站点。</li>
</ul>
<p>MAVEN的默认的构建生命周期：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">validate - 验证项目是否配置正确，如pom文件是否正确，依赖是否正确完备等</span><br><span class="line"></span><br><span class="line">compile - 对项目源代码进行编译</span><br><span class="line"></span><br><span class="line">test - 运行项目单元测试</span><br><span class="line"></span><br><span class="line">package - 将编译好的源代码按需要的格式进行打包，一般是pom、war、jar.</span><br><span class="line"></span><br><span class="line">verify - 对集成测试的结果进行检查，以保证质量达标，需要特殊配置，一般用不到</span><br><span class="line"></span><br><span class="line">install - 安装打包的项目到本地仓库，以供其他项目使用，仅仅是安装到当前主机的本地仓库</span><br><span class="line"></span><br><span class="line">deploy - 复制最终的工程包发布到远程仓库中，共享给其他开发人员和工程，这一步需要配置远程仓库的信息，包括仓库地址，账号密码</span><br></pre></td></tr></table></figure>

<p>三个生命周期完全独立。<a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html" title="完整描述">完整描述</a></p>
<h4 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">showWarnings</span>&gt;</span>true<span class="tag">&lt;/<span class="name">showWarnings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1/manager/text<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">server</span>&gt;</span>mytom<span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span>&gt;</span>/$&#123;build.finalName&#125;<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">update</span>&gt;</span>true<span class="tag">&lt;/<span class="name">update</span>&gt;</span>--&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">port</span>&gt;</span>8888<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">update</span>&gt;</span>true<span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用configuration配置插件的自定义设置。</p>
<h4 id="默认的插件"><a href="#默认的插件" class="headerlink" title="默认的插件"></a>默认的插件</h4><p>clean：用于清理项目<br>compiler：用于编译<br>install：用于打包<br>deploy：用于部署    </p>
<h4 id="运行插件"><a href="#运行插件" class="headerlink" title="运行插件"></a>运行插件</h4><p>首先了解插件的运行命令，例如tomcat7插件的运行命令为run，则</p>
<blockquote>
<p>mvn tomcat7:run</p>
</blockquote>
<p>运行tomcat7插件。插件还有phase和goals配置，涉及到Maven的不同生命周期中的不同阶段（phase），goals是插件定义的不同的功能。具体参考生命周期完整描述及插件使用说明。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL配置参数</title>
    <url>/2017/05/09/mysql-config/</url>
    <content><![CDATA[<h2 id="mysql参数说明"><a href="#mysql参数说明" class="headerlink" title="mysql参数说明"></a>mysql参数说明</h2><p>转载自<a href="https://blog.linuxeye.cn/379.html">MySQL性能调优my.cnf详解 | Linux运维笔记</a></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[client]  </span><br><span class="line">port = 3306  </span><br><span class="line">socket = /tmp/mysql.sock  </span><br><span class="line">  </span><br><span class="line">[mysqld]  </span><br><span class="line">port = 3306  </span><br><span class="line">socket = /tmp/mysql.sock  </span><br><span class="line">  </span><br><span class="line">basedir = /usr/local/mysql  </span><br><span class="line">datadir = /data/mysql  </span><br><span class="line">pid-file = /data/mysql/mysql.pid  </span><br><span class="line">user = mysql  </span><br><span class="line">bind-address = 0.0.0.0  </span><br><span class="line">server-id = 1 #表示是本机的序号为1,一般来讲就是master的意思  </span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">skip-name-resolve  </span><br><span class="line"># 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，  </span><br><span class="line"># 则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求  </span><br><span class="line">  </span><br><span class="line">#skip-networking  </span><br><span class="line">  </span><br><span class="line">back_log = 600  </span><br><span class="line"># MySQL能有的连接数量。当主要MySQL线程在一个很短时间内得到非常多的连接请求，这就起作用，  </span><br><span class="line"># 然后主线程花些时间(尽管很短)检查连接并且启动一个新线程。back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。  </span><br><span class="line"># 如果期望在一个短时间内有很多连接，你需要增加它。也就是说，如果MySQL的连接数据达到max_connections时，新来的请求将会被存在堆栈中，  </span><br><span class="line"># 以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。  </span><br><span class="line"># 另外，这值（back_log）限于您的操作系统对到来的TCP/IP连接的侦听队列的大小。  </span><br><span class="line"># 你的操作系统在这个队列大小上有它自己的限制（可以检查你的OS文档找出这个变量的最大值），试图设定back_log高于你的操作系统的限制将是无效的。  </span><br><span class="line">  </span><br><span class="line">max_connections = 1000  </span><br><span class="line"># MySQL的最大连接数，如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，当然这建立在机器能支撑的情况下，因为如果连接数越多，介于MySQL会为每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。可以过&#x27;conn%&#x27;通配符查看当前状态的连接数量，以定夺该值的大小。  </span><br><span class="line">  </span><br><span class="line">max_connect_errors = 6000  </span><br><span class="line"># 对于同一主机，如果有超出该参数值个数的中断错误连接，则该主机将被禁止连接。如需对该主机进行解禁，执行：FLUSH HOST。  </span><br><span class="line">  </span><br><span class="line">open_files_limit = 65535  </span><br><span class="line"># MySQL打开的文件描述符限制，默认最小1024;当open_files_limit没有被配置的时候，比较max_connections*5和ulimit -n的值，哪个大用哪个，  </span><br><span class="line"># 当open_file_limit被配置的时候，比较open_files_limit和max_connections*5的值，哪个大用哪个。  </span><br><span class="line">  </span><br><span class="line">table_open_cache = 128  </span><br><span class="line"># MySQL每打开一个表，都会读入一些数据到table_open_cache缓存中，当MySQL在这个缓存中找不到相应信息时，才会去磁盘上读取。默认值64  </span><br><span class="line"># 假定系统有200个并发连接，则需将此参数设置为200*N(N为每个连接所需的文件描述符数目)；  </span><br><span class="line"># 当把table_open_cache设置为很大时，如果系统处理不了那么多文件描述符，那么就会出现客户端失效，连接不上  </span><br><span class="line">  </span><br><span class="line">max_allowed_packet = 4M  </span><br><span class="line"># 接受的数据包大小；增加该变量的值十分安全，这是因为仅当需要时才会分配额外内存。例如，仅当你发出长查询或MySQLd必须返回大的结果行时MySQLd才会分配更多内存。  </span><br><span class="line"># 该变量之所以取较小默认值是一种预防措施，以捕获客户端和服务器之间的错误信息包，并确保不会因偶然使用大的信息包而导致内存溢出。  </span><br><span class="line">  </span><br><span class="line">binlog_cache_size = 1M  </span><br><span class="line"># 一个事务，在没有提交的时候，产生的日志，记录到Cache中；等到事务提交需要提交的时候，则把日志持久化到磁盘。默认binlog_cache_size大小32K  </span><br><span class="line">  </span><br><span class="line">max_heap_table_size = 8M  </span><br><span class="line"># 定义了用户可以创建的内存表(memory table)的大小。这个值用来计算内存表的最大行数值。这个变量支持动态改变  </span><br><span class="line">  </span><br><span class="line">tmp_table_size = 16M  </span><br><span class="line"># MySQL的heap（堆积）表缓冲大小。所有联合在一个DML指令内完成，并且大多数联合甚至可以不用临时表即可以完成。  </span><br><span class="line"># 大多数临时表是基于内存的(HEAP)表。具有大的记录长度的临时表 (所有列的长度的和)或包含BLOB列的表存储在硬盘上。  </span><br><span class="line"># 如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。还可以通过设置tmp_table_size选项来增加临时表的大小。也就是说，如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果  </span><br><span class="line">  </span><br><span class="line">read_buffer_size = 2M  </span><br><span class="line"># MySQL读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySQL会为它分配一段内存缓冲区。read_buffer_size变量控制这一缓冲区的大小。  </span><br><span class="line"># 如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能  </span><br><span class="line">  </span><br><span class="line">read_rnd_buffer_size = 8M  </span><br><span class="line"># MySQL的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，  </span><br><span class="line"># MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大  </span><br><span class="line">  </span><br><span class="line">sort_buffer_size = 8M  </span><br><span class="line"># MySQL执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。  </span><br><span class="line"># 如果不能，可以尝试增加sort_buffer_size变量的大小  </span><br><span class="line">  </span><br><span class="line">join_buffer_size = 8M  </span><br><span class="line"># 联合查询操作所能使用的缓冲区大小，和sort_buffer_size一样，该参数对应的分配内存也是每连接独享  </span><br><span class="line">  </span><br><span class="line">thread_cache_size = 8  </span><br><span class="line"># 这个值（默认8）表示可以重新利用保存在缓存中线程的数量，当断开连接时如果缓存中还有空间，那么客户端的线程将被放到缓存中，  </span><br><span class="line"># 如果线程重新被请求，那么请求将从缓存中读取,如果缓存中是空的或者是新的请求，那么这个线程将被重新创建,如果有很多新的线程，  </span><br><span class="line"># 增加这个值可以改善系统性能.通过比较Connections和Threads_created状态的变量，可以看到这个变量的作用。(–&gt;表示要调整的值)  </span><br><span class="line"># 根据物理内存设置规则如下：  </span><br><span class="line"># 1G  —&gt; 8  </span><br><span class="line"># 2G  —&gt; 16  </span><br><span class="line"># 3G  —&gt; 32  </span><br><span class="line"># 大于3G  —&gt; 64  </span><br><span class="line">  </span><br><span class="line">query_cache_size = 8M  </span><br><span class="line">#MySQL的查询缓冲大小（从4.0.1开始，MySQL提供了查询缓冲机制）使用查询缓冲，MySQL将SELECT语句和查询结果存放在缓冲区中，  </span><br><span class="line"># 今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。根据MySQL用户手册，使用查询缓冲最多可以达到238%的效率。  </span><br><span class="line"># 通过检查状态值&#x27;Qcache_%&#x27;，可以知道query_cache_size设置是否合理：如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，  </span><br><span class="line"># 如果Qcache_hits的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果Qcache_hits的值不大，则表明你的查询重复率很低，  </span><br><span class="line"># 这种情况下使用查询缓冲反而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入SQL_NO_CACHE可以明确表示不使用查询缓冲  </span><br><span class="line">  </span><br><span class="line">query_cache_limit = 2M  </span><br><span class="line">#指定单个查询能够使用的缓冲区大小，默认1M  </span><br><span class="line">  </span><br><span class="line">key_buffer_size = 4M  </span><br><span class="line">#指定用于索引的缓冲区大小，增加它可得到更好处理的索引(对所有读和多重写)，到你能负担得起那样多。如果你使它太大，  </span><br><span class="line"># 系统将开始换页并且真的变慢了。对于内存在4GB左右的服务器该参数可设置为384M或512M。通过检查状态值Key_read_requests和Key_reads，  </span><br><span class="line"># 可以知道key_buffer_size设置是否合理。比例key_reads/key_read_requests应该尽可能的低，  </span><br><span class="line"># 至少是1:100，1:1000更好(上述状态值可以使用SHOW STATUS LIKE &#x27;key_read%&#x27;获得)。注意：该参数值设置的过大反而会是服务器整体效率降低  </span><br><span class="line">  </span><br><span class="line">ft_min_word_len = 4  </span><br><span class="line"># 分词词汇最小长度，默认4  </span><br><span class="line">  </span><br><span class="line">transaction_isolation = REPEATABLE-READ  </span><br><span class="line"># MySQL支持4种事务隔离级别，他们分别是：  </span><br><span class="line"># READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE.  </span><br><span class="line"># 如没有指定，MySQL默认采用的是REPEATABLE-READ，ORACLE默认的是READ-COMMITTED  </span><br><span class="line">  </span><br><span class="line">log_bin = mysql-bin  </span><br><span class="line">binlog_format = mixed  </span><br><span class="line">expire_logs_days = 30 #超过30天的binlog删除  </span><br><span class="line">  </span><br><span class="line">log_error = /data/mysql/mysql-error.log #错误日志路径  </span><br><span class="line">slow_query_log = 1  </span><br><span class="line">long_query_time = 1 #慢查询时间 超过1秒则为慢查询  </span><br><span class="line">slow_query_log_file = /data/mysql/mysql-slow.log  </span><br><span class="line">  </span><br><span class="line">performance_schema = 0  </span><br><span class="line">explicit_defaults_for_timestamp  </span><br><span class="line">  </span><br><span class="line">#lower_case_table_names = 1 #不区分大小写  </span><br><span class="line">  </span><br><span class="line">skip-external-locking #MySQL选项以避免外部锁定。该选项默认开启  </span><br><span class="line">  </span><br><span class="line">default-storage-engine = InnoDB #默认存储引擎  </span><br><span class="line">  </span><br><span class="line">innodb_file_per_table = 1  </span><br><span class="line"># InnoDB为独立表空间模式，每个数据库的每个表都会生成一个数据空间  </span><br><span class="line"># 独立表空间优点：  </span><br><span class="line"># 1．每个表都有自已独立的表空间。  </span><br><span class="line"># 2．每个表的数据和索引都会存在自已的表空间中。  </span><br><span class="line"># 3．可以实现单表在不同的数据库中移动。  </span><br><span class="line"># 4．空间可以回收（除drop table操作处，表空不能自已回收）  </span><br><span class="line"># 缺点：  </span><br><span class="line"># 单表增加过大，如超过100G  </span><br><span class="line"># 结论：  </span><br><span class="line"># 共享表空间在Insert操作上少有优势。其它都没独立表空间表现好。当启用独立表空间时，请合理调整：innodb_open_files  </span><br><span class="line">  </span><br><span class="line">innodb_open_files = 500  </span><br><span class="line"># 限制Innodb能打开的表的数据，如果库里的表特别多的情况，请增加这个。这个值默认是300  </span><br><span class="line">  </span><br><span class="line">innodb_buffer_pool_size = 64M  </span><br><span class="line"># InnoDB使用一个缓冲池来保存索引和原始数据, 不像MyISAM.  </span><br><span class="line"># 这里你设置越大,你在存取表里面数据时所需要的磁盘I/O越少.  </span><br><span class="line"># 在一个独立使用的数据库服务器上,你可以设置这个变量到服务器物理内存大小的80%  </span><br><span class="line"># 不要设置过大,否则,由于物理内存的竞争可能导致操作系统的换页颠簸.  </span><br><span class="line"># 注意在32位系统上你每个进程可能被限制在 2-3.5G 用户层面内存限制,  </span><br><span class="line"># 所以不要设置的太高.  </span><br><span class="line">  </span><br><span class="line">innodb_write_io_threads = 4  </span><br><span class="line">innodb_read_io_threads = 4  </span><br><span class="line"># innodb使用后台线程处理数据页上的读写 I/O(输入输出)请求,根据你的 CPU 核数来更改,默认是4  </span><br><span class="line"># 注:这两个参数不支持动态改变,需要把该参数加入到my.cnf里，修改完后重启MySQL服务,允许值的范围从 1-64  </span><br><span class="line">  </span><br><span class="line">innodb_thread_concurrency = 0  </span><br><span class="line"># 默认设置为 0,表示不限制并发数，这里推荐设置为0，更好去发挥CPU多核处理能力，提高并发量  </span><br><span class="line">  </span><br><span class="line">innodb_purge_threads = 1  </span><br><span class="line"># InnoDB中的清除操作是一类定期回收无用数据的操作。在之前的几个版本中，清除操作是主线程的一部分，这意味着运行时它可能会堵塞其它的数据库操作。  </span><br><span class="line"># 从MySQL5.5.X版本开始，该操作运行于独立的线程中,并支持更多的并发数。用户可通过设置innodb_purge_threads配置参数来选择清除操作是否使用单  </span><br><span class="line"># 独线程,默认情况下参数设置为0(不使用单独线程),设置为 1 时表示使用单独的清除线程。建议为1  </span><br><span class="line">  </span><br><span class="line">innodb_flush_log_at_trx_commit = 2  </span><br><span class="line"># 0：如果innodb_flush_log_at_trx_commit的值为0,log buffer每秒就会被刷写日志文件到磁盘，提交事务的时候不做任何操作（执行是由mysql的master thread线程来执行的。  </span><br><span class="line"># 主线程中每秒会将重做日志缓冲写入磁盘的重做日志文件(REDO LOG)中。不论事务是否已经提交）默认的日志文件是ib_logfile0,ib_logfile1  </span><br><span class="line"># 1：当设为默认值1的时候，每次提交事务的时候，都会将log buffer刷写到日志。  </span><br><span class="line"># 2：如果设为2,每次提交事务都会写日志，但并不会执行刷的操作。每秒定时会刷到日志文件。要注意的是，并不能保证100%每秒一定都会刷到磁盘，这要取决于进程的调度。  </span><br><span class="line"># 每次事务提交的时候将数据写入事务日志，而这里的写入仅是调用了文件系统的写入操作，而文件系统是有 缓存的，所以这个写入并不能保证数据已经写入到物理磁盘  </span><br><span class="line"># 默认值1是为了保证完整的ACID。当然，你可以将这个配置项设为1以外的值来换取更高的性能，但是在系统崩溃的时候，你将会丢失1秒的数据。  </span><br><span class="line"># 设为0的话，mysqld进程崩溃的时候，就会丢失最后1秒的事务。设为2,只有在操作系统崩溃或者断电的时候才会丢失最后1秒的数据。InnoDB在做恢复的时候会忽略这个值。  </span><br><span class="line"># 总结  </span><br><span class="line"># 设为1当然是最安全的，但性能页是最差的（相对其他两个参数而言，但不是不能接受）。如果对数据一致性和完整性要求不高，完全可以设为2，如果只最求性能，例如高并发写的日志服务器，设为0来获得更高性能  </span><br><span class="line">  </span><br><span class="line">innodb_log_buffer_size = 2M  </span><br><span class="line"># 此参数确定些日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，但意外的故障将会丢失数据。MySQL开发人员建议设置为1－8M之间  </span><br><span class="line">  </span><br><span class="line">innodb_log_file_size = 32M  </span><br><span class="line"># 此参数确定数据日志文件的大小，更大的设置可以提高性能，但也会增加恢复故障数据库所需的时间  </span><br><span class="line">  </span><br><span class="line">innodb_log_files_in_group = 3  </span><br><span class="line"># 为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3  </span><br><span class="line">  </span><br><span class="line">innodb_max_dirty_pages_pct = 90  </span><br><span class="line"># innodb主线程刷新缓存池中的数据，使脏数据比例小于90%  </span><br><span class="line">  </span><br><span class="line">innodb_lock_wait_timeout = 120   </span><br><span class="line"># InnoDB事务在被回滚之前可以等待一个锁定的超时秒数。InnoDB在它自己的锁定表中自动检测事务死锁并且回滚事务。InnoDB用LOCK TABLES语句注意到锁定设置。默认值是50秒  </span><br><span class="line">  </span><br><span class="line">bulk_insert_buffer_size = 8M  </span><br><span class="line"># 批量插入缓存大小， 这个参数是针对MyISAM存储引擎来说的。适用于在一次性插入100-1000+条记录时， 提高效率。默认值是8M。可以针对数据量的大小，翻倍增加。  </span><br><span class="line">  </span><br><span class="line">myisam_sort_buffer_size = 8M  </span><br><span class="line"># MyISAM设置恢复表之时使用的缓冲区的尺寸，当在REPAIR TABLE或用CREATE INDEX创建索引或ALTER TABLE过程中排序 MyISAM索引分配的缓冲区  </span><br><span class="line">  </span><br><span class="line">myisam_max_sort_file_size = 10G  </span><br><span class="line"># 如果临时文件会变得超过索引，不要使用快速排序索引方法来创建一个索引。注释：这个参数以字节的形式给出  </span><br><span class="line">  </span><br><span class="line">myisam_repair_threads = 1  </span><br><span class="line"># 如果该值大于1，在Repair by sorting过程中并行创建MyISAM表索引(每个索引在自己的线程内)    </span><br><span class="line">  </span><br><span class="line">interactive_timeout = 28800  </span><br><span class="line"># 服务器关闭交互式连接前等待活动的秒数。交互式客户端定义为在mysql_real_connect()中使用CLIENT_INTERACTIVE选项的客户端。默认值：28800秒（8小时）  </span><br><span class="line">  </span><br><span class="line">wait_timeout = 28800  </span><br><span class="line"># 服务器关闭非交互连接之前等待活动的秒数。在线程启动时，根据全局wait_timeout值或全局interactive_timeout值初始化会话wait_timeout值，  </span><br><span class="line"># 取决于客户端类型(由mysql_real_connect()的连接选项CLIENT_INTERACTIVE定义)。参数默认值：28800秒（8小时）  </span><br><span class="line"># MySQL服务器所支持的最大连接数是有上限的，因为每个连接的建立都会消耗内存，因此我们希望客户端在连接到MySQL Server处理完相应的操作后，  </span><br><span class="line"># 应该断开连接并释放占用的内存。如果你的MySQL Server有大量的闲置连接，他们不仅会白白消耗内存，而且如果连接一直在累加而不断开，  </span><br><span class="line"># 最终肯定会达到MySQL Server的连接上限数，这会报&#x27;too many connections&#x27;的错误。对于wait_timeout的值设定，应该根据系统的运行情况来判断。  </span><br><span class="line"># 在系统运行一段时间后，可以通过show processlist命令查看当前系统的连接状态，如果发现有大量的sleep状态的连接进程，则说明该参数设置的过大，  </span><br><span class="line"># 可以进行适当的调整小些。要同时设置interactive_timeout和wait_timeout才会生效。  </span><br><span class="line">  </span><br><span class="line">[mysqldump]  </span><br><span class="line">quick  </span><br><span class="line">max_allowed_packet = 16M #服务器发送和接受的最大包长度  </span><br><span class="line">  </span><br><span class="line">[myisamchk]  </span><br><span class="line">key_buffer_size = 8M  </span><br><span class="line">sort_buffer_size = 8M  </span><br><span class="line">read_buffer = 4M  </span><br><span class="line">write_buffer = 4M  </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper第一课</title>
    <url>/2016/04/03/zk-1/</url>
    <content><![CDATA[<h2 id="一、什么是Zookeeper，作用是什么。"><a href="#一、什么是Zookeeper，作用是什么。" class="headerlink" title="一、什么是Zookeeper，作用是什么。"></a>一、什么是Zookeeper，作用是什么。</h2><h3 id="zookeeper是什么："><a href="#zookeeper是什么：" class="headerlink" title="zookeeper是什么："></a>zookeeper是什么：</h3><p>简而言之，zookeeper是java语言编写的，属于Hadoop的一个子项目，是一个开源的、高性能的、分布式的、应用协调服务。</p>
<h3 id="zookeeper能干什么："><a href="#zookeeper能干什么：" class="headerlink" title="zookeeper能干什么："></a>zookeeper能干什么：</h3><p>zookeeper作为hadoop的子项目，在hadoop中扮演着指挥员的作用，保证集群稳定运行，资源有序调度。</p>
<h4 id="zookeeper的作用"><a href="#zookeeper的作用" class="headerlink" title="zookeeper的作用"></a>zookeeper的作用</h4><h5 id="集群管理、发布订阅"><a href="#集群管理、发布订阅" class="headerlink" title="集群管理、发布订阅"></a>集群管理、发布订阅</h5><blockquote>
<p>名字服务(NameService) </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">分布式应用中，通常需要一套完备的命令机制，既能产生唯一的标识，又方便人识别和记忆。 我们知道，每个ZNode都可以由其路径唯一标识，路径本身也比较简洁直观，另外ZNode上还可以存储少量数据，这些都是实现统一的 NameService的基础。下面以在HDFS中实现NameService为例，来说明实现NameService的基本布骤:</span><br><span class="line">目标：通过简单的名字来访问指定的HDFS机群</span><br><span class="line">定义命名规则：这里要做到简洁易记忆。</span><br><span class="line">下面是一种可选的方案： [serviceScheme://][zkCluster]-[clusterName]，比如hdfs://lgprc-example/表示基于 lgprc ZooKeeper集群的用来做example的HDFS集群。</span><br><span class="line">配置DNS映射: 将zkCluster的标识lgprc通过DNS解析到对应的ZooKeeper集群的地址</span><br><span class="line">创建ZNode: 在对应的ZooKeeper上创建/NameService/hdfs/lgprc-example结点，将HDFS的配置文件存储于该结点下</span><br><span class="line">用户程序要访问hdfs://lgprc-example/的HDFS集群，首先通过DNS找到lgprc的ZooKeeper机群的地址，然后在 ZooKeeper的/NameService/hdfs/lgprc-example结点中读取到HDFS的配置，进而根据得到的配置，得到HDFS的实际访问入口</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置管理</p>
</blockquote>
<p>在分布式系统中，有很多节点的配置是一样的，如果每个节点维护一个配置，当改动是需要一个一个的修改，不仅低效而且造成服务可靠性降低，通过zk可以很容易解决这样的问题，配置集中存放在zk的一个node中，所有用到此配置的节点watch此node，当启动时拉取配置，当配置修改时得到通知更新配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">组员管理(Group Membership) </span><br><span class="line">在典型的Master-Slave结构的分布式系统中，Master需要作为“总管”来管理所有的Slave, 当有Slave加入，或者有Slave宕机，Master都需要感知到这个事情，然后作出对应的调整，以便不影响整个集群对外提供服务。以HBase为 例，HMaster管理了所有的RegionServer，当有新的RegionServer加入的时候，HMaster需要分配一些Region到该 RegionServer上去，让其提供服务；当有RegionServer宕机时，HMaster需要将该RegionServer之前服务的 Region都重新分配到当前正在提供服务的其它RegionServer上，以便不影响客户端的正常访问。下面是这种场景下使用ZooKeeper的基本步骤：</span><br><span class="line">Master在ZooKeeper上创建/service/slaves结点，并设置对该结点的Watcher</span><br><span class="line">每个Slave在启动成功后，创建唯一标识自己的临时性(Ephemeral)结点/service/slaves/<span class="variable">$&#123;slave_id&#125;</span>，并将自己地址(ip/port)等相关信息写入该结点</span><br><span class="line">Master收到有新子结点加入的通知后，做相应的处理</span><br><span class="line">如果有Slave宕机，由于它所对应的结点是临时性结点，在它的Session超时后，ZooKeeper会自动删除该结点</span><br><span class="line">Master收到有子结点消失的通知，做相应的处理</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<blockquote>
<p>发布订阅 </p>
</blockquote>
<p>watch一个节点，节点信息变更会得到通知。</p>
<blockquote>
<p>分布式锁服务  </p>
</blockquote>
<blockquote>
<ol>
<li>简单互斥锁(Simple Lock)<br>我们知识，在传统的应用程序中，线程、进程的同步，都可以通过操作系统提供的机制来完成。但是在分布式系统中，多个进程之间的同步，操作系统层面就无能为 力了。这时候就需要像ZooKeeper这样的分布式的协调(Coordination)服务来协助完成同步，下面是用ZooKeeper实现简单的互斥 锁的步骤，这个可以和线程间同步的mutex做类比来理解：<br>多个进程尝试去在指定的目录下去创建一个临时性(Ephemeral)结点 /locks/my_lock<br>ZooKeeper能保证，只会有一个进程成功创建该结点，创建结点成功的进程就是抢到锁的进程，假设该进程为A<br>其它进程都对/locks/my_lock进行Watch<br>当 A进程不再需要锁，可以显式删除/locks/my_lock释放锁；或者是A进程宕机后Session超时，ZooKeeper系统自动删除 /locks/my_lock结点释放锁。此时，其它进程就会收到ZooKeeper的通知，并尝试去创建/locks/my_lock抢锁，如此循环反 复<br>互斥锁(Simple Lock without Herd Effect)<br>上一节的例子中有一个问题，每次抢锁都会有大量的进程去竞争，会造成羊群效应(Herd Effect)，为了解决这个问题，我们可以通过下面的步骤来改进上述过程：<br>每个进程都在ZooKeeper上创建一个临时的顺序结点(Ephemeral Sequential) /locks/lock_${seq}<br>${seq}最小的为当前的持锁者(${seq}是ZooKeeper生成的Sequenctial Number)<br>其它进程都对只watch比它次小的进程对应的结点，比如2 watch 1, 3 watch 2, 以此类推<br>当前持锁者释放锁后，比它次大的进程就会收到ZooKeeper的通知，它成为新的持锁者，如此循环反复<br>这里需要补充一点，通常在分布式系统中用ZooKeeper来做Leader Election(选主)就是通过上面的机制来实现的，这里的持锁者就是当前的“主”。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>读写锁(Read/Write Lock)<br>我们知道，读写锁跟互斥锁相比不同的地方是，它分成了读和写两种模式，多个读可以并发执行，但写和读、写都互斥，不能同时执行行。利用ZooKeeper，在上面的基础上，稍做修改也可以实现传统的读写锁的语义，下面是基本的步骤:<br>每个进程都在ZooKeeper上创建一个临时的顺序结点(Ephemeral Sequential) /locks/lock_${seq}<br>${seq}最小的一个或多个结点为当前的持锁者，多个是因为多个读可以并发。需要写锁的进程，Watch比它次小的进程对应的结点，需要读锁的进程，Watch比它小的最后一个写进程对应的结点。当前结点释放锁后，所有Watch该结点的进程都会被通知到，他们成为新的持锁者，如此循环反复同步</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>屏障(Barrier)<br>在分布式系统中，屏障是这样一种语义: 客户端需要等待多个进程完成各自的任务，然后才能继续往前进行下一步。下用是用ZooKeeper来实现屏障的基本步骤：<br>Client在ZooKeeper上创建屏障结点/barrier/my_barrier，并启动执行各个任务的进程<br>Client通过exist()来Watch /barrier/my_barrier结点<br>每个任务进程在完成任务后，去检查是否达到指定的条件，如果没达到就啥也不做，如果达到了就把/barrier/my_barrier结点删除<br>Client收到/barrier/my_barrier被删除的通知，屏障消失，继续下一步任务。</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>双屏障(Double Barrier)<br>双屏障是这样一种语义: 它可以用来同步一个任务的开始和结束，当有足够多的进程进入屏障后，才开始执行任务；当所有的进程都执行完各自的任务后，屏障才撤销。下面是用ZooKeeper来实现双屏障的基本步骤：<br>进入屏障：<br>Client Watch /barrier/ready结点, 通过判断该结点是否存在来决定是否启动任务<br>每个任务进程进入屏障时创建一个临时结点/barrier/process/${process_id}，然后检查进入屏障的结点数是否达到指定的值，如果达到了指定的值，就创建一个/barrier/ready结点，否则继续等待<br>Client收到/barrier/ready创建的通知，就启动任务执行过程<br>离开屏障：<br>Client Watch /barrier/process，如果其没有子结点，就可以认为任务执行结束，可以离开屏障<br>每个任务进程执行任务结束后，都需要删除自己对应的结点/barrier/process/${process_id}</li>
</ol>
</blockquote>
<blockquote>
<p>选主</p>
</blockquote>
<p>见互斥锁</p>
<h2 id="二、Zookeeper安装和运行"><a href="#二、Zookeeper安装和运行" class="headerlink" title="二、Zookeeper安装和运行"></a>二、Zookeeper安装和运行</h2><h3 id="Windows下安装运行zookeeper"><a href="#Windows下安装运行zookeeper" class="headerlink" title="Windows下安装运行zookeeper"></a>Windows下安装运行zookeeper</h3><p><span id="windows"><a href="#linux">前往查看linux下安装运行</a></span></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>到<a href="'http://zookeeper.apache.org/releases.html#download'" title="点击前往">官网</a>下载zookeeper。解压。本机使用3.5.1版本。<br>安装JDK，<strong>此处注意JDK安装不用使用默认目录并且安装的目录不能有空格的目录名</strong>否则Zookeeper不能正确识别JAVA_HOME。会报以下错误</p>
<blockquote>
<p>JAVA_HOME is incorrectly set.</p>
</blockquote>
<p>这个错误在zkEnv.cmd中抛出。<br>JDK安装好后，需要设置环境变量。此处安装在<strong>D:\Java\jdk</strong></p>
<blockquote>
<ol>
<li>JAVA_HOME:D:\Java\jdk</li>
<li>CLASS_PATH:%JAVA_HOME%\lib</li>
<li>Path:%JAVA_HOME%\bin\java.exe</li>
</ol>
</blockquote>
<p>注意Path设置时最好带上java.exe。<br>可选的环境变量为Zookeeper的环境变量设置，此处略。<br>验证：</p>
<blockquote>
<p>java -version</p>
</blockquote>
<p>配置配置文件：</p>
<blockquote>
<p>复制zookeeper目录conf下zoo_sample.cfg改名为zoo.cfg</p>
</blockquote>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>打开zookeeper目录下的bin目录，运行<strong>zkServer.cmd</strong>即可启动服务端。输出类似信息：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">WINDOWS</span>\<span class="title">system32</span>&gt;<span class="title">call</span> <span class="title">D</span>:\<span class="title">Java</span>\<span class="title">jdk</span>\<span class="title">bin</span>\<span class="title">java</span> &quot;-<span class="title">Dzookeeper.log.dir</span>=<span class="title">E</span>:\<span class="title">zookeeper</span>-3.5.1-<span class="title">alpha</span>\<span class="title">bin</span>\..\<span class="title">logs</span>&quot; &quot;-<span class="title">Dzookeeper.root.logger</span>=<span class="title">INFO</span>,<span class="title">CONSOLE</span>&quot; &quot;-<span class="title">Dzookeeper.log.file</span>=<span class="title">zookeeper</span>-<span class="title">lenovo</span>-<span class="title">server</span>-<span class="title">LENOVO</span>-<span class="title">PC.log</span>&quot; &quot;-<span class="title">XX</span>:+<span class="title">HeapDumpOnOutOfMemoryError</span>&quot; &quot;-<span class="title">XX:OnOutOfMemoryError</span>=<span class="title">cmd</span> /<span class="title">c</span> <span class="title">taskkill</span> /<span class="title">pid</span> %%<span class="title">p</span> /<span class="title">t</span> /<span class="title">f</span>&quot; -<span class="title">cp</span> &quot;<span class="title">E</span>:\<span class="title">zookeeper</span>-3.5.1-<span class="title">alpha</span>\<span class="title">bin</span>\..\<span class="title">build</span>\<span class="title">classes</span>;<span class="title">E</span>:\<span class="title">zookeeper</span>-3.5.1-<span class="title">alpha</span>\<span class="title">bin</span>\..\<span class="title">build</span>\<span class="title">lib</span>\*;<span class="title">E</span>:\<span class="title">zookeeper</span>-3.5.1-<span class="title">alpha</span>\<span class="title">bin</span>\..\*;<span class="title">E</span>:\<span class="title">zookeeper</span>-3.5.1-<span class="title">alpha</span>\<span class="title">bin</span>\..\<span class="title">lib</span>\*;<span class="title">E</span>:\<span class="title">zookeeper</span>-3.5.1-<span class="title">alpha</span>\<span class="title">bin</span>\..\<span class="title">conf</span>&quot; <span class="title">org.apache.zookeeper.server.quorum.QuorumPeerMain</span> &quot;<span class="title">E</span>:\<span class="title">zookeeper</span>-3.5.1-<span class="title">alpha</span>\<span class="title">bin</span>\..\<span class="title">conf</span>\<span class="title">zoo.cfg</span>&quot;</span></span><br><span class="line"><span class="function">2015-12-16 09:16:40,031 [<span class="title">myid</span>:] - <span class="title">INFO</span>  [<span class="title">main:QuorumPeerConfig</span>@114] - <span class="title">Reading</span> <span class="title">configuration</span> <span class="title">from</span>: <span class="title">E</span>:\<span class="title">zookeeper</span>-3.5.1-<span class="title">alpha</span>\<span class="title">bin</span>\..\<span class="title">conf</span>\<span class="title">zoo.cfg</span></span></span><br><span class="line"><span class="function">2015-12-16 09:16:40,046 [<span class="title">myid</span>:] - <span class="title">INFO</span>  [<span class="title">main:QuorumPeerConfig</span>@316] - <span class="title">clientPortAddress</span> <span class="title">is</span> 0.0.0.0/0.0.0.0:2181</span></span><br><span class="line"><span class="function">2015-12-16 09:16:40,046 [<span class="title">myid</span>:] - <span class="title">INFO</span>  [<span class="title">main:QuorumPeerConfig</span>@320] - <span class="title">secureClientPort</span> <span class="title">is</span> <span class="title">not</span> <span class="title">set</span></span></span><br><span class="line"><span class="function">2015-12-16 09:16:40,046 [<span class="title">myid</span>:] - <span class="title">INFO</span>  [<span class="title">main:DatadirCleanupManager</span>@78] - <span class="title">autopurge.snapRetainCount</span> <span class="title">set</span> <span class="title">to</span> 3</span></span><br><span class="line"><span class="function">2015-12-16 09:16:40,046 [<span class="title">myid</span>:] - <span class="title">INFO</span>  [<span class="title">main:DatadirCleanupManager</span>@79] - <span class="title">autopurge.purgeInterval</span> <span class="title">set</span> <span class="title">to</span> 0</span></span><br><span class="line"><span class="function">2015-12-16 09:16:40,046 [<span class="title">myid</span>:] - <span class="title">INFO</span>  [<span class="title">main:DatadirCleanupManager</span>@101] - <span class="title">Purge</span> <span class="title">task</span> <span class="title">is</span> <span class="title">not</span> <span class="title">scheduled</span>.</span></span><br><span class="line"><span class="function">2015-12-16 09:16:40,046 [<span class="title">myid</span>:] - <span class="title">WARN</span>  [<span class="title">main:QuorumPeerMain</span>@122] - <span class="title">Either</span> <span class="title">no</span> <span class="title">config</span> <span class="title">or</span> <span class="title">no</span> <span class="title">quorum</span> <span class="title">defined</span> <span class="title">in</span> <span class="title">config</span>, <span class="title">running</span>  <span class="title">in</span> <span class="title">standalone</span> <span class="title">mode</span></span></span><br><span class="line"><span class="function">2015-12-16 09:16:40,093 [<span class="title">myid</span>:] - <span class="title">INFO</span>  [<span class="title">main:QuorumPeerConfig</span>@114] - <span class="title">Reading</span> <span class="title">configuration</span> <span class="title">from</span>: <span class="title">E</span>:\<span class="title">zookeeper</span>-3.5.1-<span class="title">alpha</span>\<span class="title">bin</span>\..\<span class="title">conf</span>\<span class="title">zoo.cfg</span></span></span><br><span class="line"><span class="function">2015-12-16 09:16:40,093 [<span class="title">myid</span>:] - <span class="title">INFO</span>  [<span class="title">main:QuorumPeerConfig</span>@316] - <span class="title">clientPortAddress</span> <span class="title">is</span> 0.0.0.0/0.0.0.0:2181</span></span><br><span class="line"><span class="function">2015-12-16 09:16:40,093 [<span class="title">myid</span>:] - <span class="title">INFO</span>  [<span class="title">main:QuorumPeerConfig</span>@320] - <span class="title">secureClientPort</span> <span class="title">is</span> <span class="title">not</span> <span class="title">set</span></span></span><br><span class="line"><span class="function">2015-12-16 09:16:40,109 [<span class="title">myid</span>:] - <span class="title">INFO</span>  [<span class="title">main:ZooKeeperServerMain</span>@113] - <span class="title">Starting</span> <span class="title">server</span></span></span><br><span class="line"><span class="function">2015-12-16 09:16:49,234 [<span class="title">myid</span>:] - <span class="title">INFO</span>  [<span class="title">main:Environment</span>@109] - <span class="title">Server</span> <span class="title">environment:zookeeper</span>.<span class="title">version</span>=3.5.1-<span class="title">alpha</span>-1693007, <span class="title">built</span> <span class="title">on</span> 07/28/2015 07:19 <span class="title">GMT</span></span></span><br><span class="line"><span class="function">2015-12-16 09:16:49,234 [<span class="title">myid</span>:] - <span class="title">INFO</span>  [<span class="title">main:Environment</span>@109] - <span class="title">Server</span> <span class="title">environment:host</span>.<span class="title">name</span>=<span class="title">lenovo</span>-<span class="title">PC</span></span></span><br><span class="line"><span class="function">2015-12-16 09:16:49,234 [<span class="title">myid</span>:] - <span class="title">INFO</span>  [<span class="title">main:Environment</span>@109] - <span class="title">Server</span> <span class="title">environment:java</span>.<span class="title">version</span>=1.8.0<span class="title">_65</span></span></span><br><span class="line"><span class="function">2015-12-16 09:16:49,234 [<span class="title">myid</span>:] - <span class="title">INFO</span>  [<span class="title">main:Environment</span>@109] - <span class="title">Server</span> <span class="title">environment:java</span>.<span class="title">vendor</span>=<span class="title">Oracle</span> <span class="title">Corporation</span></span></span><br><span class="line"><span class="function">2015-12-16 09:16:49,234 [<span class="title">myid</span>:] - <span class="title">INFO</span>  [<span class="title">main:Environment</span>@109] - <span class="title">Server</span> <span class="title">environment:java</span>.<span class="title">home</span>=<span class="title">D</span>:\<span class="title">Java</span>\<span class="title">jdk</span>\<span class="title">jre</span></span></span><br></pre></td></tr></table></figure>
<p>之后运行<strong>zkCli.cmd</strong>即可运行客户端并链接上zookeeper服务端。<br>输出类似信息：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:None <span class="built_in">path</span>:null</span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Linux下安装运行zookeeper"><a href="#Linux下安装运行zookeeper" class="headerlink" title="Linux下安装运行zookeeper"></a>Linux下安装运行zookeeper</h3><blockquote>
<p>本机环境ubuntu 32位desktop</p>
</blockquote>
<p><span id="linux"><a href="#windows">前往查看windows下安装运行</a></span></p>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>下载zookeeper，jdk。分别解压到/usr/local，/usr/lib，重命名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/docker/Downloads/</span><br><span class="line"></span><br><span class="line">sudo tar -zxvf jdk-8u65-linux-i586.tar.gz -C /usr/lib</span><br><span class="line"></span><br><span class="line">sudo tar -zxvf zookeeper-3.4.7.tar.gz -C /usr/<span class="built_in">local</span>/</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/lib</span><br><span class="line"></span><br><span class="line">sudo mv jdk1.8.0_65 jdk</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/loacl</span><br><span class="line"></span><br><span class="line">sudo mv zookeeper-3.4.7 zookeeper</span><br><span class="line"></span><br><span class="line">sudo gedit /etc/profile</span><br></pre></td></tr></table></figure>
<p>编辑环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jdk</span><br><span class="line"><span class="built_in">export</span> ZOOKEEPER_HOME=/usr/<span class="built_in">local</span>/zookeeper</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=/usr/lib/jdk/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib:<span class="variable">$JRE_HOME</span>/lib:<span class="variable">$ZOOKEEPER_HOME</span>/lib:<span class="variable">$CLASSPATH</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$ZOOKEEPER_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin:<span class="variable">$JAVA_HOME</span>:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<p><strong>此处注意，一定要使环境变量立即生效</strong></p>
<blockquote>
<p>source /etc/profile</p>
</blockquote>
<p>验证：</p>
<blockquote>
<p>java -version</p>
</blockquote>
<p>配置zookeeper配置文件，切换目录到zookeeper/conf下</p>
<blockquote>
<p>cp zoo_sample.cfg zoo.cfg</p>
</blockquote>
<h4 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h4><p>服务端：<br>由于要创建目录，需要root权限：</p>
<blockquote>
<p>sudo su;</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/usr/<span class="built_in">local</span>/zookeeper/conf<span class="comment"># cd ../bin</span></span><br><span class="line">root@ubuntu:/usr/<span class="built_in">local</span>/zookeeper/bin<span class="comment"># ./zkServer.sh</span></span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/<span class="built_in">local</span>/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Usage: ./zkServer.sh &#123;start|start-foreground|stop|restart|status|upgrade|print-cmd&#125;</span><br><span class="line">root@ubuntu:/usr/<span class="built_in">local</span>/zookeeper/bin<span class="comment"># ./zkServer.sh start</span></span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/<span class="built_in">local</span>/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure>
<p>使用客户端链接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/usr/<span class="built_in">local</span>/zookeeper/bin<span class="comment">#./zkCli.sh</span></span><br></pre></td></tr></table></figure>

<h2 id="关于报错"><a href="#关于报错" class="headerlink" title="关于报错"></a>关于报错</h2><p>windows下一般配置有错或是目录有空格之类的。<br>linux下可能是环境变量没有立即生效的。本机测试，在普通用户下使用 source /etc/profile后切换到root用户，启动出错，原因是root用户下环境变量没起作用，再用一遍source /etc/profile后启动成功。</p>
<p>输出日志可以查看zookeeper目录下bin目录里的zookeeper.out文件。</p>
<h2 id="三、结构"><a href="#三、结构" class="headerlink" title="三、结构"></a>三、结构</h2><h3 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h3><pre><code>zk是树形结构的，类似xml结构。每一个节点可以存储信息，可以有子节点。</code></pre><h4 id="节点模型"><a href="#节点模型" class="headerlink" title="节点模型"></a>节点模型</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">czxid – The zxid of the change that caused this znode to be created.</span><br><span class="line">mzxid – The zxid of the change that last modified this znode.</span><br><span class="line">ctime – The time <span class="keyword">in</span> milliseconds from epoch when this znode was created.</span><br><span class="line">mtime – The time <span class="keyword">in</span> milliseconds from epoch when this znode was last modified.</span><br><span class="line">version – The number of changes to the data of this znode.</span><br><span class="line">cversion – The number of changes to the children of this znode.</span><br><span class="line">aversion – The number of changes to the ACL of this znode.</span><br><span class="line">ephemeralOwner – The session id of the owner of this znode <span class="keyword">if</span> the znode is an ephemeral node. If it is not an ephemeral node, it will be zero.</span><br><span class="line">dataLength – The length of the data field of this znode.</span><br><span class="line">numChildren – The number of children of this znode.</span><br><span class="line">cZxid = 0x3//节点id，创建时指定，创建时事务id</span><br><span class="line">ctime = Thu Dec 17 21:04:51 CST 2015//创建时间</span><br><span class="line">mZxid = 0x1b//节点更新id，每次更新节点，id就会改变。更新时事务ID</span><br><span class="line">mtime = Thu Dec 17 21:31:00 CST 2015//更新时间</span><br><span class="line">pZxid = 0x6//父节点id</span><br><span class="line">cversion = 3//子节点节点数变化次数，删除，创建子节点会使数字增加。子节点版本</span><br><span class="line">dataVersion = 1//数据版本，每次<span class="built_in">set</span>值会使数据版本增加</span><br><span class="line">aclVersion = 0//权限版本</span><br><span class="line">ephemeralOwner = 0x0//如果是临时节点，这是此节点对应的sessionId</span><br><span class="line">dataLength = 3//本节点数据长度</span><br><span class="line">numChildren = 3//子节点数</span><br></pre></td></tr></table></figure>

<h2 id="四、zoo-cfg配置项说明"><a href="#四、zoo-cfg配置项说明" class="headerlink" title="四、zoo.cfg配置项说明"></a>四、zoo.cfg配置项说明</h2><blockquote>
<ol>
<li>tickTime：心跳时间，毫秒为单位。</li>
<li>initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 10*2000=20 秒。</li>
<li>syncLimit：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 5*2000=10 秒。</li>
<li>dataDir：存储内存中数据库快照的位置。</li>
<li>clientPort：监听客户端连接的端口</li>
<li>server.A=B：C：D：其中 A 是一个数字，表示这个是第几号服务器，范围是1-255；B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。<br>集群时需要在dataDir目录下创建myid文件，将内容设置为上⑥中的A值，用来标识不同的服务器。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zk</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Map</title>
    <url>/2017/04/19/map/</url>
    <content><![CDATA[<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>java实现的map采用散列表的方式，有2个要素构成：桶数组与散列函数。桶数组存储元素，散列函数则确定元素在桶中存放的位置。<br>在散列表中，为得到较好的性能，需要使每个桶的容量都小于桶的数量，因而引入装载因子,设l为装载因子，n为每个桶的容量，N为桶数组的数量，则：</p>
<blockquote>
<p>l=n/N</p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">map散列表结构解决碰撞的方法有：</span><br><span class="line">设H为映射的Key通过散列函数计算得到的值，N桶数量（为存储映射的数组的length），L为装载因子=n(每个桶容量)/N。j为正整数（j=1,2,3...）。</span><br><span class="line">1. 开放地址策略。采用开放地址策略的方式是使用数组本身来解决下标冲突，本质都是在遇到碰撞时，将后入的映射向后移动，此策略缺点是性能随元素的增加和碰撞概率（碰撞概率也随元素增加而上升）上升而下降，优点是节省空间，不需要借助额外的空间来解决冲突。线性探测法，遇到碰撞后执行(H+1)%N得到新的下标j，发现j已被占用，再执行(H+2)%N，如此，直到得到的下标能够存入数组。平方探测法，遇到冲突，使用循环(H + j^2)%N的方式直到元素能够存入数组。前2个方法在L大于0.5时，会造成大量元素集聚（线性连续集聚，平方二阶集聚），使得即使存在空桶，也有可能找不到插入的位置。双散列法，除原有散列函数外，再选取另外一个散列函数g()作为二阶散列函数，使得任意g(key)不为0，不断使用H + j*g(key)获取新下标，直到能够存入元素。</span><br><span class="line">2. 分离链策略。分离链策略是将冲突的元素使用链表的形势存储在同一个数组下标处，形成一个列表数据结构，对映射的操作转变为对列表的操作。这种策略下的方法叫做链地址法。此策略缺点是需要额外的空间存储链表，优点是性能稳定且较高。</span><br></pre></td></tr></table></figure>
<p>map存储键值对，有的map允许null值key和value，有的不允许。存取value时通过key判断取值，会涉及key对象的2个方法，equals和hashCode。如果使用重写equals和hashCode方法的类实例化的对象作为key时需要注意可能导致映射不正确（不同的对象会被当成一个对象处理）。如果使用可变对象（修改对象属性值时会对equals产生影响）作为key时，会使映射关系不正确，禁止某个map将自身作为key在自身建立映射。value的equals及hashCode同样影响map对于value的操作。<br>所有map实现都有2个构造函数，一个默认构造函数，一个以map作为参数的构造函数。<br>map提供3个视图：key视图（keySet），value视图(values)，key-value视图(entrySet)。映射的顺序依赖map的具体实现，由迭代器返回元素的顺序决定。<br>map基础结构为Entry&lt;K,V&gt;结构。</p>
<span id="more"></span>
<h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><p>基于数组的链表结构（散列桶，数组为桶，每个数组元素处存储链表头），通过synchronized方法保证线程安全。<br>Hashtable主要属性有entry数组[Entry<?,?>[] table]，实际容量[count=实际entry数量]，装载因子[loadFactor]，容量阈值[threshold=(int)(capacity * loadFactor)]。capacity为初始化时指定最大容量，并非真实的容量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">Entry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Entry&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key =  key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">如果不指定容量，初始容量为<span class="number">11</span>，最大容量为最大整数值-<span class="number">8</span>（对象内存模型，数组需要额外的空间存储数组长度），每次扩容为原来容量的<span class="number">2</span>倍，装载因子默认为<span class="number">0.75</span>，当数组实际容量达到指定容量*<span class="number">0.75</span>时，自动扩容。   </span><br><span class="line"></span><br><span class="line">put和get时entry在数组中位置计算：</span><br><span class="line">&gt; (key.hash &amp; <span class="number">0x7FFFFFFF</span>) % entrys.length</span><br><span class="line">&gt; key的hashCode与上<span class="keyword">int</span>最大值（二进制首位为<span class="number">0</span>，其他位全为<span class="number">1</span>），对entry数组的长度求模。</span><br><span class="line"></span><br><span class="line">hashTable不允许使用<span class="keyword">null</span>的key和value。</span><br><span class="line"></span><br><span class="line">### put</span><br><span class="line">put方法流程：</span><br><span class="line">```bash</span><br><span class="line"><span class="number">1.</span> 计算出key对应的数组下标。</span><br><span class="line"><span class="number">2.</span> 取出计算出的下标对应的entry链表。</span><br><span class="line"><span class="number">3.</span> 循环entry链表，使用(entry.hash == hash) &amp;&amp; entry.key.equals(key)条件查找是否已经有相同的key-value生成的entry在链表中，从而判断是更新还是新增。</span><br><span class="line"><span class="number">3.1</span>. 如果已有entry，是更新操作，替换value并返回旧值，结束put操作。</span><br><span class="line"><span class="number">3.2</span>. 如果没有entry，是新增操作。</span><br><span class="line"><span class="number">3.2</span><span class="number">.1</span> 结构改变数+<span class="number">1</span>，判断当前实际容量是否&gt;=容量阈值。</span><br><span class="line"><span class="number">3.2</span><span class="number">.2</span> 如果实际容量&gt;=容量阈值，先进行扩容并重新计算数组下标。</span><br><span class="line"><span class="number">3.2</span><span class="number">.3</span> 将新生成entry添加到数组下标处（新entry的next指向原先的entry链表头）。</span><br><span class="line"><span class="number">3.2</span><span class="number">.4</span> 实际容量+<span class="number">1</span>。</span><br><span class="line"><span class="number">3.3</span> 添加成功，返回<span class="keyword">null</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//put </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空值不允许</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="comment">/****** 如果是更新操作  *********/</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];<span class="comment">//取出原位置上的entry链表</span></span><br><span class="line">        <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">            <span class="comment">//循环判断是否已经有key对应的entry，如果有更新并结束put操作</span></span><br><span class="line">            <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">                V old = entry.value;</span><br><span class="line">                entry.value = value;</span><br><span class="line">                <span class="keyword">return</span> old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/****** 如果是新增操作  *********/</span></span><br><span class="line">        addEntry(hash, key, value, index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加新的entry</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录hashtable结构变更次数</span></span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">            <span class="comment">//如果实际存储的容量已经达到阈值，扩容。可以看到扩容是在put元素到entry之前进行的。</span></span><br><span class="line">            rehash();</span><br><span class="line">            <span class="comment">//更新tab引用</span></span><br><span class="line">            tab = table;</span><br><span class="line">            hash = key.hashCode();</span><br><span class="line">            <span class="comment">//重新计算存放位置</span></span><br><span class="line">            index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新增enrtry，将新entry放到对应数组下标处，并将next指向原来的entry头</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">        tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        <span class="comment">//实际容量+1</span></span><br><span class="line">        count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = table.length;</span><br><span class="line">        Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新容量计算，为原来容量（数组长度）的2倍</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果扩容超过最大容量，调整新容量为最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">                <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以新容量创建entry数组</span></span><br><span class="line">        Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line">        <span class="comment">//结构调整次数+1</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//计算新的容量阈值</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//更新hashtable entry数组引用。</span></span><br><span class="line">        table = newMap;</span><br><span class="line">        <span class="comment">//循环数组，取entry链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">            <span class="comment">//循环entry链表，取entry对象</span></span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line">                <span class="comment">//entry旧链表头</span></span><br><span class="line">                Entry&lt;K,V&gt; e = old;</span><br><span class="line">                <span class="comment">//向前移动链表</span></span><br><span class="line">                old = old.next;</span><br><span class="line">                <span class="comment">//计算出旧链表头在新entry数组中存放的位置</span></span><br><span class="line">                <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">                <span class="comment">//断开旧链表头的next，并将next指向新entry存放位置处的entry链表头</span></span><br><span class="line">                e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">                <span class="comment">//旧链表头放到新的entry数组</span></span><br><span class="line">                newMap[index] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>get方法流程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 计算出key在数组中的位置i。</span><br><span class="line">2. 取出i处的entry链表e。</span><br><span class="line">3. 循环e，使用(e.hash == <span class="built_in">hash</span>) &amp;&amp; e.key.equals(key)条件寻找entry。 </span><br><span class="line">4.1. 如果找到，返回entry的值。</span><br><span class="line">4.1.2 如果找不到，返回null。</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HashTable线程安全，但性能不高，因为操作锁住整个对象。size方法复杂度为O(1)。在相同的初始容量下，装载因子越大，扩容次数越小，但相应的碰撞率就越高（因为实际存储的元素越多，数组同一位置存储的entry链表越长的可能性越大），get和容量调整一级批量操作时耗费的时间越长。反之也成立。大量的碰撞会导致OOM和获取元素时CPU占用升高（主要是get和rehash）。hashtable的视图通过实例化指定不同类型的同一枚举器类获得。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>基于数组链表结构的<strong>非线程安全</strong>map实现。允许使用null值得key和value，hashmap不保证映射顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表长度阈值，如果链表长度&gt;=8，会将单向链表存储结构转为红黑树存储结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; </span><br><span class="line"><span class="comment">//桶，entry数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//键值对set</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际容量-map中键值对数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构改变次数，遍历时以此判断结构是否发生改变，中断循环</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容量阈值，此值为实例化时指定的初始容量*装载因子。默认初始容量为16，最大容量为2的30次方</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载因子，默认0.75f。采用分离链策略（链地址法）解决冲突时，假设元素都均匀的分离到桶中，</span></span><br><span class="line"><span class="comment">//这时从效率考虑，希望n(每个桶存放的链中的元素数量)和N(桶的数量)的比值n/N小于1，使得操作时间复杂度维持在O(n/N)即O(1)。</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>
<p>和hastable类似。影响性能的有2个参数：加载因子和初始容量。<br>相同的初始容量下，加载因子越大，map内桶填满越多，空间利用率越高，相应的碰撞概率也增高，查找效率降低，加载因子越小，map内桶填满越少，空间利用率越低，查找效率越高。默认值是空间与时间的一个折中值，一般使用默认值。</p>
<p>hashmap的桶的初始化并不是在map初始化时完成，而是在第一次put是完成。并且初始化桶的容量是map初始化时的threshold（这个是使用传入的容量值找到距它最近的2的n次方的值X装载因子得到），初始化完桶后，再次重新用新的桶容量X装载因子计算出容量阈值。是在核心方法resize中完成。</p>
<h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p>hash计算，在put，get时，都是通过重新计算hash来进行后续的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="comment">//使用高16位和低16位进行异或操作（使高位和低位都参与hash计算），主要是从速度、功效、质量来考虑的，这么做可以在Node数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>hash方法最主要是用来进行桶位置计算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = (n - <span class="number">1</span>) &amp; hash<span class="comment">//n为此时entry数组length，hash为通过key用上面的公司计算出，应为n是2的n次方，总为偶数，减一后为奇数，此时&amp;操作相当于对hash的%（取模）运算</span></span><br></pre></td></tr></table></figure>


<h4 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h4><p>resize在初始化后第一次put或者put时发现容量&gt;=阈值时调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;<span class="comment">//将已有的Node数组赋值给oldTab</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">//如果原来的map是空的，oldCap容量为0，如果不为空，oldCap为Node数组length</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;<span class="comment">//老map的容量调整阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;<span class="comment">//定义新的容量和新的容量调整阈值</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;<span class="comment">//如果oldCap&gt;0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//如果容量等于或超过最大容量1&lt;&lt;30</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;<span class="comment">//容量阈值为Integer的最大值</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;<span class="comment">//将现有Node数组返回，不进行调整</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<span class="comment">//如果oldCap*2&lt;最大容量并且&gt;=默认初始容量16，并将新容量设为老容量的2倍</span></span><br><span class="line">                    newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold 新的阈值=老的阈值*2</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold 如果老的容量&lt;=0且老的容量调整阈值&gt;0</span></span><br><span class="line">            newCap = oldThr;<span class="comment">//直接将老的阈值作为新的容量</span></span><br><span class="line">            <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults 老的容量和调整阈值都&lt;=0，新的都将使用默认值</span></span><br><span class="line">                newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">                newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;<span class="comment">//如果新的阈值为0</span></span><br><span class="line">                    <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;<span class="comment">//新的容量*装载因子</span></span><br><span class="line">                    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);<span class="comment">//如果新的容量小于最大容量并且 （新容量*装载因子）小于最大容量则将新容量=（新容量*装载因子）的int值，否则将int最大值赋给新容量</span></span><br><span class="line">            &#125;</span><br><span class="line">        threshold = newThr;<span class="comment">//将计算出来的新的容量调整阈值赋给hashmap的容量调整阈值</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];<span class="comment">//使用计算出来的新容量创建Node数组</span></span><br><span class="line">        table = newTab;<span class="comment">//新的Node数组赋值给hashmap</span></span><br><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;<span class="comment">//如果旧的数组不为空，循环将旧的数组数据挪到新数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;<span class="comment">//定义临时Node e</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;<span class="comment">//将循环的到的旧数组元素赋值给临时Node</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;<span class="comment">//将旧的数组置NULL</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)<span class="comment">//如果获取到的Node的next是空的</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;<span class="comment">//将e放入新的Node数组中，注意下标是 此时e的hash值&amp;（新容量-1）</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果e是TreeNode-&gt;LinkedHashMap</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);<span class="comment">//调用TreeNode的split方法将e赋值到新的Node数组</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order  临时Node如果是中间的Node并且不是TreeNode对象执行以下操作赋值到新Node数组</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;<span class="comment">//临时节点 next 用来存循环出来的下一个节点</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;<span class="comment">//e的下一个节点赋值给next</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;<span class="comment">//如果e的hash值&amp;上旧容量为0</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;<span class="comment">//如果是第一次，e赋值给loHead</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;<span class="comment">//如果不是第一次，将e赋值给loTail的下一节点</span></span><br><span class="line">                                loTail = e;<span class="comment">//每次将e赋值给loTail</span></span><br><span class="line">                            &#125;<span class="keyword">else</span> &#123;<span class="comment">//e的hash &amp; 旧容量不为0</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)<span class="comment">//第一次循环将hiHead赋值为e</span></span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;<span class="comment">//从第二次循环开始每次循环将hiTail的下一节点赋值为e</span></span><br><span class="line">                                    hiTail = e;<span class="comment">//每次将hiTail赋值为e</span></span><br><span class="line">                                &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);<span class="comment">//如果e还有next并且next不为null继续上面的操作，将e的next赋值给e</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;<span class="comment">//循环完如果loTail不为null 将loTail置为null</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;<span class="comment">//loTail的下一节点置为null</span></span><br><span class="line">                        newTab[j] = loHead;<span class="comment">//将loHead赋值给新Node数组，下标为循环下标</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;<span class="comment">//循环完成如果hiTail不为null</span></span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;<span class="comment">//hiTail的下一节点置为Null</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;<span class="comment">//将hiHead添加到新Node数组的，下标为循环下标+老的hash容量，因为jdk8扩容为2倍扩容，因而不需要重新计算移动的node的下标，只会有2种情况：1.不动，在原位置。2.新下标是现在的下标+旧容量。原理：*2相当于多出一个高位，key的hash不变，&amp;时只用看高位，如果高位为0，则位置不变，如果是1，则位置需要加上旧容量。</span></span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>resize的主要功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1&gt;.调整容量和容量阈值。为以前的2倍或者原值（最大允许容量）或者装载因子*容量的int值：</span><br><span class="line">1、oldCap&lt;=0&amp;&amp;oldThr&lt;=0，则newCap=16(默认值)，newThr=(int)16*0.75(默认装载因子)。</span><br><span class="line">2、oldCap&gt;0&amp;&amp;oldCap&gt;=最大容量(1&lt;&lt;<span class="string">30)，则newThr=Integer.MAX_VALUE，中断直接返回原有table。</span></span><br><span class="line"><span class="string">3、oldCap&gt;0&amp;&amp;oldCap&lt;最大容量&amp;&amp;oldCap*2&lt;最大容量&amp;&amp;oldCap&gt;=16，则newCap=oldCap*2，newThr=oldThr*2;</span></span><br><span class="line"><span class="string">oldCap&gt;0&amp;&amp;oldCap&lt;最大容量&amp;&amp;oldCap*2&gt;最大容量，则newCap=oldCap*2，newThr=Integer.MAX_VALUE。</span></span><br><span class="line"><span class="string">4、oldCap&lt;=0&amp;&amp;oldThr&gt;0，则newCap=oldThr，newThr需要先用newCap*loadFactor算出中间值ft，然后进行比较得出：</span></span><br><span class="line"><span class="string">newThr=(newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?(int)ft : Integer.MAX_VALUE)。</span></span><br><span class="line"><span class="string">最后用算出的newCap创建出新的table数组。</span></span><br><span class="line"><span class="string">5、移动原有的HashMap中的Entry数组中的元素，组合成新的HashMap。</span></span><br></pre></td></tr></table></figure>

<h3 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h3><p>普通node:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>红黑树：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>hashmap为hashtable轻量级map实现，存取时通过key的hash值与hash值的高位进行异或运算再与桶长度-1进行与运算计算出位置，再进行存取操作。存时，如果单个链表长度超过8，将存储由链表改变为红黑树，如果实际存储元素总数&gt;=阈值，resize进行扩容，新容量和新阈值为原来2倍；遍历时，顺着桶的位置来遍历，因此是乱序。hashmap的遍历方法都是fail-fast的，当遍历时，只有在iterator中使用remove方法是允许的，其他遍历方式改变hashmap的结构都会导致遍历失败且不保证总是抛出ConcurrentModificationException。如果要线程安全的使用hashmap，需要使用Map m = Collections.synchronizedMap(new HashMap(…))来进行封装。基本操作，put，get，contains，remove具有稳定的性能。hash map非线程安全，多线程下进行put操作可能造成死循环，因为put操作可能会引起rehash操作，rehash会对节点进行桶位置重新分配和链接。</p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>基于HashMap实现的具有特定迭代顺序的非线程安全map。提供一个特殊的构造函数可以指定以map中元素最后访问的顺序作为迭代顺序，从近期访问最少到访问最多的顺序，此实现可用来做LRU（最近最少使用）缓存。<br>LinkedHashMap在HashMap的entry结构上进行扩展，使新的entry多出2个维度，一个记录当前entry前面put的entry，一个记录当前entry后面put的entry。同时，使用 head 和 tail 2个属性，分别指向第一个put到map中entry和最后一次put到map中的entry（使用默认排序）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashMap.Node subclass for normal LinkedHashMap entries.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">        Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3801124242820219131L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否按最近读取进行排序，如果否，将按元素put的顺序，如果true，将把最近get过 * 的元素移动到双链表末尾</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br><span class="line">```    </span><br><span class="line">LinkedHashMap中entry数组每个下标处存有一个单链表，并且单链表中的每个entry又和其他entry（包括其他链表中的entry）形成一个双链表，LinkedHashMap通过这样的方式来保证读取entry的顺序。   </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">   <span class="comment">//如果accessOrder为true，每次访问过的元素移动到链表末尾</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder)</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">            LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">            p.after = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">                head = a;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b.after = a;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">                a.before = b;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                last = b;</span><br><span class="line">            <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">                head = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.before = last;</span><br><span class="line">                last.after = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = p;</span><br><span class="line">            ++modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>红黑树算法实现的MAP，<img src="./TreeMap.png" alt="TreeMap"><br>map中存储的元素时有序的，按照key存入顺序或使用构造时传入的comparator接口实例判断存入时key的大小，放入合适的位置。containsKey，geyt，put，remove操作的时间复杂度为log(n)，TreeMap并不是线程安全的，需要在外部调用时进行线程同步。</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>基于CAS操作和ReentrantLock实现的线程安全的map，实现了HashTable的所有功能。<br>由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>
<h3 id="ConcurrentHashMap的初始化"><a href="#ConcurrentHashMap的初始化" class="headerlink" title="ConcurrentHashMap的初始化"></a>ConcurrentHashMap的初始化</h3><p>ConcurrentHashMap初始化方法是通过initialCapacity，loadFactor, concurrencyLevel几个参数来初始化segments数组，段偏移量segmentShift，段掩码segmentMask和每个segment里的HashEntry数组 。</p>
<p>初始化segments数组。让我们来看一下初始化segmentShift，segmentMask和segments数组的源代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">    concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>.segments = Segment.newArray(ssize);</span><br></pre></td></tr></table></figure>
<p>由上面的代码可知segments数组的长度ssize通过concurrencyLevel计算得出。为了能通过按位与的哈希算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方（power-of-two size），所以必须计算出一个是大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。假如concurrencyLevel等于14，15或16，ssize都会等于16，即容器里锁的个数也是16。注意concurrencyLevel的最大大小是65535，意味着segments数组的长度最大为65536，对应的二进制是16位。</p>
<p>初始化segmentShift和segmentMask。这两个全局变量在定位segment时的哈希算法里需要使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。segmentShift用于定位参与hash运算的位数，segmentShift等于32减sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的，后面的测试中我们可以看到这点。segmentMask是哈希运算的掩码，等于ssize减1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。</p>
<p>初始化每个Segment。输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadfactor是每个segment的负载因子，在构造方法里需要通过这两个参数来初始化数组中的每个segment。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"><span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">    ++c;</span><br><span class="line"><span class="keyword">int</span> cap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">    cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i)</span><br><span class="line">    <span class="keyword">this</span>.segments[i] = <span class="keyword">new</span> Segment&lt;K,V&gt;(cap, loadFactor);</span><br></pre></td></tr></table></figure>
<p>上面代码中的变量cap就是segment里HashEntry数组的长度，它等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。segment的容量threshold＝(int)cap*loadFactor，默认情况下initialCapacity等于16，loadfactor等于0.75，通过运算cap等于1，threshold等于零。</p>
<h3 id="定位Segment"><a href="#定位Segment" class="headerlink" title="定位Segment"></a>定位Segment</h3><p>既然ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素的时候，必须先通过哈希算法定位到Segment。可以看到ConcurrentHashMap会首先使用hash的变种算法对元素的hashCode进行一次再哈希。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        h += (h &lt;&lt; <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">        h += (h &lt;&lt; <span class="number">3</span>);</span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">6</span>);</span><br><span class="line">        h += (h &lt;&lt; <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>之所以进行再哈希，其目的是为了减少哈希冲突，使元素能够均匀的分布在不同的Segment上，从而提高容器的存取效率。假如哈希的质量差到极点，那么所有的元素都在一个Segment中，不仅存取元素缓慢，分段锁也会失去意义。我做了一个测试，不通过再哈希而直接执行哈希计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;0001111&quot;</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;0011111&quot;</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;0111111&quot;</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;1111111&quot;</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</span><br></pre></td></tr></table></figure>
<p>计算后输出的哈希值全是15，通过这个例子可以发现如果不进行再哈希，哈希冲突会非常严重，因为只要低位一样，无论高位是什么数，其哈希值总是一样。我们再把上面的二进制数据进行再哈希后结果如下，为了方便阅读，不足32位的高位补了0，每隔四位用竖线分割下。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">0100｜0111｜0110｜0111｜1101｜1010｜0100｜1110</span><br><span class="line">1111｜0111｜0100｜0011｜0000｜0001｜1011｜1000</span><br><span class="line">0111｜0111｜0110｜1001｜0100｜0110｜0011｜1110</span><br><span class="line">1000｜0011｜0000｜0000｜1100｜1000｜0001｜1010</span><br></pre></td></tr></table></figure>
<p>可以发现每一位的数据都散列开了，通过这种再哈希能让数字的每一位都能参加到哈希运算当中，从而减少哈希冲突。ConcurrentHashMap通过以下哈希算法定位segment。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下segmentShift为28，segmentMask为15，再哈希后的数最大是32位二进制数据，向右无符号移动28位，意思是让高4位参与到hash运算中， (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask的运算结果分别是4，15，7和8，可以看到hash值没有发生冲突。</p>
<h3 id="ConcurrentHashMap的get操作"><a href="#ConcurrentHashMap的get操作" class="headerlink" title="ConcurrentHashMap的get操作"></a>ConcurrentHashMap的get操作</h3><p>Segment的get操作实现非常简单和高效。先经过一次再哈希，然后使用这个哈希值通过哈希运算定位到segment，再通过哈希算法定位到元素，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">    <span class="keyword">return</span> segmentFor(hash).get(key, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空的才会加锁重读，我们知道HashTable容器的get方法是需要加锁的，那么ConcurrentHashMap的get操作是如何做到不加锁的呢？原因是它的get方法里将要使用的共享变量都定义成volatile，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。之所以不会读到过期的值，是根据java内存模型的happen before原则，对volatile字段的写入操作先于读操作，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值，这是用volatile替换锁的经典应用场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">volatile</span> V value;</span><br></pre></td></tr></table></figure>
<p>在定位元素的代码里我们可以发现定位HashEntry和定位Segment的哈希算法虽然一样，都与数组的长度减去一相与，但是相与的值不一样，定位Segment使用的是元素的hashcode通过再哈希后得到的值的高位，而定位HashEntry直接使用的是再哈希后的值。其目的是避免两次哈希后的值一样，导致元素虽然在Segment里散列开了，但是却没有在HashEntry里散列开。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hash &gt;&gt;&gt; segmentShift) &amp; segmentMask<span class="comment">//定位Segment所使用的hash算法</span></span><br><span class="line"><span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);<span class="comment">// 定位HashEntry所使用的hash算法</span></span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentHashMap的Put操作"><a href="#ConcurrentHashMap的Put操作" class="headerlink" title="ConcurrentHashMap的Put操作"></a>ConcurrentHashMap的Put操作</h3><p>由于put方法里需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必须得加锁。Put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二步定位添加元素的位置然后放在HashEntry数组里。</p>
<p>是否需要扩容。在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold），如果超过阀值，数组进行扩容。值得一提的是，Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时HashMap就进行了一次无效的扩容。</p>
<p>如何扩容。扩容的时候首先会创建一个两倍于原容量的数组，然后将原数组里的元素进行再hash后插入到新的数组里。为了高效ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。</p>
<h3 id="ConcurrentHashMap的size操作"><a href="#ConcurrentHashMap的size操作" class="headerlink" title="ConcurrentHashMap的size操作"></a>ConcurrentHashMap的size操作</h3><p>如果我们要统计整个ConcurrentHashMap里元素的大小，就必须统计所有Segment里元素的大小后求和。Segment里的全局变量count是一个volatile变量，那么在多线程场景下，我们是不是直接把所有Segment的count相加就可以得到整个ConcurrentHashMap大小了呢？不是的，虽然相加时可以获取每个Segment的count的最新值，但是拿到之后可能累加前使用的count发生了变化，那么统计结果就不准了。所以最安全的做法，是在统计size的时候把所有Segment的put，remove和clean方法全部锁住，但是这种做法显然非常低效。 因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。</p>
<p>那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put , remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。</p>
<h2 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h2><p>基于skip-list算法实现的线程安全的有序map，按照key的自然顺序或构造时传入的比较器实例比较得出相应存储位置。size()操作需要遍历全部元素。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Collection之List</title>
    <url>/2016/09/08/Collection-List/</url>
    <content><![CDATA[<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList由Object数组构成,用int类型的size属性记录数组中实际对象的数量，实现了随机访问接口RandomAccess。默认容量是10，最大容量为Integer.MAX_VALUE-8。使用int modCount记录结构变更（增减数组长度）次数，使用指针迭代ArrayList时，<br>指针中的expectedModCount初始为modCount，当在迭代中发现expectedModCount和modCount不相等时，认为结构被其他线程改变了，此时将抛出异常。<br>每次插入、批量新增和删除元素都会对结构作出改变，并对modCount+1，底层通过使用System.arraycopy实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param      src      the source array.源数组。</span></span><br><span class="line"><span class="comment"> * @param      srcPos   starting position in the source array.要复制的起始位置,包含此位置的元素。</span></span><br><span class="line"><span class="comment"> * @param      dest     the destination array.目标数组。</span></span><br><span class="line"><span class="comment"> * @param      destPos  starting position in the destination data.目标数组放置复制元素的其实位置。</span></span><br><span class="line"><span class="comment"> * @param      length   the number of array elements to be copied.要从源数组复制的元素数量。</span></span><br><span class="line"><span class="comment"> * @exception  IndexOutOfBoundsException  if copying would cause</span></span><br><span class="line"><span class="comment"> *               access of data outside array bounds.</span></span><br><span class="line"><span class="comment"> * @exception  ArrayStoreException  if an element in the &lt;code&gt;src&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> *               array could not be stored into the &lt;code&gt;dest&lt;/code&gt; array</span></span><br><span class="line"><span class="comment"> *               because of a type mismatch.</span></span><br><span class="line"><span class="comment"> * @exception  NullPointerException if either &lt;code&gt;src&lt;/code&gt; or</span></span><br><span class="line"><span class="comment"> *               &lt;code&gt;dest&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>ArrayList是<strong>非线程安全</strong>的。由于是数组实现，每次<strong>结构改变都要移动数据</strong>，所以涉及此类的操作性能很低，但却带来了<strong>很好的访问速度</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>Tips</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subList(int fromIndex, int toIndex)方法返回一个窗口，在fromIndex（包含），toIndex（不包含）之间，本身元素还是在源ArrayList中，</span><br><span class="line">在返回的SubList上进行的操作会对源ArrayList造成影响。</span><br></pre></td></tr></table></figure>

<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Vector,向量，底层和ArrayList一样使用Object数组实现，但在增加元素改变结构时，vector使用<strong>capacityIncrement</strong>因子来增加定长容量——<br>如果capacityIncrement&lt;=0,则一次性增加容量为原来的2倍。增加容量时，如果按上述方方法仍不够容纳元素，则增加的容量为元素数量。<br>vector使用<strong>同步方法</strong>的方式保证线程安全，因而其多线程性能不高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Object[] elementData;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> elementCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2767605614048989439L</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>LinkedList链表，实现了Deque（双端队列）接口，可以作为链表使用，也可以作为队列使用。其由Node构成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>本身记录first（头）和last（尾）的Node引用，以及元素数量size。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">  <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与ArrayList一样，非线程安全，使用modCount记录结构改变次数，迭代时用于判断结构是否被改变，SubList同样是个窗口。<br>由于使用引用记录顺序，因此LinkedList在结构改变的操作中效率较高，但是在数据读取时由于需要从头遍历，所以效率较低。</p>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>ArrayList的<strong>线程安全版本</strong>，所有的可变（add、set、remove等）操作都是通过对底层的数组进行一次复制来实现。</p>
<h3 id="2个类常见的遍历同时操作的比较："><a href="#2个类常见的遍历同时操作的比较：" class="headerlink" title="2个类常见的遍历同时操作的比较："></a>2个类常见的遍历同时操作的比较：</h3><blockquote>
<p>ArrayList遍历同时操作：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">迭代方式\操作</th>
<th align="center">list.add</th>
<th align="center">iterator.remove</th>
<th align="center">list.remove</th>
</tr>
</thead>
<tbody><tr>
<td align="center">foreach方式</td>
<td align="center">报错</td>
<td align="center">–</td>
<td align="center">报错</td>
</tr>
<tr>
<td align="center">Iterator方式</td>
<td align="center">报错</td>
<td align="center">不报错</td>
<td align="center">报错</td>
</tr>
</tbody></table>
<blockquote>
<p>CopyOnWriteArrayList遍历同时操作：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">迭代方式\操作</th>
<th align="center">list.add</th>
<th align="center">iterator.remove</th>
<th align="center">list.remove</th>
</tr>
</thead>
<tbody><tr>
<td align="center">foreach方式</td>
<td align="center">不报错</td>
<td align="center">–</td>
<td align="center">不报错</td>
</tr>
<tr>
<td align="center">Iterator方式</td>
<td align="center">不报错</td>
<td align="center">报错</td>
<td align="center">不报错</td>
</tr>
</tbody></table>
<p>CopyOnWriteArrayList在Iterator使用list执行结构改变的操作不会报错的原因是Iterator创建的时候是返回了一个当前list的快照，这个快照生成的Iterator并不支持那些改变结构的操作，并且由于是快照，所以使用list.add等操作时，操作其实是“另一个”list。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8673264195747942595L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The lock protecting all mutators */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the array.  Non-private so as to also be accessible</span></span><br><span class="line"><span class="comment">     * from CopyOnWriteArraySet class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the array.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">        array = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此类使用<strong>volatile</strong>修饰的Object数组存储对象，因此保证了多线程下读的可见性（一致性），但不保证多线程下写的一致性，写的一致性靠<strong>ReentrantLock</strong>来保证：</p>
<blockquote>
<p>在所有的add，remove，set等写方法中，此类使用ReentrantLock.lock和ReentrantLock.unlock方法来保证写时的数据一致性。</p>
</blockquote>
<p>此类sublist方法使用ReentrantLock保证线程安全，但返回sublist还是原list的一个窗口。</p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列有FIFO（first in first out）的特性，元素从队尾入从队头出，但是双端队列可以不遵守此规则，根据需要选择入队出队的位置是头还是尾。<br>Queue/Deque的主要方法：</p>
<ol>
<li>add 插入元素到队列尾部，如果队列满了抛出异常，不会阻塞线程</li>
<li>offer 插入元素到队列尾部，如果队列满了，返回false，不会阻塞线程</li>
<li>remove 查看队列头元素并出队，空队列抛出异常，不会阻塞线程</li>
<li>poll 查看队列头元素并出队，不会阻塞线程</li>
<li>element 查看队列头元素，空队列抛出异常</li>
<li>peek 查看队列头元素</li>
<li>put 插入元素到队尾，没有空间则线程阻塞</li>
<li>take 出队，没有元素则线程阻塞</li>
</ol>
<table>
<thead>
<tr>
<th align="center">特点</th>
<th align="center">入队</th>
<th align="center">出队</th>
<th align="center">查看</th>
</tr>
</thead>
<tbody><tr>
<td align="center">不阻塞，抛异常</td>
<td align="center">add</td>
<td align="center">remove</td>
<td align="center">element</td>
</tr>
<tr>
<td align="center">不阻塞，不抛异常</td>
<td align="center">offer</td>
<td align="center">poll</td>
<td align="center">peek</td>
</tr>
<tr>
<td align="center">阻塞</td>
<td align="center">put</td>
<td align="center">take</td>
<td align="center">–</td>
</tr>
</tbody></table>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7720805057305804111L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">transient</span> Object[] queue; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;<span class="comment">//队列元素的数量&lt;=queue数组的length</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>优先队列使用Comparator来对元素进行排序，小的在前，大的在后，如果没有制定则按入队顺序。扩容时，如果容量小于64，则扩容为<br>原来的2倍，如果大于64,则扩容为原来的1.5倍。最大容量为int的最大值。在保证优先顺序时，只保证一个优先级，<br>并不会一定严格按照元素在Comparator里的大小顺序进行排列存储到数组中（存储的是完全二叉树构成的小顶堆）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;<span class="comment">//K是当前队列的size，x是新入队的元素</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            Object e = queue[parent];</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此方法使用的是和当前queue的长度n[n=(size-1)/2]下标处的元素用Comparator比较，如果返回大于等于0则将新加元素放到n处，并将n处的元素挪到队列尾处。<br>如果n处的元素还返回小于0,则再次向前以此方法递归换元素的位置。<br>object数组存储的是完全二叉树结构,可参考此处<a href=""http://www.cnblogs.com/CarpenterLee/p/5488070.html"">PriorityQueue</a>，这个操作其实是完全二叉树的插入操作。<br>如果需要按一定的顺序遍历元素，需要先将其转换为Array，并用stream排序。<br>此类<strong>非线程安全</strong>。<br>不允许添加null值。</p>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">817911632652898426L</span>;</span><br><span class="line">    <span class="comment">/** The queued items */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line">    <span class="comment">/** items index for next take, poll, peek or remove */</span></span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line">    <span class="comment">/** items index for next put, offer, or add */</span></span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line">    <span class="comment">/** Number of elements in the queue */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Main lock guarding all access */</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="comment">/** Condition for waiting takes */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    <span class="comment">/** Condition for waiting puts */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line">    <span class="keyword">transient</span> Itrs itrs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an &#123;<span class="doctag">@code</span> ArrayBlockingQueue&#125; with the given (fixed)</span></span><br><span class="line"><span class="comment">     * capacity and the specified access policy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity the capacity of this queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fair if &#123;<span class="doctag">@code</span> true&#125; then queue accesses for threads blocked</span></span><br><span class="line"><span class="comment">     *        on insertion or removal, are processed in FIFO order;</span></span><br><span class="line"><span class="comment">     *        if &#123;<span class="doctag">@code</span> false&#125; the access order is unspecified.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> capacity &lt; 1&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">        lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">        notEmpty = lock.newCondition();</span><br><span class="line">        notFull =  lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于<strong>数组</strong>实现的<strong>线程安全</strong>的<strong>有界</strong>队列，通过ReentrantLock及其条件，控制共享资源Object数组的操作。<br>构造函数中fair用于控制唤醒阻塞的访问线程是否按FIFO顺序。<br>使用takeIndex和putIndex记录将要出队和入队的元素将要放到items数组中的下标，putIndex一直增长，直到和数组长度相等时置为0，<br>takeIndex从0开始，一直增长，同样到数组长度后重置为0,当出现队列满了后，调用put会阻塞。队列为空时，调用take方法会阻塞。<br>不允许添加null值。</p>
<blockquote>
<p>此实现可以用于生产者-消费者模式。</p>
</blockquote>
<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>固定长度的基于单向链表结构的队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6903933977591709194L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Linked list node class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * One of:</span></span><br><span class="line"><span class="comment">         * - the real successor Node</span></span><br><span class="line"><span class="comment">         * - this Node, meaning the successor is head.next</span></span><br><span class="line"><span class="comment">         * - null, meaning there is no successor (this is the last node)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(E x) &#123; item = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The capacity bound, or Integer.MAX_VALUE if none */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Current number of elements */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Head of linked list.</span></span><br><span class="line"><span class="comment">     * Invariant: head.item == null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tail of linked list.</span></span><br><span class="line"><span class="comment">     * Invariant: last.next == null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>根据构造函数是否传入容量决定是否有界，最大容量为int最大值，超过容量抛出异常或等待一定时间后再抛出异常。通过内部单向链表实现队列，使用2个ReentrantLock控制数据的读取和新增，<br>由于2个锁相互独立，因此读写互不影响，在多线程情况下并发性能较高。无界的情况下，每次入队生成新的Node对象，出队产生废弃的Node对象，因此需要注意内存溢出。</p>
<blockquote>
<p>ArrayBlockingQueue 性能 &gt; LinkedBlockingQueue</p>
</blockquote>
<p>不允许添加null值。空队列包含一个空值Node，队head永远指向这个空值Node（出队时将正数第二个Node值弹出，然后将他的值设为空，变为队头）。</p>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>基于链表实现的线程安全的<strong>无界队列</strong>，由于<em>size方法需要遍历整个容器</em>，所以调用此方法时性能取决于队列中实际需要遍历的元素数量，并且由于在遍历过程中元素数量可能发生变化，导致得到一个错误的返回值。<br>不允许添加null值。初始时队列的head和tail指向空值的node。当队列元素为1时，head指向此节点，tail及其next指向一个空值节点，大于1个元素时，tail节点才会指向尾节点。</p>
<p>底层使用volatile保证多线程下可见性，UNSAFE的cas操作保证原子性，做到线程安全。</p>
<p>removeAll,retailAll,containsAll,equals,toArray,isEmpty,size方法并不保证原子性，因而不具有线程安全。</p>
<h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>通过一个ReentrantLock保证线程安全，内部封装PriorityQueue操作实现<strong>无界优先队列</strong>。逻辑上的无界，当无法申请到足够的内存空间时抛出OutOfMemory异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5595510919245408276L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The implementation uses an array-based binary heap, with public</span></span><br><span class="line"><span class="comment">     * operations protected with a single lock. However, allocation</span></span><br><span class="line"><span class="comment">     * during resizing uses a simple spinlock (used only while not</span></span><br><span class="line"><span class="comment">     * holding main lock) in order to allow takes to operate</span></span><br><span class="line"><span class="comment">     * concurrently with allocation.  This avoids repeated</span></span><br><span class="line"><span class="comment">     * postponement of waiting consumers and consequent element</span></span><br><span class="line"><span class="comment">     * build-up. The need to back away from lock during allocation</span></span><br><span class="line"><span class="comment">     * makes it impossible to simply wrap delegated</span></span><br><span class="line"><span class="comment">     * java.util.PriorityQueue operations within a lock, as was done</span></span><br><span class="line"><span class="comment">     * in a previous version of this class. To maintain</span></span><br><span class="line"><span class="comment">     * interoperability, a plain PriorityQueue is still used during</span></span><br><span class="line"><span class="comment">     * serialization, which maintains compatibility at the expense of</span></span><br><span class="line"><span class="comment">     * transiently doubling overhead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default array capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum size of array to allocate.</span></span><br><span class="line"><span class="comment">     * Some VMs reserve some header words in an array.</span></span><br><span class="line"><span class="comment">     * Attempts to allocate larger arrays may result in</span></span><br><span class="line"><span class="comment">     * OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Priority queue represented as a balanced binary heap: the two</span></span><br><span class="line"><span class="comment">     * children of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The</span></span><br><span class="line"><span class="comment">     * priority queue is ordered by comparator, or by the elements&#x27;</span></span><br><span class="line"><span class="comment">     * natural ordering, if comparator is null: For each node n in the</span></span><br><span class="line"><span class="comment">     * heap and each descendant d of n, n &lt;= d.  The element with the</span></span><br><span class="line"><span class="comment">     * lowest value is in queue[0], assuming the queue is nonempty.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of elements in the priority queue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The comparator, or null if priority queue uses elements&#x27;</span></span><br><span class="line"><span class="comment">     * natural ordering.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lock used for all public operations</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Condition for blocking when empty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spinlock for allocation, acquired via CAS.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> allocationSpinLock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A plain PriorityQueue used only for serialization,</span></span><br><span class="line"><span class="comment">     * to maintain compatibility with previous versions</span></span><br><span class="line"><span class="comment">     * of this class. Non-null only during serialization/deserialization.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;E&gt; q;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于有优先级的功能，可以用来做任务调度执行的排序等有顺序要求的功能。</p>
<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>无数据缓冲队列，每个put操作必须等待一个take操作，反之一样。队列没有实际容量，不能迭代。不允许使用null。提供公平策略，使put和take线程组按FIFO顺序put和take。volatile保证可见性，使用UNSAFE类进行CAS操作，<strong>线程安全</strong>。入队线程在没有put或take线程等待的时候，通过LockSupport调用UNSAFE的park方法挂起，在可以执行的时候调用unpark方法恢复。</p>
<blockquote>
<p>方法和注意事项：</p>
</blockquote>
<ol>
<li>此类Iterator直接返回Collections.emptyIterator()。hasNext永远返回false，next抛出NoSuchElementException异常。</li>
<li>peek永远返回null。</li>
<li>put线程调用put方法后一直等待有其他线程将其put的元素取走或已经有排队的线程，直接将元素取走。</li>
<li>offer方法会立即返回，不同的是如果没有等待的线程，返回false，如果已经有等待的线程，等待线程取走元素，offer方法返回true。此方法提供一个有等待时间的重载方法，允许offer线程等待一段时间后再返回。</li>
<li>take取出元素（即从put的线程获取元素），取不到就阻塞直到有其他线程put元素。</li>
<li>poll从put线程获取元素，此方法立即返回，只有恰好有其他线程put或offer元素或已经有put线程在等待时，才会获得元素，否则返回null。此方法提供一个有等待时间的重载方法，允许poll线程等待一段时间后再返回。</li>
<li>isEmpty永远返回true。</li>
<li>remainingCapacity永远返回0。</li>
<li>remove、removeAll、contains永远返回false。</li>
</ol>
<p>SynchronousQueue内部通过不同的数据结构实现公平策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        transferer = fair ? <span class="keyword">new</span> TransferQueue&lt;E&gt;() : <span class="keyword">new</span> TransferStack&lt;E&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>非公平模式下使用栈结构，公平模式下使用队列结构。</p>
<h3 id="核心方法为transfer以及node实现"><a href="#核心方法为transfer以及node实现" class="headerlink" title="核心方法为transfer以及node实现"></a>核心方法为transfer以及node实现</h3><h4 id="queue模式"><a href="#queue模式" class="headerlink" title="queue模式"></a>queue模式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">           <span class="comment">/* Basic algorithm is to loop trying to take either of</span></span><br><span class="line"><span class="comment">            * two actions:</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * 1. 如果队列是空的或新入队的线程与等待线程队列的操作相同（都是put线程或者都是          </span></span><br><span class="line"><span class="comment">            * take线程），则尝试将此线程加入到等待队列中，等待有相反操作的线程到来或取消等待（被中断），操作成功会返回node的item值。</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * 2. 如果队列不为空，并且入队的线程为等待线程队列的相反操作线程，尝试执行CAS操作，并将第* 一个入队的线程弹出，并返回put线程的item值。</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * 在上面的操作中，每次操作成功都会尝试变更队列的head和tail的位置。</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * 在循环一开始，检查head或tail为null,如果为null则重置循环. </span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           QNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">           <span class="keyword">boolean</span> isData = (e != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               QNode t = tail;</span><br><span class="line">               QNode h = head;</span><br><span class="line">               <span class="keyword">if</span> (t == <span class="keyword">null</span> || h == <span class="keyword">null</span>)         <span class="comment">// saw uninitialized value</span></span><br><span class="line">                   <span class="keyword">continue</span>;                       <span class="comment">// spin</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (h == t || t.isData == isData) &#123; <span class="comment">// empty or same-mode</span></span><br><span class="line">                   QNode tn = t.next;</span><br><span class="line">                   <span class="keyword">if</span> (t != tail)                  <span class="comment">// inconsistent read</span></span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;               <span class="comment">// lagging tail</span></span><br><span class="line">                       advanceTail(t, tn);</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)        <span class="comment">// can&#x27;t wait</span></span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                       s = <span class="keyword">new</span> QNode(e, isData);</span><br><span class="line">                   <span class="keyword">if</span> (!t.casNext(<span class="keyword">null</span>, s))        <span class="comment">// failed to link in</span></span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                   advanceTail(t, s);              <span class="comment">// swing tail and wait</span></span><br><span class="line">                   Object x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line">                   <span class="keyword">if</span> (x == s) &#123;                   <span class="comment">// wait was cancelled</span></span><br><span class="line">                       clean(t, s);</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (!s.isOffList()) &#123;           <span class="comment">// not already unlinked</span></span><br><span class="line">                       advanceHead(t, s);          <span class="comment">// unlink if head</span></span><br><span class="line">                       <span class="keyword">if</span> (x != <span class="keyword">null</span>)              <span class="comment">// and forget fields</span></span><br><span class="line">                           s.item = s;</span><br><span class="line">                       s.waiter = <span class="keyword">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line"></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// complementary-mode</span></span><br><span class="line">                   QNode m = h.next;               <span class="comment">// node to fulfill</span></span><br><span class="line">                   <span class="keyword">if</span> (t != tail || m == <span class="keyword">null</span> || h != head)</span><br><span class="line">                       <span class="keyword">continue</span>;                   <span class="comment">// inconsistent read</span></span><br><span class="line"></span><br><span class="line">                   Object x = m.item;</span><br><span class="line">                   <span class="keyword">if</span> (isData == (x != <span class="keyword">null</span>) ||    <span class="comment">// m already fulfilled</span></span><br><span class="line">                       x == m ||                   <span class="comment">// m cancelled</span></span><br><span class="line">                       !m.casItem(x, e)) &#123;         <span class="comment">// lost CAS</span></span><br><span class="line">                       advanceHead(h, m);          <span class="comment">// dequeue and retry</span></span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   advanceHead(h, m);              <span class="comment">// successfully fulfilled</span></span><br><span class="line">                   LockSupport.unpark(m.waiter);</span><br><span class="line">                   <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">QNode</span> </span>&#123;</span><br><span class="line">            <span class="keyword">volatile</span> QNode next;          <span class="comment">// next node in queue</span></span><br><span class="line">            <span class="keyword">volatile</span> Object item;         <span class="comment">// put的值，CAS&#x27;ed to or from null</span></span><br><span class="line">            <span class="keyword">volatile</span> Thread waiter;       <span class="comment">// 调用put或take的线程，to control park/unpark</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> isData; <span class="comment">//是否有值，有为put操作，没有为take操作，区分互补的2种操作线程</span></span><br><span class="line"></span><br><span class="line">            QNode(Object item, <span class="keyword">boolean</span> isData) &#123;</span><br><span class="line">                <span class="keyword">this</span>.item = item;</span><br><span class="line">                <span class="keyword">this</span>.isData = isData;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(QNode cmp, QNode val)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> next == cmp &amp;&amp;</span><br><span class="line">                    UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(Object cmp, Object val)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> item == cmp &amp;&amp;</span><br><span class="line">                    UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Tries to cancel by CAS&#x27;ing ref to this as item.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">tryCancel</span><span class="params">(Object cmp)</span> </span>&#123;</span><br><span class="line">                UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> item == <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Returns true if this node is known to be off the queue</span></span><br><span class="line"><span class="comment">             * because its next pointer has been forgotten due to</span></span><br><span class="line"><span class="comment">             * an advanceHead operation.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">isOffList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> next == <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Unsafe mechanics</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> itemOffset;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">static</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                    Class&lt;?&gt; k = QNode.class;</span><br><span class="line">                    itemOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                        (k.getDeclaredField(<span class="string">&quot;item&quot;</span>));</span><br><span class="line">                    nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                        (k.getDeclaredField(<span class="string">&quot;next&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="stack模式"><a href="#stack模式" class="headerlink" title="stack模式"></a>stack模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Basic algorithm is to loop trying one of three actions:</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 1. If apparently empty or already containing nodes of same</span></span><br><span class="line"><span class="comment">             *    mode, try to push node on stack and wait for a match,</span></span><br><span class="line"><span class="comment">             *    returning it, or null if cancelled.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 2. If apparently containing node of complementary mode,</span></span><br><span class="line"><span class="comment">             *    try to push a fulfilling node on to stack, match</span></span><br><span class="line"><span class="comment">             *    with corresponding waiting node, pop both from</span></span><br><span class="line"><span class="comment">             *    stack, and return matched item. The matching or</span></span><br><span class="line"><span class="comment">             *    unlinking might not actually be necessary because of</span></span><br><span class="line"><span class="comment">             *    other threads performing action 3:</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 3. If top of stack already holds another fulfilling node,</span></span><br><span class="line"><span class="comment">             *    help it out by doing its match and/or pop</span></span><br><span class="line"><span class="comment">             *    operations, and then continue. The code for helping</span></span><br><span class="line"><span class="comment">             *    is essentially the same as for fulfilling, except</span></span><br><span class="line"><span class="comment">             *    that it doesn&#x27;t return the item.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            SNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">            <span class="keyword">int</span> mode = (e == <span class="keyword">null</span>) ? REQUEST : DATA;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                SNode h = head;</span><br><span class="line">                <span class="keyword">if</span> (h == <span class="keyword">null</span> || h.mode == mode) &#123;  <span class="comment">// empty or same-mode</span></span><br><span class="line">                    <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) &#123;      <span class="comment">// can&#x27;t wait</span></span><br><span class="line">                        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.isCancelled())</span><br><span class="line">                            casHead(h, h.next);     <span class="comment">// pop cancelled node</span></span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class="line">                        SNode m = awaitFulfill(s, timed, nanos);</span><br><span class="line">                        <span class="keyword">if</span> (m == s) &#123;               <span class="comment">// wait was cancelled</span></span><br><span class="line">                            clean(s);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> ((h = head) != <span class="keyword">null</span> &amp;&amp; h.next == s)</span><br><span class="line">                            casHead(h, s.next);     <span class="comment">// help s&#x27;s fulfiller</span></span><br><span class="line">                        <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) &#123; <span class="comment">// try to fulfill</span></span><br><span class="line">                    <span class="keyword">if</span> (h.isCancelled())            <span class="comment">// already cancelled</span></span><br><span class="line">                        casHead(h, h.next);         <span class="comment">// pop and retry</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (;;) &#123; <span class="comment">// loop until matched or waiters disappear</span></span><br><span class="line">                            SNode m = s.next;       <span class="comment">// m is s&#x27;s match</span></span><br><span class="line">                            <span class="keyword">if</span> (m == <span class="keyword">null</span>) &#123;        <span class="comment">// all waiters are gone</span></span><br><span class="line">                                casHead(s, <span class="keyword">null</span>);   <span class="comment">// pop fulfill node</span></span><br><span class="line">                                s = <span class="keyword">null</span>;           <span class="comment">// use new node next time</span></span><br><span class="line">                                <span class="keyword">break</span>;              <span class="comment">// restart main loop</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            SNode mn = m.next;</span><br><span class="line">                            <span class="keyword">if</span> (m.tryMatch(s)) &#123;</span><br><span class="line">                                casHead(s, mn);     <span class="comment">// pop both s and m</span></span><br><span class="line">                                <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                            &#125; <span class="keyword">else</span>                  <span class="comment">// lost match</span></span><br><span class="line">                                s.casNext(m, mn);   <span class="comment">// help unlink</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// help a fulfiller</span></span><br><span class="line">                    SNode m = h.next;               <span class="comment">// m is h&#x27;s match</span></span><br><span class="line">                    <span class="keyword">if</span> (m == <span class="keyword">null</span>)                  <span class="comment">// waiter is gone</span></span><br><span class="line">                        casHead(h, <span class="keyword">null</span>);           <span class="comment">// pop fulfilling node</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        SNode mn = m.next;</span><br><span class="line">                        <span class="keyword">if</span> (m.tryMatch(h))          <span class="comment">// help match</span></span><br><span class="line">                            casHead(h, mn);         <span class="comment">// pop both h and m</span></span><br><span class="line">                        <span class="keyword">else</span>                        <span class="comment">// lost match</span></span><br><span class="line">                            h.casNext(m, mn);       <span class="comment">// help unlink</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SNode</span> </span>&#123;</span><br><span class="line">            <span class="keyword">volatile</span> SNode next;        <span class="comment">// next node in stack</span></span><br><span class="line">            <span class="keyword">volatile</span> SNode match;       <span class="comment">// the node matched to this</span></span><br><span class="line">            <span class="keyword">volatile</span> Thread waiter;     <span class="comment">// to control park/unpark</span></span><br><span class="line">            Object item;                <span class="comment">// data; or null for REQUESTs</span></span><br><span class="line">            <span class="keyword">int</span> mode;</span><br><span class="line">            <span class="comment">// Note: item and mode fields don&#x27;t need to be volatile</span></span><br><span class="line">            <span class="comment">// since they are always written before, and read after,</span></span><br><span class="line">            <span class="comment">// other volatile/atomic operations.</span></span><br><span class="line"></span><br><span class="line">            SNode(Object item) &#123;</span><br><span class="line">                <span class="keyword">this</span>.item = item;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(SNode cmp, SNode val)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cmp == next &amp;&amp;</span><br><span class="line">                    UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Tries to match node s to this node, if so, waking up thread.</span></span><br><span class="line"><span class="comment">             * Fulfillers call tryMatch to identify their waiters.</span></span><br><span class="line"><span class="comment">             * Waiters block until they have been matched.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> s the node to match</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span> true if successfully matched to s</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">tryMatch</span><span class="params">(SNode s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (match == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, matchOffset, <span class="keyword">null</span>, s)) &#123;</span><br><span class="line">                    Thread w = waiter;</span><br><span class="line">                    <span class="keyword">if</span> (w != <span class="keyword">null</span>) &#123;    <span class="comment">// waiters need at most one unpark</span></span><br><span class="line">                        waiter = <span class="keyword">null</span>;</span><br><span class="line">                        LockSupport.unpark(w);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> match == s;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Tries to cancel a wait by matching node to itself.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">tryCancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, matchOffset, <span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> match == <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Unsafe mechanics</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> matchOffset;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">static</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                    Class&lt;?&gt; k = SNode.class;</span><br><span class="line">                    matchOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                        (k.getDeclaredField(<span class="string">&quot;match&quot;</span>));</span><br><span class="line">                    nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                        (k.getDeclaredField(<span class="string">&quot;next&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>操作的线程为互补线程，通过isData区分，true为put，false为take，生成2种对应的node，操作时，如果等待线程是空的，线程挂起，进入等待线程组，后面的线程入队时，判断与已经等待的线程是不是同一种操作，如果是，挂起进入等待线程组，如果是相反的互补操作，则执行transfar操作，根据策略不同，唤醒一个在等待的线程，返回数据，并将唤醒的线程移出等待线程组，并更新SynchronousQueue的头和尾。</p>
<blockquote>
<p>可用于线程间通讯。需要严格遵守生产者消费者模式的场景。Executors.newCachedThreadPool()任务队列就使用SynchronousQueue。</p>
</blockquote>
<h2 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h2><p>类似SynchronousQueue，但实现的是公平模式下的SynchronousQueue且<strong>具有实际的容量的无界阻塞队列</strong>，put或take线程遵守FIFO。原理与SynchronousQueue一样，LinkedTransferQueue维护一个等待线程组，这个线程组类型全为take或者全为put，当与其互补的一个线程到来后，立即唤醒等待的第一个线程，完成数据的传递，并出队，当与其类型相同的一个线程到来后，生成一个新的节点入队。</p>
<blockquote>
<p>与SynchronousQueue不同，LinkedTransferQueue实现了Collection和Iterator的接口，有实际返回值，且可以使用put，</p>
</blockquote>
<blockquote>
<p>和ConcurrentLinkedQueue一样，removeAll,retailAll,containsAll,equals,toArray,isEmpty,size方法并不保证原子性，因而不具有线程安全,并且size方法需要遍历整个队列，时间取决于队列中节点数量。</p>
</blockquote>
<p>重要的方法：</p>
<ol>
<li>transfer(E e)：若当前存在一个正在等待获取的消费者线程，即立刻移交之；否则，会插入当前元素e到队列尾部，并且等待进入阻塞状态，到有消费者线程取走该元素。</li>
<li>tryTransfer(E e)：若当前存在一个正在等待获取的消费者线程（使用take()或者poll()函数），使用该方法会即刻转移/传输对象元素e；若不存在，则返回false，并且不进入队列。这是一个不阻塞的操作。</li>
<li>tryTransfer(E e, long timeout, TimeUnit unit)：若当前存在一个正在等待获取的消费者线程，会立即传输给它;否则将插入元素e到队列尾部，并且等待被消费者线程获取消费掉；若在指定的时间内元素e无法被消费者线程获取，则返回false，同时该元素被移除。</li>
<li>hasWaitingConsumer()：判断是否存在消费者线程。</li>
<li>getWaitingConsumerCount()：获取所有等待获取元素的消费线程数量。</li>
</ol>
<p><strong>transfer方法保证了队列中新加入节点之前的节点都被消费过。</strong></p>
<h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements all queuing methods. See above for explanation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the item or null for take</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> haveData true if this is a put, else a take</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> how NOW, ASYNC, SYNC, or TIMED</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nanos timeout in nanosecs, used only if mode is TIMED</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an item if matched, else e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if haveData mode but e is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">xfer</span><span class="params">(E e, <span class="keyword">boolean</span> haveData, <span class="keyword">int</span> how, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (haveData &amp;&amp; (e == <span class="keyword">null</span>))<span class="comment">//操作类型和数据是否匹配，匹配才往下执行</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Node s = <span class="keyword">null</span>;                        <span class="comment">// the node to append, if needed</span></span><br><span class="line"></span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;                            <span class="comment">// restart on append race</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Node h = head, p = h; p != <span class="keyword">null</span>;) &#123; <span class="comment">// find &amp; match first node</span></span><br><span class="line">                <span class="keyword">boolean</span> isData = p.isData;</span><br><span class="line">                Object item = p.item;</span><br><span class="line">                <span class="keyword">if</span> (item != p &amp;&amp; (item != <span class="keyword">null</span>) == isData) &#123; <span class="comment">// unmatched</span></span><br><span class="line">                    <span class="keyword">if</span> (isData == haveData)   <span class="comment">// 操作类型相同，中断互补查找</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (p.casItem(item, e)) &#123; <span class="comment">// 操作类型不同，使用cas操作尝试将找到的节点操作状态变更，如果成功则继续</span></span><br><span class="line">                        <span class="keyword">for</span> (Node q = p; q != h;) &#123;</span><br><span class="line">                            Node n = q.next;  <span class="comment">// update by 2 unless singleton</span></span><br><span class="line">                            <span class="keyword">if</span> (head == h &amp;&amp; casHead(h, n == <span class="keyword">null</span> ? q : n)) &#123;</span><br><span class="line">                                h.forgetNext();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;                 <span class="comment">// advance and retry</span></span><br><span class="line">                            <span class="keyword">if</span> ((h = head)   == <span class="keyword">null</span> ||</span><br><span class="line">                                (q = h.next) == <span class="keyword">null</span> || !q.isMatched())</span><br><span class="line">                                <span class="keyword">break</span>;        <span class="comment">// unless slack &lt; 2</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        LockSupport.unpark(p.waiter);</span><br><span class="line">                        <span class="keyword">return</span> LinkedTransferQueue.&lt;E&gt;cast(item);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//进行目标节点后移和头节点修正</span></span><br><span class="line">                Node n = p.next;</span><br><span class="line">                p = (p != n) ? n : (h = head); <span class="comment">// Use head if p offlist</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (how != NOW) &#123;                 <span class="comment">//没有找到互补节点的操作，将调用线程和数据生成新node入队</span></span><br><span class="line">                <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                    s = <span class="keyword">new</span> Node(e, haveData);</span><br><span class="line">                Node pred = tryAppend(s, haveData);</span><br><span class="line">                <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">continue</span> retry;           <span class="comment">// lost race vs opposite mode</span></span><br><span class="line">                <span class="keyword">if</span> (how != ASYNC)</span><br><span class="line">                    <span class="keyword">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e; <span class="comment">// not waiting</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>基于PriorityQueue实现的以过期时间作为优先排序的线程安全无界阻塞队列，不允许存放null值，且存放元素需要实现Delayed接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *领导追随者模式的leader线程，take和带有超时时间的poll方法执行时，如果队首为 *null或队首超时时间没到，则设置当前线程为leader并在available上一直wait或   *wait剩下的超时时间，直到收到信号继续执行或过了</span></span><br><span class="line"><span class="comment">     *wait时间，继续尝试获取并移除队首</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Condition signalled when a newer element becomes available</span></span><br><span class="line"><span class="comment">     * at the head of the queue or a new thread may need to</span></span><br><span class="line"><span class="comment">     * become leader.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>队首元素为超时元素，超时元素通过take/poll方法中通过死循环结合线程等待来判断，由于是使用ReentrantLock封装的优先队列（在priorityQueue的方法调用外使用lock），元素在入队时已经调整了存储的二叉树结构，并且在每次take/off后都会进行结构调整，所以保证了每次取到的队首都是最近要过期的。</p>
<h1 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h1><h2 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h2><p><em>基于可变数组实现的无界双端队列（最大为int最大值）</em>，数组用于存储入队的元素，通过下标标记出队头和队尾，不能存放null元素，非线程安全。下列方法时间复杂度随存放元素的多少呈线性增长（因为方法内对数组进行遍历）：</p>
<blockquote>
<p>remove、removeFirstOccurrence、removeLastOccurrence、contains、iterator.remove() 以及批量操作</p>
</blockquote>
<p>同ArrayList一样，iterator迭代时，如果不是通过iterator对结构做出改变，会使得并发的iterator和for遍历操作抛出ConcurrentModificationException，且此异常并不保证一定抛出，因此不能依赖此异常的抛出做任何业务上的逻辑处理。<br>ArrayDeque每次扩容后的新容量为原来的2倍。内部elements数组在实现队列时，队头从数组<strong>下标高位</strong>开始，队尾从数组<strong>下标低位</strong>开始。head下标的有元素，获取是直接获取下标对应元素，tail小标没有元素，每次获取时需要执行tail-1获取下标，再取元素。当head==tail+1或head-1==tail时，数组进行扩容。<br>ArrayDeque可用于堆栈和队列。合理的使用情况下，性能优于Stack和LinkedList。</p>
<h3 id="addFirst-offerFirst-push"><a href="#addFirst-offerFirst-push" class="headerlink" title="addFirst==offerFirst==push"></a>addFirst==offerFirst==push</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//head从高位开始，每次从头入队</span></span><br><span class="line">        elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;</span><br><span class="line">        <span class="keyword">if</span> (head == tail)</span><br><span class="line">            doubleCapacity();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="addLast-offerLast-add"><a href="#addLast-offerLast-add" class="headerlink" title="addLast==offerLast==add"></a>addLast==offerLast==add</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        elements[tail] = e;</span><br><span class="line">        <span class="comment">//每次tail存放后会检查下次入队是否会使head==tail，如果会就扩容，也就是说每次从尾部入队至少会保证有一个位置是空的，使从头部入队不会覆盖元素</span></span><br><span class="line">        <span class="comment">//并且更新tail=tail+1，即真实的tail在数组中的位置为tail-1，tail处并没有元素</span></span><br><span class="line">        <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)</span><br><span class="line">            doubleCapacity();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doubleCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> head == tail;</span><br><span class="line">        <span class="keyword">int</span> p = head;</span><br><span class="line">        <span class="keyword">int</span> n = elements.length;</span><br><span class="line">        <span class="keyword">int</span> r = n - p; <span class="comment">// number of elements to the right of p</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Sorry, deque too big&quot;</span>);</span><br><span class="line">        Object[] a = <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">        <span class="comment">//将原来数组从head到数组结束的元素拷贝到新数组</span></span><br><span class="line">        System.arraycopy(elements, p, a, <span class="number">0</span>, r);</span><br><span class="line">        <span class="comment">//将原来数组从tail倒数到下标0处的元素拷贝到新数组</span></span><br><span class="line">        System.arraycopy(elements, <span class="number">0</span>, a, r, p);</span><br><span class="line">        <span class="comment">//原来的队列是分离的，首尾在物理上并不保持由首到尾的关系，copy后，在新的数组靠前的位置形成物理上由首到尾关系的队列，相当于原来tail所领导的元素划拨给了head领导</span></span><br><span class="line">        elements = a;</span><br><span class="line">        head = <span class="number">0</span>;<span class="comment">//下次head位置会变到新数组的末尾</span></span><br><span class="line">        tail = n;<span class="comment">//修正尾部</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//tail-head为负数，&amp;运算后得到正确的容量，相当于elements.length-|(tail - head)|</span></span><br><span class="line">        <span class="keyword">return</span> (tail - head) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="pollFirst-removeFirst-pop-remove-poll"><a href="#pollFirst-removeFirst-pop-remove-poll" class="headerlink" title="pollFirst=removeFirst==pop==remove==poll"></a>pollFirst=removeFirst==pop==remove==poll</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = head;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        E result = (E) elements[h];</span><br><span class="line">        <span class="comment">// Element is null if deque empty</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        elements[h] = <span class="keyword">null</span>;     <span class="comment">// Must null out slot</span></span><br><span class="line">        head = (h + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="pollLast-removeLast"><a href="#pollLast-removeLast" class="headerlink" title="pollLast==removeLast"></a>pollLast==removeLast</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = (tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        E result = (E) elements[t];</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        elements[t] = <span class="keyword">null</span>;</span><br><span class="line">        tail = t;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h2><p>基于双链表结构，可指定容量的双端阻塞队列。容量不指定时，取int的最大值。不超过容量的情况下，每次入队时生成新的节点。<br>大部分的操作时间复杂度都是O(1)，但一部分操作需要遍历整个队列，时间复杂度O(n)，随队列中元素数量增长而线性增长。这些方法包括：</p>
<blockquote>
<p>remove、removeFirstOccurrence、removeLastOccurrence、contains、iterator.remove()</p>
</blockquote>
<p>注意此类并<strong>没有提供批量操作</strong>（被注释去掉）。<br>使用一个ReentrantLock及2个Conditon进行并发控制。</p>
<blockquote>
<p>ReentrantLock：入队和出队操作并发时线程安全。<br>Conditon：队列为空时阻塞读取操作，队列满时阻塞入队操作。</p>
</blockquote>
<p>此类提供的迭代器是弱一致性模型迭代器，在多线程并发情况下，使用迭代器可能出现数据不一致且不会抛出异常的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingDeque</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingDeque</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">387911632671998426L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Doubly-linked list node class */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The item, or null if this node has been removed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        E item;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * One of:</span></span><br><span class="line"><span class="comment">         * - the real predecessor Node</span></span><br><span class="line"><span class="comment">         * - this Node, meaning the predecessor is tail</span></span><br><span class="line"><span class="comment">         * - null, meaning there is no predecessor</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * One of:</span></span><br><span class="line"><span class="comment">         * - the real successor Node</span></span><br><span class="line"><span class="comment">         * - this Node, meaning the successor is head</span></span><br><span class="line"><span class="comment">         * - null, meaning there is no successor</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(E x) &#123;</span><br><span class="line">            item = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to first node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to last node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 队列中的元素数量 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 队列容量 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 并发控制锁 */</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 队列不为空条件，take类方法在此条件阻塞 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 队列不满条件，put类方法在此条件阻塞 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="ConcurrentLinkedDeque"><a href="#ConcurrentLinkedDeque" class="headerlink" title="ConcurrentLinkedDeque"></a>ConcurrentLinkedDeque</h2><p>基于双链表的无界无阻塞线程安全双端队列。不能添加null元素。<br>此类提供的迭代器是弱一致性模型迭代器，在多线程并发情况下，使用迭代器可能出现数据不一致且不会抛出异常的情况。<br>addAll,ermoveAll,retainAll,containsAll,equals,toArray操作不是原子性操作，因而不具有线程安全。<br>size方法由于需要遍历这个链表，性能较低，复杂度为O(n)。使用CAS实现无锁算法（lock-free）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentLinkedDeque</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">876323262645176354L</span>;</span><br><span class="line">    <span class="comment">//队头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line">    <span class="comment">//队尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Node&lt;Object&gt; PREV_TERMINATOR, NEXT_TERMINATOR;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function">Node&lt;E&gt; <span class="title">prevTerminator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Node&lt;E&gt;) PREV_TERMINATOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function">Node&lt;E&gt; <span class="title">nextTerminator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Node&lt;E&gt;) NEXT_TERMINATOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;E&gt; prev;</span><br><span class="line">        <span class="keyword">volatile</span> E item;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        Node() &#123;  <span class="comment">// default constructor for NEXT_TERMINATOR, PREV_TERMINATOR</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Constructs a new node.  Uses relaxed write because item can</span></span><br><span class="line"><span class="comment">         * only be seen after publication via casNext or casPrev.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node(E item) &#123;</span><br><span class="line">            UNSAFE.putObject(<span class="keyword">this</span>, itemOffset, item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp, E val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">            UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">lazySetPrev</span><span class="params">(Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">            UNSAFE.putOrderedObject(<span class="keyword">this</span>, prevOffset, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casPrev</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, prevOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unsafe mechanics</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> prevOffset;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> itemOffset;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class&lt;?&gt; k = Node.class;</span><br><span class="line">                prevOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">&quot;prev&quot;</span>));</span><br><span class="line">                itemOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">&quot;item&quot;</span>));</span><br><span class="line">                nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">&quot;next&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = tail = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> headOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> tailOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        PREV_TERMINATOR = <span class="keyword">new</span> Node&lt;Object&gt;();</span><br><span class="line">        PREV_TERMINATOR.next = PREV_TERMINATOR;</span><br><span class="line">        NEXT_TERMINATOR = <span class="keyword">new</span> Node&lt;Object&gt;();</span><br><span class="line">        NEXT_TERMINATOR.prev = NEXT_TERMINATOR;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = ConcurrentLinkedDeque.class;</span><br><span class="line">            headOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;head&quot;</span>));</span><br><span class="line">            tailOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;tail&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始时，head和tail同时指向空值节点，如果第一个元素从队头入队时，新生成一个节点，head（tail）节点prev指向新节点，如果第一个元素从队尾入队时，新生成一个节点，head(tail)的next指向新节点。如果元素一开始从队头入队（addFirst），之后当有元素从队尾入队，从队头入队的元素和从队尾入队的元素之间会有空值节点，仅当第二从队尾入队操作结束，才会消除空值节点。如果元素一开始从队尾入队，然后又元素从队头入队，2种操作的元素之间会一直存在一个空值节点。</p>
<h2 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>见LinkedList</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title>ORACLE RAC</title>
    <url>/2015/06/13/oracle-rac/</url>
    <content><![CDATA[<p>Oracle RAC的优势在于利用多个节点（数据库实例）组成一个数据库，这样在保证了数据库高可用性的情况下更充分的利用了多个主机的性能，而且可以通过增加节点进行性能的扩展。实现Oracle RAC需要解决的关键问题就是多节点进行数据访问时如何保证数据的一致性，Oracle是通过各节点间的私有连接进行内存融合（cache fusion）来保证各节点数据访问的一致性。用一个例子来解释一下内存融合的过程，在存在A、B两个节点的RAC环境中，当A节点使用DML语句（如Update）对一个数据块中的数据进行修改时，A节点实例会到GRD（Global Resource Directory）中查找该数据块的信息，这些信息包括该数据块的Master（第一次读这个数据块的节点），Owner（当前拥有这个数据块的节点），以及数据块在各个节点间的传递记录。A节点如果发现GRD中没有需要读取的数据块的信息，说明该数据块是一个干净的数据块，A节点从磁盘或Buffer Cache中获得该数据块，然后对需要修改的行加锁，进行相应的修改，当然SCN会随之增加。在A完成修改而没有提交或回滚的情况下，如果B节点也需要访问这个数据块修改某些行（假设不同于A修改的行），B同样去到GRD中查找该数据块的信息，当然B发现该数据块的Master为A，Owner也为A，为了保证A的修改不丢失，B需要发信息给A，让A将需要修改的数据块通过私有连接直接从内存中传给B，当然该数据块中包含A的锁信息，这样A节点与B节点间的一次内存的数据传递就是内存融合。Oracle RAC的内存融合也面临一些问题，继续刚刚的例子，如果A又再次请求对该数据块修改或者结束事务（提交或回滚）的时候，又需要从B节点内存中取得数据块，又要发生内存融合，这样在两个节点业务没有合理分割的情况下，数据库繁忙时，大量的内存融合会对数据库性能造成严重的影响。通过对Oracle RAC技术的理解，在实现Oracle RAC架构时的业务分割就成为了保证系统性能的重要手段，业务分割的根本在于使不同的实例不能访问相同的数据块，这样业务分割规则可以小到表的级别（不同的表不会共享一个数据块），大到表空间、Schema的级别。心跳应该用独立的网卡。</p>
<p>　　当然，rac本身之保证了数据库服务器的高可用和高性能，所以最好有其他的存储技术来保证存储的高可用，例如raid\vplex等。</p>
<p>　　在距离不太远（几十公里），且速度较快（例如裸光纤）下，延时较小，，米足够多，可以考虑使用oracle rac实现双活或者灾备，RTO RPO=0。</p>
<span id="more"></span>
<p>附：<br>1.rac基本理论知识<br>1.1 Public NIC接入公共网络，private NIC接入私有网络，这是个完全隔离的网络传递的数据只是RAC节点的心跳数据和cache fusion数据。oracle不建议私有网络直接用交叉线连接。</p>
<p>1.2 RAC最重要的是共享存储。数据文件、联机日志、控制文件、参数文件都必须放在共享存储上。现在的存储环境基本上都是基于SAN的，跑FC协议（FC协议封装了SCSI协议）。</p>
<p>1.3 RAC环境需要OS必须版本相同包括小版本、补丁包都必须一致。</p>
<p>1.4 集群件安装在OS之上，负责管理整个集群环境中的硬件资源并为上层的RAC集群提供基础服务。如果把集群看成是一台虚拟的计算机，那么集群件就是这台计算机上的OS，而RAC是运行在其上的一个应用。</p>
<p>10g之前，oracle只针对linux、windows两个OS提供了一个不完善的集群件产品OCM（oracle cluster manager），其它平台需要第三方集群产品比如HACMP、sun cluster。10g开始，10.1版本提供CRS，10.2版            本提供oracle clusterware（10.1的改名）。10.2开始的集群件提供API接口，因此还能够为其它软件提供HA功能。CRS可以和其它集群件产品集成。10g之前oralce只提供对裸设备的支持，所以9i RAC裸设备是常见选择。10后oracle提供OCFS和ASM两种存储方案。</p>
<p>1.5 OEL(oracle enterprise linux)是oracle在RHEL基础上重新开发出的linux。</p>
<p>1.6 需要强调的是，10g的clusterware的vote disk、ocr在目前的版本上还只能创建在裸设备、ocfs上。VIP在clusterware安装过程中创建（调用VIPCA)，不需要手工设置。</p>
<p>1.7 集群的分类：高性能计算集群（用在科学计算）、LB、HA、</p>
<p>1.8 健忘症：集群环境配置文件不是集中存放，每个节点都有一个本地副本，用户修改任何节点的集群配置会将更改同步到其它节点。但这样有一个问题：节点1正常维护需要关闭，然后在节点2修改了配置，然后节点2关闭，启动节点1，由于没有同步，所以节点1启动后，它用的仍然是旧的配置文件，这时就造成配置丢失，这就叫健忘症。RAC的解决方案是OCR。</p>
<p>1.9 脑裂:节点间了解彼此的健康状况是通过心跳机制来实现的。如果仅仅是心跳出了问题，各节点还正常运行，这时每个节点都认为其它节点宕机，自己是集群环境的唯一健在者自己应该获得集群的控制权，因为存储是共享的，这意味着数据灾难。这就叫脑裂。RAC解决脑裂的方法是引入Quorum disk，谁先得到quorum disk这一票谁获胜，另一个节点被踢出集群。</p>
<p>1.10 IO隔离：解决被踢出集群的节点不能操作共享存储上的数据。</p>
<p>1.11 CRS resource：CRS对运行于其上的应用进行监视，并在发生异常时进行重启、切换等干预手段。这些被CRS监控的对象就叫CRS resource。这些resource是在RAC安装过程中自动或手动创建的，并且注册登记到CRS中，以metadata的形式被记录在OCR磁盘上，这些metadata包括resource的名称、如何启动、停止、如何检查健康状况等配置信息。RAC的CRS resource包括GSD、ONS、VIP、database、instance、listener等。</p>
<p>1.12 oracle clusterware的运行环境由两个磁盘文件、若干后台进程及网络元素组成。OCR解决健忘问题，OCR位于共享存储上保存整个群集的配置，无论在哪个节点修改配置都是修改相同的配置文件。配置信息以“key-value的形式保存其中，10g以前这个文件叫server manageability repository（SRVM)。OCR的位置记录在ocr.loc文件中，9i对应的是srvConfig.loc文件。</p>
<p>1.13 能读写OCR disk中内容的节点称OCR master。这个节点的OCR process负责更新本地和其它节点的OCR cache。其它节点想修改OCR需要向本节点的OCR process提出请求，然后本节点的process再向OCR master的OCR process提出请求。</p>
<p>1.14 voting disk主要记录节点成员状态，在出现脑裂时，仲裁哪个partion获得集群的控制权。它的位置可以用这个命令来查看：$crsctl query css votedisk</p>
<p>1.15 clusterware最重要的三个后台进程：CRSD、CSSD、EVMD。在安装clusterware的最后阶段会要求在每个节点执行root.sh，目的是在/etc/inittab文件中添加三行使每次系统重启时，cluseter也会自动启动。EVMD和CRSD两个进程如果出现异常，系统会自动重启这两个进程。如果CSSD出现异常，系统会立即重启。</p>
<p>OCSSD进程：该进程提供CSS（cluster synchronization service）服务，CSS服务通过多种心跳机制实时监控集群健康状态，提供脑裂保护等基础集群服务功能。心跳机制包含两种：私有网络、voting disk。</p>
<p>两个心跳都有最大时延，对于disk heartbeat，这个时延叫IOT，对于network heartbeat，这个时延叫MC，两个参数都是以秒为单位，缺省IOT大于MC。可以通过以下命令来查看这两个参数：</p>
<p>$crsctl get css disktimeout      $crsctl get css misscount</p>
<p>另外这个进程还用来支持ASM instance和RDBMS instance之间的通信。如果在已经安装了ASM的节点上安装RAC，会遇到一个问题，RAC要求节点只有一个OCSSD进程，并且是运行在$CRS_HOME目录下的。这就需要先停止ASM，并通过$ORACLE_HOME/bin/localconfig.sh delete删除之前的inittab条目。</p>
<p>CRSD进程：实现HA的主要进程，它所提供的服务叫CRS（cluster ready service）它监控资源，并在资源运行异常时进行干预，包括关闭、重启进程或转移服务。默认情况下，CRS会自动尝试重启资源5次，如果还是失败则放弃尝试。</p>
<p>EVMD进程：负责发布CRS产生的各种事件，这些event可以通过两种方式发布给客户–ONS和callout script。另外它还负责CRSD和CSSD两个进程间的通信。</p>
<p>RACGIMON进程：负责检查数据库健康状态，负责service的启动、停止、故障转移，这个进程会建立到数据库的持久连接，定期检查SGA中的特定信息，该信息由PMON进程定时更新。</p>
<p>OPROCD进程：也叫process monitor daemon。在非linux平台且没有使用第三方集群软件时，会看到这个进程，用来检测节点的CPU挂起，如果调度时间超过1.5S，会认为CPU工作异常，会重启节点。在linux平台上时候时利用hangcheck-timer模块来实现IO隔离功能的。</p>
<p>1.16 IP利用的是TCP层超时，VIP利用的是应用层的立即响应。详见P94。</p>
<p>1.17 clusterware的日志体系比较复杂，日志的根目录在$CRS_HOME/log/[node]</p>
<p>1.18 单实例下的并发控制</p>
<p>lock框架包括3个组件：资源、锁、排队机制。前两者是数据结构，后者是使用算法。</p>
<p>资源：由owner、waiter、converter三个成员组成，这是3个指针分别指向lock组成的链表。</p>
<p>锁：当要访问共享资源时，需要锁定资源。如果不能获得资源的访问权，就把lock挂到资源的waiter链表中，如果能获得就挂到lock的owner链表中。</p>
<p>排队机制：lock使用的是enqueue的算法即“先入先出队列”。如进程的锁定不能满足，该进程的lock structure就被加到waiter链表的末端。</p>
<p>waiter和converter排队机制的区别：如果某个操作需要先后两种不同模式的锁，比如先share mode然后exclusive mode，则进程先请求share mode，获得后的lock structure会挂在owner上，当需要exclusive mode锁时，进程必须先释放share mode的锁，然后再次申请exclusive mode的锁，但是可能无法立即获得，这时这个请求就会被挂在converter队列下，converter队列会优先于waiter队列被处理。可以从v$lock看到这些lock信息。</p>
<p>LMODE&gt;0,REQUEST=0   Owner</p>
<p>LMODE=0,REQUEST&gt;0   Waiter（Acquirer）</p>
<p>LMODE&gt;0,REQUEST&gt;0   Converter</p>
<p>对于粗粒度或数量有限的资源使用这种机制还可以，但对于几百G的数据量，如果每条记录都分配一个resourece、lock数据结构，无论从内存需求还是维护开销都是一个噩梦。对于数据记录这种细粒度资源，oracle使用的是行级锁。行级锁其实只是数据块头、数据记录头的一些字段，不会消耗资源。所以它虽然有锁的功能，但无锁的开销。详见书的P102。</p>
<p>latch于lock的对比：latch请求、获得、释放等操作是原子操作，一般几个硬件指令就可以完成。lock相反。进程申请lock没有获得，这个进程会释放CPU资源，也就是进行上下文切换，整个过程较耗资源。如果进程申请latch没有获得，进程不释放CPU资源，而是不断的尝试请求，只有尝试了一定次数之后还不能获得，才释放CPU，这就是latch的spin机制。这时的表现是：CPU利用率非常高，但吞吐量却很低。另外latch使用的是抢占机制，而不是lock使用的排队机制。</p>
<p>1.19 DLM（分布式锁管理）：可以把它想象成一个仲裁，它记录着哪个节点正在用哪种方式操作哪个数据，并负责协调解决节点间的竞争。DLM在不同的阶段有不同的名称，OPS的叫PCM，RAC的叫cache fusion。</p>
<p>Non-Cache Fusion资源：典型的资源包括sharepool的row cache和library cache内容。通过每个节点的LCK0进程来同步。</p>
<p>Cache Fusion资源：buffer cache的数据块。数据块的状态可以从v$BH视图查看。</p>
<p>以上两种资源可以通过v$resource_limit来查看。</p>
<p>1.20 GRD：记录每个数据块在集群间的分布图。每个实例SGA中都是部分GRD，所有实例的GRD构成一个完整的GRD。</p>
<p>1.21 PCM lock：GRD中记录的是PCM lock信息，这种锁有3个属性：Mode、Role、PI。Role这个属性是用来描述脏数据块在集群间分布状况的，有local和global两个取值。有local role的实例可以把数据块写到磁盘不需要联系GRD，由本实例完成即可。拥有local role和X mode的实例要给其它instance发送这个数据块，如果发送的是和磁盘一致的版本，那么本实例任然保持local role。如果发送的是和磁盘不一致的版本，那么本实例的角色就转换成global，同时接收方也是global，代表多个实例拥有脏数据块版本。拥有global role的实例想把数据块写到磁盘，必须要联系GRD，由拥有数据块current版本的实例完成写动作。</p>
<p>PI: past image，代表着这个实例的SGA中是否拥有和磁盘内容不一致的版本，以及版本顺序，并不是代表这个节点是否曾经修改过这个数据块。PI主要能够加速crash recovery的恢复过程。</p>
<p>AST: DLM使用两个队列跟踪所有的lock请求，并用两个ASTs(异步中断或陷阱）来完成请求的发送和响应。具体的过程见书的P120。</p>
<p>1.22 RAC进程名称和进程提供的服务名称差异很大，不便记忆。造成这种现象是因为进程名称是从OPS时代延续下来的，但是服务名称却已经在RAC中重新设计并命名。</p>
<p>LMSn：负责数据块在实例间的传递，对应的服务叫GCS（global cache service）。进程的数据量通过参数GCS_SERVER_PROCESSES控制，默认是2，取值范围为：0-9。</p>
<p>LMD: 负责在多个实例之间协调对数据块的访问顺序，保证数据的一致性访问。它负责提供GES（global enqueue service）服务。GCS、GES、GRD构成RAC最核心的功能：cache fusion。</p>
<p>LCK：负责non-cache fusion资源的同步访问，每个实例有一个LCK进程。</p>
<p>LMON: 各实例的LMON进程会定期通信，以检查集群中各节点的健康状态，当某个节点出现故障时，负责集群重构、GRD恢复等操作，它提供的服务叫CGS（cluster group services）。LMON可以和下层的clusterware合作也可以单独工作。当LMON检测到实例级别的脑裂时，LMON会通知下层的clusterware，期待clusterware解决脑裂问题，但是RAC并不假设clusterware肯定能够解决问题，因此，LMON不会无尽等待clusterware层的处理结果。如果发生等待超时，LMON会自动触发IMR（instance membership recovery）IMR功能可以看做是oracle在数据库层提供的脑裂、IO隔离机制。LMON主要是借助两种心跳机制来完成健康检测：1、节点间的网络心跳。2、控制文件的磁盘心跳。每个节点的CKPT进程每隔3S更新一次控制文件一个数据块。可以通过x$kcccp看到这个动作。SQL&gt;select inst_id,cphbt from x$kcccp</p>
<p>DIAG: 监控实例的健康状态，并在实例出现运行错误时收集诊断数据记录到alert.log</p>
<p>GSD: 负责从客户端工具，比如srvctl接收用户命令，为用户提供管理接口。</p>
<p>1.23 RAC中的文件。</p>
<p>spfile文件：放在共享存储</p>
<p>redo thread： 每个实例有套redo log，这套redo log叫做一个redo thread。RAC中每个实例要设置thread参数，该参数缺省值时0。如果设置了这个参数，则实例启动时，会用等于该thread的private redo thread。如果用缺省值，实例启动会选择使用public redo thread，并且该实例会以独占的方式使用该redo thread。RAC环境下，redo log group是在整个数据库级别进行编号的，比如实例1有1，2，3三个日志组，那么实例2的日志组就应该从4开始编号。</p>
<p>归档日志：归档日志不必放在共享存储上，每个实例可以在本地存放归档日志，但是如果在单个实例进行备份归档日志或进行介质恢复操作，又要求这个节点能够访问到所有实例的归档日志。因此RAC环境下配置归档日志有多种选择：1、NFS。2、实例间归档。3、ASM。常用第二种方法进行配置。</p>
<p>undo表空间：每个实例都需要一个单独的回滚表空间。</p>
<p>1.24 RAC中的SCN。在单实例环境中只有一个SCN产生器，改变发生的顺序就是SCN的顺序。在RAC下，每个节点都有自己的SCN发生器，必须有某种机制保证这些SCN在时间排序上的精确。RAC中GCS负责维护全局的SCN产生，缺省用的时Lamport SCN生成算法。原理如下：节点间通信内容中都携带SCN，每个节点把接收到的SCN和本机的SCN比，如果本机的SCN小，则调整本机的SCN和接收到的一致。如果节点间通信不多，还会主动定期互相通报，因此节点即使处于idle状态，还是会有一些redo log的产生。另外一种算法是广播算法。原理：每个commit操作后，节点向其它节点广播SCN，虽然会对系统造成负载，但是确保每个节点在commit后都能看到SCN号。10g RAC就是用的广播算法，可以在alert.log中看到。</p>
<p>1.25 当不同的实例请求相同的数据块，这个数据块就需要在实例间进行传递。oracle7的OPS中，这种传递是通过磁盘完成的。实例1必须先把这个块写回磁盘，然后实例2再从磁盘读取这个数据块。oracle8i只能传递没有修改过的数据块，对于修改的数据块还是要通过磁盘传递。9i才使用cache fusion通过私有网络传递数据块。</p>
<p>1.26 RAC和clusterware的交互。RAC集群和节点集群是两个层次的集群，两个集群都有脑裂，IO隔离等问题。这两个集群有各自的故障检测机制，二者之间的机制可以有重叠也可以不同。RAC的集群状态维护是由RAC的LMON进程提供的，这个进程提供了CGS和NM（node management）两个服务。NM是RAC集群和clusterware集群的通信通道，通过它把本节点的资源状态登记到本地的clusterware，进而由后者提供给其它节点的clusterware，NM还要从clusterware获得其它节点的资源状态。</p>
<p>NM组：RAC的每个实例的所有进程是作为一个组注册到clusterware中的，其中LMON进程作为组里的primary member注册并获得Member ID，而其它进程作为这个组的slave Member并以相同的member id注册到clusterware。整个集群的节点成员信息是通过一个位图来维护的，每个节点对应一个bit，0代表节点down，1代表up，整个位图有个有效/无效标志位。这个位图在整个集群中作为一个全局资源被永久记录。当有新的节点加入集群时，该节点需要读取该位图，找到对应的bit，把值从0改变成1，并且把位图的无效标志位置为1，这时虽然位图内容是正确的，但状态是无效的，其它节点发现这个状态位图无效，就会触发集群的重构，达到新的稳态后，再把位图状态置为有效，当集群完成重构后，NM会把这个事件传递给CGS层，CGS负责同步所有节点间的重构。对于实例的正常启动和关闭，该实例的NM会向clusterware进行注册或取消注册，注册过程中，NM同时从clusterware获得集群的其它节点列表，然后NM通知其它节点的NM，最后NM事件发送给CGS层，由CGS层负责协调整个集群的组重构，当CGS完成了重构之后，再通知GCS，GES进行实例重构（GRD层的重构）。对于实例的异常关闭，clusterware、NM就不会知道，这时就需要CGS提供的IMR功能进行感知，然后进行重构。</p>
<p>IMR的重构原理：IMR是由CGS提供的重构机制，用于确认实例之间的连通性、快速的排除故障节点以减少对数据的损害。在这个过程中，每个实例都需要做出投票，投票的内容是它所认为的整个集群现在的状态，然后由一个实例根据这些投票，重新规划出一个新的集群，并把这个投票结果记录到控制文件，其它实例读取这个结果，确认自己是否还属于集群，如果不属于集群，就要自动重启，如果属于集群则参与重构。IMR发现出现脑裂，即集群中出现两个group，这时IMR会先通知CM，然后等待CM去解决这个问题，等待时间是_IMR_SPLITBRAIN_RES_WAIT，缺省600毫秒，超时后IMR自己执行节点排除。在CGS完成节点的重构后，GCS，GES才进行数据层面的重构，也就是crash recovery。</p>
<p>重构触发类型：1,节点的加入或离开，由NM触发。2,网络心跳异常，超时时间默认300S，由_cgs_send_timeout参数控制，由IMR触发。3，控制文件心跳异常，超时时间默认900S，由_controlfile_enqueue_timeout参数控制，由IMR触发。</p>
<p>2.ASM存储方案</p>
<p>2.1red hat as4以后，裸设备已经被linux社区抛弃了，而是通过支持O_DIRECT标识来绕过OS缓冲。10gR2缺省就是用O_DIRECT的方式操作设备的。但是oracle clusterware 10R2的开发没能及时跟上，仍然需要使用裸设备来创建voting disk和OCR。</p>
<p>2.2 ASM中的shared pool有extent map，每100GB需要1MB的extent map，根据这个空间再加上额外的2MB就可以了，ASM SGA的默认值一般能满足要求。</p>
<p>2.3 ASM实例比RDBMS多出两个进程：RBAL和ABRn</p>
<p>RBAL：rebalancer进程，负责规划ASM磁盘组的reblance活动。</p>
<p>ABRn：RBAL的子进程，数量上可以有多个1-9，这组进程负责真正完成reblance活动。</p>
<p>2.4 使用ASM作为存储的RDBMS实例，会多出两个进程：RBAL和ASMB</p>
<p>RBAL:打开每个磁盘组的所有磁盘和数据的rebalance。</p>
<p>ASMB:负责与ASM实例的通信，它先利用diskgroup name从CSS获得管理改diskgroup的ASM实例的连接串，然后建立到ASM的持久连接，两个实例通过这条连接定期交换信息，同时也是一种心跳机制。</p>
<p>RDBMS要想使用ASM作为存储，必须在启动时从ASM实例获得extent map，以后发生磁盘组的维护操作，ASM实例还要把extent map的更新信息通知给RDBMS，这两个实例间的信息交互就是通过ASMB进程完成的。因此ASM实例必须先于数据库实例的启动。</p>
<p>O0nn 01-10：这组实例建立到ASM实例的连接，某些长时间操作比如创建数据文件，RDBMS会通过这些进程向ASM发送信息。</p>
<p>2.5 ASM实例运行不需要任何文件只是表面现象，其实ASM也需要很多文件来保证它的运行，只不过这些文件是oracle内部维护的，对DBA不可见，也不需要DBA的干预。</p>
<p>2.6 ASM实例和RDBMS是1：1的关系，两个实例可以共用一个$ORACLE_HOME。ASM和RDBMS是1：n的关系，则最好为ASM安装单独的ASM_HOME，并和RDBMS的ORACLE_HOME区分开来，这种环境需要使用ASM_HOME下的监听器。</p>
<p>2.7 创建ASM磁盘：首先要让ASM实例发现磁盘，另外要让磁盘分区的属主设成oracle。接下来就是创建ASM磁盘，ASM可以通过两种方式使用磁盘，一是裸设备方式，二是ASMlib方式（允许在块设备上创建ASM，目前oracle只提供了linux下的ASMlib)。</p>
<p>2.8 使用裸设备。solaris平台下，系统同时提供对磁盘设备的字符（c）、块（b）方式访问。每个磁盘有两个设备文件名（/dev/dsk/c1t1d1s1;/dev/rdsk/c1t1d1s1),创建ASM直接用这些设备名就可以了，无需额外配置裸设备。AIX也是一样的道理。linux平台比较麻烦，缺省没有提供对磁盘设备的字符访问方式，必须配置rawdevices服务，把块设备绑定到裸设备才行。这里有三种方式来配置。只要区别在于对oracle用户权限处理方法不同。</p>
<p>方式1：#vi /etc/sysconfig/rawdevices 添加裸设备、块设备的绑定条目：/dev/raw/raw30 /dev/sdc1     /dev/raw/raw31 /dev/sdc2   …  –&gt; #service rawdevices start  –》#chkconfig rawdevices on(系统启动时，自动启动rawdevices服务）  –》#service rawdevices status  –》cd /dev/raw;ll(查看裸设备）  –》#cd /dev/raw;chown oracle:dba raw*  –&gt;在/etc/rc.local或其它脚本中添加改raw设备属性的命令。(因为rawdevices是以root运行的，因此裸设备缺省的owner是root:root)</p>
<p>方式2：#mknod /oradata/system.dbf c 162 1(这里的162，1分别是major device number，minor device number） –》#chown oracle：dba /oradata/system.dbf  –&gt;#vi /etc/sysconfig/rawdevices</p>
<p>/oradata/system.dbf /dev/sdd7   –&gt;#service rawdevices restart 服务重启后会在/dev/raw目录下创建出一个新的裸设备。</p>
<p>方式3：适合在red hat as4使用，这个版本是用UDEV来管理设备，设备启动后的属主可以在文件中配置。前面的步骤跟方式一样，权限的修改步骤如下：#vi /etc/udev/permissions.d/50-udev.permissions  找到raw一节，修改成下面内容：raw/*:oracle:dba:0660  –&gt;#service rawdevices restart   RHEL5 UDEV的工作方式又发生了变化，50-udev.permissions 文件被抛弃，而使用rule文件来配置。</p>
<p>2.9 ASMlib方式。ASMlib是一个由ORACLE定义接口、由存储厂商实现的函数库，目前oralce只提供了linux平台下的实现库。下载ASMlib时要选择和OS内核匹配的版本。安装完成后，配置驱动（#/etc/init.d/oracleasm configure) ,确认配置成功（#lsmod |grep asm;cat /proc/filesystem;df -ha）。创建ASM磁盘（#/etc/init.d/oracleasm createdisk VOL1 /dev/sdb1 …),这时能在/dev/oracleasm/disks目录下看到createdisks创建的磁盘VOL1。列出创建好的磁盘（#/etc/init.d/oracleasm listdisks),进一步查看每个ASM磁盘对应的物理设备（#/etc/init.d/oracleasm querydisk VOL1)。如果是RAC环境，只需要在一个节点上执行，其它节点执行这个命令就可以扫描的磁盘了，#/etc/init.d/oracleasm scandisks。</p>
<p>2.10 如果完全使用裸设备实现RAC，配置存储的时候有两点需要注意：1、保证LUN在各节点上的顺序一样。2、设备名对应的物理设备不会因为系统的重启发生变化。比如sda、sdb这类名字，到底是a还是b取决于总线对硬件的扫描顺序。RAC环境中一个节点连着两套存储，一套是本地，另一套是通过HBA卡连接的SAN，HBA卡和本地盘的扫描顺序决定着这类名字对应的设备的变化。为了避免这种不一致，要在/etc/mobprobe.conf中添加两行，强迫扫描本地盘，再扫描HBA。（alias scsi_hostadapter1 aic7xxx   alias scsi_hostadapter2 lpfc)不过到了RED HAT AS4默认就是这种顺序了。如果使用ASM就不需要这些配置，ASM磁盘头会有metadata信息可以准确的识别磁盘。但是磁盘名称在所有节点一致仍然是一个好习惯。</p>
<p>2.11 major number，minor number。前者找到设备驱动程序，后者找到设备具体位置。major number，minor number是预先分配好的，比如裸设备的major number是162，SCSI设备的major number是8。SCSI设备的minor number=driver*16 + partition number。SCSI设备的用户空间名是sd driver partition。linux下SCSI磁盘/dev/sda的partition number是0，代表整个磁盘，linux每个磁盘最多有16个分区，其中分区4代表整个扩展分区，可用分区只有15个。</p>
<p>2.12 配置ASM实例：先介绍几个初始化参数。ASM_POWER_LIMIT:当在磁盘组中添加或删除磁盘时，磁盘组会自动对数据在新旧磁盘间重新分配，从而实现分散IO，这个过程叫再平衡（rebalance）。取值范围0-11。0代表不做rebalance，11代表最快的速度做rebalance，也意味着最严重的性能影响。alter diskgroup dg1 add disk ‘a’ rebalance power 1 (往磁盘组增加一个磁盘a，并定义rebalance为1。）</p>
<p>ASM_DISKSTRING:定义哪些磁盘可以被ASM使用。使用ASMlib时，需要使用”ORCL:磁盘名“格式。ASM实例也可以使用SPFILE。</p>
<p>无论是否在RAC环境，ASM实例都需要CSS进程，否则会报29701的错误。启动CSS进程的命令如下：/oracle/product/10.2.0/db1/bin/localconfig add</p>
<p>创建磁盘组的操作需要连接到ASM实例中进行，记得创建一个spfile文件。SQL&gt;create diskgroup dg1 external redundancy disk ‘ORCL:VOL1’,’ORCL:VOL2’;(创建磁盘组dg1）。</p>
<p>现在RDBMS可以使用ASM的磁盘组了。使用前必须保证ASM实例已经注册到Listener,否则需要手工注册（SQL&gt;alter system register;)。使用ASM的磁盘组中的磁盘很简单（SQL&gt;create tablespace test datafile ‘+dg1/test.dbf’ size 100M;)。RDBMS在运行的时候，ASM实例是无法关闭的，手工关闭也不可能。</p>
<p>3.RAC维护工具集</p>
<p>oracle clusterware命令集的分类：</p>
<p>节点层：olsnodes</p>
<p>网络层：oifcfg</p>
<p>集群层：crsctl ocrcheck ocrdump ocrconfig</p>
<p>应用层：srvctl onsctl crs_stat</p>
<p>oifcfg的4个子命令：iflist;getif;setif;delif    举例：</p>
<p>$oifcfg iflist    –显示网口列表</p>
<p>$oifcfg getif     –查看每个网卡的属性</p>
<p>$oifcfg getif -global dbp   –查看节点dbp的global类型的配置</p>
<p>$oifcfg getif -type public  –查看public类型的网卡配置</p>
<p>$oifcfg getif -type cluster_interconnect</p>
<p>$oifcfg setif -global ten@none/10.0.0.1:public   –添加新的网卡，这个命令并不会检查网卡是否真的存在。</p>
<p>$oifcfg delif -global  –删除接口配置</p>
<p>$oifcfg setif -g global eth0/192.168.12.1:public   –添加接口配置</p>
<p>$oifcfg setif -g global eth1/10.0.0.0:cluster_interconnect</p>
<p>$crsctl check crs   –检查CRS状态</p>
<p>$crsctl check cssd/crsd/evmd    –分别检查三个组件的状态</p>
<p>CRS进程默认随着OS的启动而自动启动，有时出于维护的目的需要停止这个进程，可以用以下命令：</p>
<p>#/oracle/product/oem/crs/bin/crsctl disable/enable crs</p>
<p>这个命令实际上是修改了/etc/oracle/scls_scr/dbp/root/crsstart 这个文件的内容。</p>
<p>启动、停止CRS棧：crsctl start/stop crs</p>
<p>$crsctl get query css votedisk   –查看votedisk磁盘的位置。</p>
<p>$crsctl get css misscount   –查看参数</p>
<p>$crsctl set css miscount 100   –设置参数</p>
<p>CRS由CRS、CSS、EVM3个服务组成，每个服务又是由一系列module组成的。CRSCTL允许对每个module进行跟踪，并把跟踪内容记录到日志中。</p>
<p>$crsctl lsmodules css/crs/evm</p>
<p>#/oracle/product/oem/crs/bin/crsctl debug log css “CSSD:1”   –跟踪CSSD模块。</p>
<p>#more $CRS_HOME/log/dbp/cssd/ocssd.log  –查看跟踪产生的日志。</p>
<p>维护votedisk：可以通过crsctl命令添加votedisk，votedisk使用是的是一种过半数的算法，所以添加votedisk应该添加两个。添加和删除votedisk的操作比较危险，必须停止数据库、停止ASM、停止CRS后操作，并且操作时必须使用-force参数。举例如何添加一个votedisk：</p>
<p>1.#$ORA_CRS_HOME/bin/crsctl add css votedisk /dev/raw/raw1 -force</p>
<p>  #$ORA_CRS_HOME/bin/crsctl add css votedisk /dev/raw/raw2 -force</p>
<p>2.#$ORA_CRS_HOME/bin/crsctl query css votedisk</p>
<p>3.#crsctl start crs  </p>
<p>OCR系列命令：ORACLE会每4个小时对OCR做一个备份，并且保留最后3个备份，以及前一天，前一周的最后一个备份。这个备份由master node的CRSD进程完成，备份的默认位置为：$CRS_HOME/crs/cdata/<cluster_name>目录下，每次备份后，备份文件名会自动更改，最近一次备份叫backup00.ocr。建议DBA除了保存在本地外，还应该在其它地方保存一份。</p>
<p>ocrdump：以ASCII的方式打印出OCR的内容，产生的文件只能用于阅读，不能用于恢复。</p>
<p>$ocrdump -stdout -keyname SYSTEM.css -xml|more  –把SYSTEM.css键的内容以.xml格式打印输出到屏幕。命令的执行过程中，会在$CRS_HOME/log/<nodename>/client目录下产生名为ocrdump_<pid>.log的日志文件，如果命令出现执行问题，可以查看这个日志。</p>
<p>ocrcheck：用于检查OCR内容的一致性，不需要参数。这个命令会产生ocrcheck_pid.log日志文件。</p>
<p>ocrconfig：用于维护OCR磁盘，OCR磁盘最多只能有两个，一个是primary OCR，另一个是Mirror OCR。</p>
<p>$ocrconfig -help   –查看命令帮助</p>
<p>$ocrconfig -showbackup  –查看自动备份，OCR的自动备份在$CRS_HOME/crs/cdata/<cluster_name>目录ixa，可以通过ocrconfig -backuploc <directory_name>命令修改到新目录。</p>
<p>OCR的备份与恢复：oracle推荐在对集群作调整时，比如增加、删除节点前，应该对OCR做一个备份。可以使用export备份到指定文件。如果做了replace或restore等操作，oracle建议使用cluvfy comp ocr -n all命令做一次全面检查。下面举一个OCR备份与恢复的案例：</p>
<p>1.crsctl stop crs</p>
<p>2.ocrconfig -export /oracle/ocr.exp  (注意这里要用root用户导出）</p>
<p>3.crsctl start crs</p>
<p>4.crsctl check crs</p>
<p>5.dd if=/dev/zero of=/dev/raw/raw1 bs=1024 count=102400  (故意破坏ocr内容）</p>
<p>6.ocrcheck   –检查会失败。</p>
<p>7./backup/install_medir/clusterware/cluvfy/runcluvfy.sh comp ocr -n all   –检查一致性也失败。</p>
<p>8.ocrconfig -import /oracle/ocr.exp   –恢复OCR内容。</p>
<p>9.再次用刚才的两个工具进行检查。</p>
<p>10.crsctl start crs</p>
<p>移动OCR的位置：（/dev/raw/raw1移到/dev/raw/raw31)</p>
<p>1.ocrconfig -showbackup /  ocrconfig -export /tmp/ocrexp -s online   –查看OCR是否有备份，如果没有执行一次导出做备份。</p>
<p>2.ocrcheck   /  ocrconfig -replace ocrmirror  /dev/raw/raw21    –查看当前OCR的位置，发现只有一个primary ocr，没有mirror ocr，所以不能直接改变OCR的位置，需要添加镜像再修改OCR位置。</p>
<p>3.ocrcheck  –验证一下是否添加成功。</p>
<p>4.ocrconfig -replace ocr /dev/raw/raw31   –改变位置。</p>
<p>5.检查/etc/oracle/ocr.loc文件。系统默认会修改这个文件，如果没有更改，需要手工修改相应的条目。</p>
<p>crs_stat  –查看CRS维护的所有资源的运行状态，包括2个GSD,ONS,VIP,ASM INSTANCE,LISTENER,RDBMS INSTANCE和1个database。使用-v -p参数可以获得更详细的信息。 -ls选项可以获得每个资源的权限定义。</p>
<p>onsctl  –这个命令用于管理配置ONS（oracle notification service），ONS是oracle clusterware实现FAN(fast application notification）Event push模型的基础。传统模型中，客户端需要定期检索服务器来判断服务端状态，本质上是一个PULL模型。10g引入了一种全新的PUSH机制-FAN，当服务端发生某些事件时，服务器会主动的通知客户端这种变化，这样客户端能尽早知道服务端的变化，而这种机制就是依赖ONS实现的。在使用这个命令之前，需要先配置ONS服务。</p>
<p>ONS配置内容：配置文件在$CRS_HOME/opmn/conf/ons.config,注意这个文件中的nodes和useocr这两个参数。这两个参数共同决定了本机ONS daemon要和哪些远程节点上的ONS daemon进行通信。如果useocr=ON，说明信息保存在OCR中，如果是OFF说明信息取nodes中的配置。对于单实例而言，要把useocr设置成OFF。看几个配置的例子：</p>
<p>useocr=off</p>
<p>nodes=dbs：6200，dbp：6200</p>
<p>（节点信息从nodes参数读取，本机的ONS要和这dbs，dbp两个节点上的6200端口通信）</p>
<p>useocr=on</p>
<p>（使用OCR时，这个信息是保存在DATABASE.ONS_HOSTS这个键下。可以把这个键从OCR导出来：ocrdump -xml abc.xml -keyname DATABASE.ONS_HOSTS)。</p>
<p>可以直接编辑这个配置文件来配置ONS，如果使用了OCR则可以通过racgons命令进行配置。举个例子：</p>
<p>racgons add_config dbs:6200 dbp:6200  –添加配置</p>
<p>racgons remove_config dbs:6200 dbp:6200  –删除配置</p>
<p>ONS进程运行，并不代表ONS正常工作，需要使用ping命令来确认。比如ps -ef|grep ons可以看到ONS进程正常运行，但onsctl ping看到ons is not running…,启动ONS服务：onsctl start 再次确认ONS服务状态，已经ok。 $onsctl debug  –查看详细信息。</p>
<p>srvctl –RAC维护中最常用的命令，也是最复杂的命令。</p>
<p>查看配置：</p>
<p>$srvctl config database   –显示在OCR中注册的所有数据库</p>
<p>$srvctl config database -d a  –查看数据库a的配置</p>
<p>$srvctl config database -d a -a –查看数据库a更详细的配置</p>
<p>$srvctl config nodeapps -n dbs  –返回节点名、实例、$ORACLE_HOME</p>
<p>$srvctl config nodeapps -n dbs -a  –查看VIP配置</p>
<p>$srvctl config nodeapps -n dbs -g  –查看GSD</p>
<p>$srvctl config nodeapps -n dbs -s  –查看ONS</p>
<p>$srvctl config nodeapps -n dbs -l  –查看listener</p>
<p>$srvctl config listener -n dbs   –查看监听器的名称</p>
<p>$srvctl config asm -n dbp   –查看ASM实例名和$ORACLE_HOME</p>
<p>$srvctl config service -d test -a  –查看数据库的所有service配置</p>
<p>$srvctl add database -d abc -o $ORACLE_HOME  –添加数据库</p>
<p>$srvctl add instance -d abc -n dbs -i abc2  –添加实例</p>
<p>$srvctl add service -d abc -s abcservice -r abc1 -a abc2 -P BASIC  –添加服务</p>
<p>配置数据库随CRS的启动而自动启动：</p>
<p>srvctl enable/disable database -d test   –启动/关闭数据库的自动启动特性</p>
<p>srvctl config database -d test -a  –确认配置是否成功</p>
<p>srvctl enable/disable instance -d test -i abc1  –开启/关闭某个实例的自动启动</p>
<p>srvctl disable service -d test -s abcservice -i abc1  –禁止服务在某个实例上运行</p>
<p>$srvctl remove service -d test -s abcservice  –删除service</p>
<p>$srvctl remove instance -d test -i abc1  –删除abc1</p>
<p>$srvctl remove database -d test  –删除数据库</p>
<p>remove命令删除的只是对象在OCR中的定义信息，对象本身不会被删除。</p>
<p>$srvctl start database -d test   –启动数据库。</p>
<p>$srvctl start database -d test -i abc1 -o mount  –启动实例abc1到mount状态。</p>
<p>$srvctl stop instance -d test -i abc1 -o immediate</p>
<p>$srvctl stop instance -d test -i abc1 -o abort</p>
<p>$srvctl start service -d test -s abcservice -i abc1</p>
<p>$srvctl status service -d test -v</p>
<p>跟踪srvctl：10g中跟踪srvctl，只需要设置SRVM_TRACE=true这个OS环境变量即可，这个命令的所有函数调用会输出到屏幕上。</p>
<p>一个恢复案例（OCR磁盘和votedisk磁盘全部破坏，并且没有备份）：</p>
<p>1.crsctl stop crs  –停止所有节点的clusterware stack</p>
<p>2.$CRS_HOME/install/rootdelete.sh   –分别在每个节点执行这个脚本。</p>
<p>3.$CRS_HOME/install/rootdeinstall.sh  –只需要在一个节点上执行即可。</p>
<p>4.$CRS_HOME/root.sh  –在和步骤3同一个节点执行这个脚本。</p>
<p>5.$CRS_HOME/root.sh  –在其它节点执行这个脚本。</p>
<p>6.用netca命令重新配置监听器，确认注册到了clusterware中：crs_stat -t -v</p>
<p>7.srvctl add asm -n dbs -i +ASM1 -o /oracle/product/database</p>
<p>  srvctl add asm -n dbp -i +ASM2 -o /oracle/product/database</p>
<p>8.srvctl start asm -n dbs</p>
<p>  srvctl start asm -n dbp(这里出现了ORA-27550：的错误，这个问题是因为RAC无法确认使用哪个网卡作为private interconncect，所以可以通过在两个ASM实例的pile中添加以下参数解决这个问题。</p>
<p>+ASM1.cluster_interconnects=’10.0.0.8’</p>
<p>+ASM2.cluster_interconnects=’10.0.0.9’</p>
<p>重启ASM，问题得到解决)</p>
<p>9.srvctl add database -d test -o /oracle/product/database</p>
<p>10.srvctl add instance -d test -i abc1 -n dbs</p>
<p>   srvctl add instance -d test -i abc2 -n dbp</p>
<p>11.srvctl modify instance -d test -i abc1 -s +ASM1   –修改实例和ASM实例的依赖关系</p>
<p>   srvctl modify instance -d test -i abc2 -s +ASM2</p>
<p>12.srvctl start database -d test(启动过程又出错，跟ASM问题相同，解决办法类似，修改database参数即可，如下：</p>
<p>SQL&gt;alter system set cluster_interconnect=’10.0.0.8’ scope=spfile sid=’abc1’;</p>
<p>SQL&gt;alter system set cluster_interconnect=’10.0.0.9’ scope=spfile sid=’abc2’;)</p>
<p>srvctl start database -d test  –重启数据库，操作成功。</p>
<p>4.HA和LB</p>
<p>HA=MTTF/(MTTF+MTTR)  MTTF=平均故障间隔时间   MTTR=平均修复时间</p>
<p>10g RAC failover的分类：client-side connect time failover;TAF;service-side TAF</p>
<p>注意：不要在listner.ora中设置GLOBAL_DB_NAME，这个参数会禁用connect_time failover和transparent application failover</p>
<p>client-side connect time failover:用户端tnsname中配置了多个地址，用户发起连接请求时，先尝试第一个地址，如果连接失败尝试第二个地址，直到遍历所有地址。它的特点是只在发起连接的时候才去感知节点故障，一旦连接建好后，节点故障不会处理，客户端的表现就是会话断开，用户程序必须重新建立连接。在tnsnames.ora添加FAILOVER=ON条目即可实现此功能，系统默认就能实现这种功能。</p>
<p>TAF：如果某个实例发生故障，连接到这个实例上的用户就会被自动迁移到其它的健康实例上。迁移对应用程序而言是透明的，但用户未提交的事务会回滚。TAF的配置也很简单，只要在tnsnames.ora添加FAILOVER_MODE配置项，这个条目有4个子项目需要定义。METHOD=BASIC/PRECONNECT  (BASIC:感知节点故障时才创建到其它实例的连接。 PRECONNECT:在最初建立连接时就同时建立到所有实例的连接，这样切换速度就快)。  TYPE=session/select(session:对于select语句切换后需要重新执行查询语句。 select：对于select语句切换后在新的几点继续返回剩下的记录。两种方式对未提交的事务都自动回滚）。</p>
<p>DELAY和RETRIES表示重试间隔时间和重试次数。</p>
<p>service-side TAF：直接在服务器上修改配置，无需修改客户端的tnsnames.ora文件。它通过结合service在数据库里保存FAIL_MODE的配置，把所有的TAF配置保存在数据字典中，省去了客户端的配置工作。</p>
<p>service-side TAF比TAF多出了一个instance role，所谓实例角色，就是有多个instance参与一个service时，可以配置优先使用哪个instance为用户提供服务，用户共有两种可选角色：</p>
<p>PREFERRED:首选实例  AVAILABLE:后备实例。要想实现这个功能必须配置services（DBCA，手工方式（srvctl)都可以配置）。使用srvctl这个工具时，命令只更新OCR中的配置，不会更新数据字典和监听器中的信息，因此还要用dbms_service包来更新数据字典。无论使用DBCA还是srvctl命令来配置service，都无法配置TAF的type、delay、retries3个属性。必须使用dbms_services包来修改这些属性。10g配置了service-side TAF，客户端甚至都不需要tnsnames.ora文件。10g提供新连接方法：easy connect naming methods。连接串格式如下：username/password@[//]host[:port][/service_name]</p>
<p>oracle clusterware HA框架：这里强调的是oracle clusterware是一款独立的集群件产品，不只是针对RAC，另外oracle也提供了API，用户可以进行二次开发实现更丰富的功能。详见书的P210。</p>
<p>LOADBALANCE:10g RAC提供两种手段实现分散负载：纯技术的分散负载;面向业务的的分散负载。</p>
<p>纯技术的分散负载有两种实现方法：客户端均衡;服务器端均衡</p>
<p>客户端均衡：oracle8实现的方法，使用随机算法把连接请求分散到各个实例，这种分配方法没有考虑每个节点的真实负载。</p>
<p>服务器端均衡：oracle9引进的方法。负载均衡的实现依赖于listener收集的负载信息，PMON进程会收集系统的负载信息，然后登记到listener中，最少1分钟，最多10分钟PMON要做一次更新，节点负载越高，更新频率越高。如果listener关闭，PMON会每隔1秒钟检查listener是否重启。除了自动定时更新任务外，用户也可以使用alter system register命令手工进行这个过程。整个过程可以在listener日志看到。我们也可以使用1025事件跟踪PMON进程，来查看注册的内容。PMON不仅会向本地注册，还可以向其它节点上的listener注册，但到底向何处注册，是由remote_listeners决定的，参数值是一个tnsnames项。</p>
<p>客户端均衡和服务器端均衡不是互拆的，两者可以一起工作。配置LB时有点需要注意：需要将各个实例的listener.ora文件中去掉缺省产生的sid_list_listener_name条目，这样才能保证listener获得的信息都是动态注册的，而不是从文件中读取的静态信息。</p>
<p>利用service分散负载：通过把应用按照功能模块进行划分成service，进而把每个service固定在某些RAC节点上。（cache fusion减少了）</p>
<p>5.备份</p>
<p>flash recovery area：闪回恢复区可以集中存放所有与恢复有关的文件，这些文件包括以下几类：</p>
<p>控制文件（创建db时使用了闪回恢复区，会自动在这里创建一个控制文件的copy）</p>
<p>控制文件和spfile的自动备份</p>
<p>备份集backup set文件</p>
<p>image copy文件</p>
<p>归档日志，log_archive_dest_10会自动指向flash recovery area</p>
<p>闪回日志（闪回数据库需要这种功能）</p>
<p>10g中的闪回功能家族中，只有闪回数据库和闪回恢复区有关系（闪回日志必须放在闪回恢复区），其它的没有直接关系。</p>
<p>10g中的v$logfile,v$control_file,v$datafile_copy,v$backup_piece,v$archived_log 这些视图中也增加了</p>
<p>is_reconvery_dest_file列，代表该文件是否放在recovery area中。</p>
<p>RMAN&gt;select name,is_recovery_dest_file from v$archived_log;</p>
<p>配置闪回区：RAC环境下的配置，要保证每个节点的配置值都相同。可以在线修改，立即生效：</p>
<p>SQL&gt;alter system set db_recovery_file_dest=’+DISKA’ scope=both;</p>
<p>SQL&gt;alter system set db_recover­y_file_dest_size=’5g’ scope=both sid=’*’;</p>
<p>使用ASM作为闪回区，只能指定到diskgroup级别，而不能指定到目录，ASM存储管理是采用OMF方式，每个数据库会被分配到指定目录diskgroup/instance_name。</p>
<p>闪回区的监控：当空间使用率达到90%，会自动触发删除，如果没有空间可以释放，并且使用空间超过85%，会记录一条warning日志，如果超过97%会记录一条critical warning日志，这些日志内容可以从DBA_OUTSTANDING_ALERTS视图查看。闪回区的使用情况可以通过v$recovery_file_dest来进行监控。</p>
<p>RMAN使用方法：</p>
<p>1.批处理方法：把命令写入文本文件。cat back</p>
<p>run {</p>
<p>backup database;</p>
<p>}</p>
<p>通过cmdfile指定命令文件，使用log指定日志文件：</p>
<p>$rman target / cmdfile=back log=back.log</p>
<p>2.脚本方式：需要恢复目录，脚本分local和global两种。</p>
<p>local：连接到target db和catalog db</p>
<p>RMAN&gt;create script full_bakcup</p>
<p>{</p>
<p>backup database plus archivelog</p>
<p>delete obsolete;</p>
<p>}</p>
<p>global：需要用global关键字</p>
<p>RMAN&gt;create global script global_full_backup</p>
<p>{</p>
<p>backup database plus archivelog;</p>
<p>delete obsolete;</p>
<p>}</p>
<p>使用脚本： RMAN&gt;run { execute script full_bakcup；}</p>
<p>备份格式：image copy只能在磁盘上进行，backup set是一种压缩格式，RMAN能跳过空数据块，备份的时候还可以额外压缩，但image copy比backup set的restore速度快，尽管它占用较多的空间。</p>
<p>RMAN的备份保留策略： RMAN&gt;configure retention policy to recovery window of 7 days;</p>
<pre><code>RMAN&gt;configure retention policy to redundancy 2;</code></pre><p>RMAN&gt;report obsolete;</p>
<p>RMAN&gt;report obsolete recovery window of 7 days;</p>
<p>RMAN&gt;report obsolete redundancy 2;</p>
<p>RMAN&gt;show retention policy;</p>
<p>RMAN&gt;delete obsolete;</p>
<p>RMAN&gt;delete obsolete redundancy 2;</p>
<p>RMAN&gt;delete obsolete recovery window of 4 days;</p>
<p>RMAN&gt;configure retention policy to none;</p>
<p>RMAN只能对数据文件进行增量备份，控制文件、日志文件不能增量备份。增量备份能够捕获nologging操作的数据变化，而这些操作不会被记录到日志上。</p>
<p>backup as copy db_file_name_convert=(‘+data/wxxrzxm’,’/backup/test’) database;   –路径的转变。</p>
<p>如果想把ASM上的数据文件备份到ASM上，上述方法可能会出错，因为ASM是使用OMF方式管理数据文件的。</p>
<p>增量备份：oracle10g只允许0和1两级了，0级相当于全备，但不能作为0级使用。</p>
<p>种类：RMAN&gt;backup incremental level 1 database;   –差异增量</p>
<pre><code>RMAN&gt;backup incremental level 1 cumulative database;  --累加增量</code></pre><p>举个例子：</p>
<p>RMAN&gt;run {</p>
<pre><code> backup as copy db_file_name_convert=(&apos;+DATA/wxxrzm&apos;,&apos;/backup/test&apos;) incremental level 0 database tag &apos;full_backup&apos;;

&#125;</code></pre><p>RMAN&gt;run {</p>
<pre><code>backup incremental level 1 CUMULATIVE for recover of copy with tag &apos;full_backup&apos; database;

recover copy of database with tag &apos;full_backup&apos;;

&#125;</code></pre><p>增量备份为了获得要备份的数据块，必须对数据文件中的所有数据块进行遍历，效率不高。因此oracle提供了一个特殊的文件叫block change tracking file，每当数据块发生变化时，相关信息同时记录到这个文件中。</p>
<p>SQL&gt;alter database enable/disable block change tracking;   –启用关闭该功能。</p>
<p>SQL&gt;select * from v$block_change_tracking;  –查看文件的位置。</p>
<p>SQL&gt;alter database enable block change tracking using file ‘path’   –手工指定文件位置。</p>
<p>启用这个特征后oracle会启动一个ctwr进程，它负责跟踪数据变化。</p>
<p>RMAN&gt;backup duration 2:00 database;  –希望在2小时内完成备份，如果无法完成，整个任务都会出错返回，产生的备份文件也不可用。</p>
<p>RMAN&gt;backup duration 2:00 partial database filesperset 1;  –保证产生的每个备份文件都对应一个数据文件。完成的备份保留。</p>
<p>RMAN&gt;backup duration 0:01 minimize load database;</p>
<p>RMAN&gt;backup duration 0:01 minimize time database;</p>
<p>恢复命令：10G，restore命令增加了一个preview子命令。举例如下：</p>
<p>$rman / target</p>
<p>RMAN&gt;spool log to test.log</p>
<p>RMAN&gt;restore datafile 1 preview;</p>
<p>RMAN&gt;restore database preview summary;</p>
<p>RMAN&gt;spool log off;</p>
<p>RMAN&gt;list backup;</p>
<p>RMAN&gt;list copy;</p>
<p>RMAN&gt;crosscheck copy;</p>
<p>RMAN&gt;delete expired copy;  –list显示的信息是从控制文件获得，如果用rm命令删除copy这个动作不会同步到控制文件，这会造成不一致。</p>
<p>v$rman_output:查看每个备份任务的日志。  v$rman_status：查看备份任务的完成情况。</p>
<p>RAC的备份：RAC的备份与单实例备份有两点需要注意：1.RMAN连接集群中的某个实例即可。 2.备份归档时，必须保证在备份实例上能够访问所有实例的归档日志，否则会报错。</p>
<p>SQL&gt;alter system set log_archive_dest_state_2=defer scope=both sid=’*’;</p>
<p>注意10g里增加的新参数log_archive_local_first参数，10g以前本地和远程的归档都完成后，联机日志文件才能被重用。这个参数设置为true后，oracle先进行本地归档，然后同时远程传递和使用联机日志。</p>
<p>6.恢复</p>
<p>修改数据块之前，代表本次修改操作的redo记录必须先要被保存下来，然后才能修改数据记录。旧的日志被覆盖前需要完成两件事：1，检查点必须完成。2，完成归档。</p>
<p>SCN的种类：系统检查点SCN–记录在控制文件中（v$database可以看到）。  数据文件检查点SCN–记录在控制文件中（v$datafile)。 数据文件的启动、终止SCN–数据文件头记录启动scn（v$datafile_header)，控制文件记录数据文件的终止scn。这两个SCN用来确认数据文件是否需要恢复。数据库运行中，所有数据文件的终止SCN都是null，正常关闭数据库后数据文件的终止scn会被设置成启动scn，异常关闭数据库后，终止scn来不及修改还是null。</p>
<p>每个实例对应的联机日志就是一个redo thread。rac环境下每个实例都需要自己的联机日志，也就是每个实例都有自己的redo thread，所以在rac下添加日志时必须指定线程号：</p>
<p>SQL&gt;alter database add logfile thread 1 group 5(‘/oracle/oradata/redo5’) size 50m;</p>
<p>日志切换触发检查点，检查点启动DBWR把data buffer cache中的dirty block写入磁盘，当该联机日志所覆盖的操作都被同步到数据时，这个联机日志文件就可以被重用了。但是dirty blcok在磁盘上不是连续分布的，所以日志切换要等待DBWR写完，这就会导致用户进程必须长时间的等待。oracle 8开始出现了增量检查点的算法。执行检查点时，只在控制文件中记录当时的检查点SCN，然后DBWR在后台进程进行写操作，每隔3s，DBWR会在控制文件中更新checkpoint progress record，代表工作进展情况，而用户进程继续前台操作，不受DBWR的影响。</p>
<p>记住RAC下的联机日志必须放在共享存储上，因为恢复时必须把所有实例的联机日志都合并，把redo log record按照SCN排序。</p>
<p>crash recovery：RAC下某个实例发生了crash后在其它实例上进行的recovery。在执行crash recovery时，故障节点被IO fencing，即故障节点不能对共享数据进行操作。</p>
<p>PCM-lock：用来描述数据块的buffer copy在不同实例间的分布情况。它有三个属性：MODE,ROLE,PAST IMAGE。具体参见书的P270。可以根据其它节点上的PCM-lock推断出哪些数据块需要恢复。关于crash recovery的过程详见p273。</p>
<p>online block recovery：某个用户进程修改数据时异常死掉，导致data buffer数据不一致，这时就会触发online block recovery动作。这个动作找到一个恢复起点（最近的past image）应用联机日志进行恢复。</p>
<p>完全恢复的一个特殊案例：数据结构改变后的恢复</p>
<p>先做一个全备份，然后添加一个数据文件，并创建一个表空间，同时增加一些数据。–》关闭数据库，模拟灾难。删除刚才新建的数据文件。–》启动数据库，因为删除的数据文件没有备份，所以restore，recover的方法都不行。 –》只能用alter database create datafile重建数据文件（无需指定数据文件所属的表空间，也不用指定数据文件大小，因为这些属性在控制文件都有记录） –》在ASM里要注意，你指定建的数据文件名可能跟控制文件记录的数据文件名不同。这时需要将控制文件记录的数据文件名rename成ASM里记录的数据文件名。SQL&gt;alter database rename file ‘’ to ‘’  –&gt;再次recover datafile就可以了。</p>
<p>ASM也可以像目录一样操作：</p>
<p>$export ORACLE_SID=+ASM1</p>
<p>$asmcmd -p</p>
<p>ASMCMD[+] &gt;cd +DATA2/DB/controlfile/</p>
<blockquote>
<p>ls</p>
</blockquote>
<blockquote>
<p>rm …</p>
</blockquote>
<p>不完全恢复的一个案例：</p>
<p>1.RMAN&gt;backup database;   –先做一个全备份。</p>
<p>2.abort数据库，进ASM删除数据文件、联机日志、控制文件。</p>
<p>3.SQL&gt;startup nomount;</p>
<p>4.RMAN&gt;restore controlfile from ‘自动备份‘</p>
<p>5.RMAN&gt;sql ‘alter database mount’;</p>
<p>6.RMAN&gt;restore database;  –恢复过程中，数据文件被自动改名，并且改动被同步到控制文件中。</p>
<p>7.确定恢复终点。控制文件记录的归档文件（v$archived_log)和磁盘上的归档文件数量不一样，有4个文件时备份之后产生的。</p>
<p>8.RMAN&gt;catalog archivelog ‘归档’;   –将备份后产生的归档登记到控制文件。</p>
<p>9.SQL&gt;recover database using backup controlfile until cancel;  –执行不完全恢复。如果使用RMAN工具，需要使用set until提前指定恢复终点：</p>
<p>RMAN&gt;run {</p>
<p>set until sequence 64 thread 2;</p>
<p>restore database;</p>
<p>recover database;</p>
<p>}</p>
<p>10.RMAN&gt;sql ‘alter database open resetlogs’;</p>
<p>11.$srvctl start database -d test   –打开其它实例。</p>
]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>ORACLE</tag>
        <tag>数据库集群</tag>
      </tags>
  </entry>
</search>
